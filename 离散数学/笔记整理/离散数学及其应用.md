# 离散数学及其应用

## 第一章

### 1.1	命题逻辑

#### 命题(Propositions)

命题：命题是一个陈述语句，它只能是真或者假。

一般用字母表示命题，命题为真用T表示，假用F表示。

不能再由其他的命题组成的命题是**原子命题**（也就是不能再分析的命题）。



复合命题：由已知命题使用逻辑运算符组合成的新命题。

命题的否定：令$p$为一命题，则$p$的否定记作`~p`，它们的真值相反。

命题的合取：设`p q`为命题。`p q`的合取就是命题`p`并且`q`，用$p \land q$表示。

命题的析取：设`p q`为命题。`p q`的析取就是命题`p`或者`q`，用$p \lor q$表示。

命题的异或：设`p q`为命题。`p q`的异或就是命题`p`和`q`种恰好有一个成立时为真，用$p \oplus q$表示。

条件语句：若`p`，则`q`，当`p`为真而`q`为假时，`p->q`为假，否则为真。其中`p`为前提，`q`为结论。

条件语句又称为蕴含。



设已经有命题：`p->q`。

逆命题：`q->p`。

逆否命题：$\urcorner q \to \urcorner q$。

反命题：$\urcorner p \to \urcorner q$。

以上只有**逆否命题**一直有与`p->q`相同的真值，这被称作等价。**一个条件语句和它的逆否命题总是等价的。**

条件语句的逆与反也是等价的。



双向蕴含：$p \leftrightarrow q$，意思是“p当且仅当q”。当`p`与`	q`为真时，真值为真，否则为假。双向蕴含又被称为双条件。



运算符的优先级：

| 运算符                  | 优先级 |
| ----------------------- | ------ |
| $\urcorner$             | 1      |
| $\land$ $\lor$          | 2      |
| $\to$ $\leftrightarrow$ | 3      |



比特：一个具有两个可能值得符号，即0和1。

布尔变量：一个变量的值或真或假。

比特运算：又称为位运算，一般有$AND$、$OR$、$XOR$。

比特串是0比特或者多比特的序列，其长度就是比特的数目。



### 1.2	命题逻辑的应用

主要是一些有趣的问题。

系统规范说明：必须是一致的，不能包含可能导致矛盾的相互冲突的需求。

还有逻辑谜题，布尔搜索、逻辑电路等。



### 1.3	命题等价式

永真式：真值永远为真的复合命题，又称为重言式。

矛盾式：真值永远为假的复合命题。

可能式：既不是永真式又不是矛盾式的复合命题。



逻辑等价：在所有可能的情况下，都具有相同真值的两个复合命题。

如果$p \leftrightarrow q$是永真式，那么`p`和`q`称为是逻辑等价的，用$p\equiv q$表示。



逻辑等价式：

| 等价式                                                     | 名称       |
| ---------------------------------------------------------- | ---------- |
| $p \and T\equiv p $                                        | 恒等律     |
| $p \lor F \equiv p$                                        | 恒等律     |
| $p \lor T \equiv T$                                        | 支配律     |
| $p \and F \equiv F$                                        | 支配律     |
| $p \lor p \equiv p$                                        | 幂等律     |
| $p \and p \equiv p$                                        | 幂等律     |
| $\urcorner (\urcorner p)\equiv p $                         | 双重否定律 |
| $p \and q \equiv q \and p$                                 | 交换律     |
| $p \lor q \equiv q \lor p$                                 | 交换律     |
| $p \lor (q \lor r) \equiv (p \lor q)\lor r$                | 结合律     |
| $p \and (q \and r)\equiv (p \and q) \and r$                | 结合律     |
| $p \lor (q\and r) \equiv (p \lor r) \and (p\lor q)$        | 分配律     |
| $p\and(q\ \lor r) \equiv (p \and q)\lor (p \and r)$        | 分配律     |
| $\urcorner (p \and q) \equiv \urcorner p \lor \urcorner q$ | 德摩根定律 |
| $\urcorner (p \lor q)\equiv \urcorner p \and \urcorner q$  | 德摩根定律 |
| $p \lor (p \and q)\equiv p$                                | 吸收律     |
| $p \and (p \lor q)\equiv p$                                | 吸收律     |
| $p \and \urcorner p \equiv F$                              | 否定律     |
| $p \lor \urcorner p \equiv T$                              | 否定律     |

德摩根定律可以进行扩展：

$\urcorner (p_1 \lor p_2 \lor ···\lor p_n) \equiv (\urcorner p_1\and \urcorner p_2 \and ··· \and \urcorner p_n)$。

$\urcorner (p_1 \and p_2 \and ···\and p_3)\equiv (\urcorner p_1 \lor \urcorner p_2\lor ···\lor \urcorner p_n)$。

可以用符号$\bigvee_{j=1}^{n} p_j$或者$\bigwedge_{j=1}^{n}p_j$来进行缩写。

写作$\urcorner (\bigvee_{j=1}^{n}p_j)\equiv \bigwedge_{j=1}^{n} \urcorner p_j$和$\urcorner (\bigwedge_{j=1}^{n}p_j)\equiv \bigvee_{j=1}^{n}\urcorner p_j$。



| 条件命题的逻辑等价式                          |
| --------------------------------------------- |
| $p\to q \equiv \urcorner p \lor q$            |
| $p\to q\equiv \urcorner q \to \urcorner p$    |
| $p\lor q\equiv \urcorner p\to q$              |
| $p \and q\equiv \urcorner (p\to \urcorner q)$ |
| $\urcorner (p\to q)\equiv p \and \urcorner q$ |
| $(p\to q)\and(p\to r)\equiv p\to (q \and r)$  |
| $(p\to r)\and(q\to r)\equiv (p \lor q)\to r$  |
| $(p\to q)\lor (p\to r)\equiv p\to(q \lor r)$  |
| $(p\to r)\lor(q\to r)\equiv (p\and q)\to r$   |





| 双条件命题的逻辑等价式                                       |
| ------------------------------------------------------------ |
| $p\leftrightarrow q\equiv (p\to q)\and (q\to p)$             |
| $p\leftrightarrow q\equiv \urcorner p\leftrightarrow \urcorner q$ |
| $p\leftrightarrow q\equiv (p\and q)\lor (\urcorner p \and \urcorner q)$ |
| $\urcorner (p\leftrightarrow q)\equiv p\leftrightarrow\urcorner q$ |



可满足性：存在一个对其变量的真值赋值，使其为真。并且这个真值赋值被称作解。

不可满足性：不存在一个对其变量的真值赋值，使其为真。



比较困难的是`n`皇后问题和数独问题。

证明命题等价的方法：

- 通过真值表：构造两个命题的真值表，并比较结果。如果它们对每种可能的输入的真值都匹配，那么这两个命题是等价的。
- 通过等价律：应用等价律将一个命题转化为另一个命题。



### 1.4	谓词和量词

**谓词是一个包含一个或多个变量的陈述，当变量被特定值替代时，它变成一个命题。**

`n`元谓词：包含`n`个变量的语句，可以表示成$P(x_1,x_2,x_3······x_n)$，这样的语句被称作命题函数$P$在`n`远足$(x_1,x_2,x_3······)$的值。$P$又称为`n`位谓词。（实际上$P$就是用于描述变量行为、性质的语句）

**当谓词的所有变量都被特定值替代时，谓词变为命题。**

**当谓词的所有变量都被特定值替代时，谓词变为命题。**

**实例化：将谓词中的变量替换为特定值，使其成为命题。**

- $∀xP(x)$：“对于所有 $x$，$P(x)$ 都为真。”
- 如果我们实例化 $x$ 为 2，我们得到 $P(2)$：“2 是偶数。”





**前置条件：**用于描述合法输入的语句

**后置条件**：用于描述程序运行的输出应该满足的条件。



量化：在一定范围内的变量，谓词总是成立，而不是一定需要变量被赋给确定的值。这种从一个命题函数生成一个命题的方法称为量化。

主要有两种：**全称量化，存在量化**。分别对应全称量词和存在量词。

一般用$\forall xP(x)$表示$P(x)$的全程量化：对于所有的$x，P(x)$为真。

一般用$\exists xP(x)$表示$P(x)$的存在量化：存在一个$x$，使得$P(x)$为真。

使用量词必须指定论域。

**全称量词$\forall$：用于表示一个谓词对某个领域中的所有元素都成立。读作 “对于所有”。**

**存在量词$\exist$：用于表示在某个领域中存在至少一个元素使得谓词成立。读作 “存在”。**

**全称量词与存在量词的对偶性 (Duality of Quantifiers)**：

**对偶性：** 全称量词与存在量词是对偶的。这意味着：全称命题的否定变成存在命题，反之亦然。

e.g：$\urcorner \forall xP(x) \equiv \exist x \urcorner P(x)$。





还有一些新的量词。

唯一性量词：用$\exist !$或者$\exist_1$表示，$\exist! xP(x)$表示的是：存在一个唯一的$x$使得$P(x)$为真，一般避免使用唯一性量词。

有限域上的量词：当量词的域是有限的，或者元素可以逐个列举出来时，量化语句可以用命题逻辑表达。

$\forall xP(x) \equiv P(x_1) \and P(x_2) \and P(x_3) \and ······\and P(x_n)$。

$\exist xP(x) \equiv P(x_1) \lor P(x_2) \lor P(x_3) \lor···\lor P(x_n)$。

我们可以使用循环来判断量化：如果是全称量化，我们可以循环判断每一个元素$x$，查看$P(x)$是否都为真，判断$\forall xP(x)$是否为真。

如果是存在量化，我们可以循环查找一个$x$，使得$P(x)$为真，那么$\exist xP(x)$为真。



受限域的量词：就是$\forall xP(x)$中前面的$x$加了一定的限制条件，比方说大于0，小于0等。

$\forall \exist$量词具有更高的优先级。

量词绑定：当量词作用于$x$时，$x$被限制一个特殊的范围内，或者被设置为特定的值。$x$这里被称作时约束的。

作用域：量词作用的部分。如果一个变量是自由的，那么它在量词的作用域之外。



量词的逻辑等价式：用$S\equiv T$表示涉及谓词和量词的两个语句$S$和$T$是逻辑等价的。

全称量词对合取是可分配的，但是对析取是不可分配的，存在量词则相反。

可能单纯看有些迷糊：$\forall x(P(x)\and Q(x)) \equiv \forall xP(x) \and \forall xQ(x)$。

量化表达式的否定：$\urcorner \forall xP(x) \equiv \exist x \urcorner P(x)$。		$\urcorner \exist xQ(x)\equiv \forall x \urcorner Q(x)$。



课本上有一部分内容是“从语句到逻辑表达式的翻译”：建议看书比较好。



全称量词实例化：如果 $\forall x P(x)$，则对于任何特定值 $a$，$P(a)$ 都为真。

存在量词实例化：如果$\exist xP(x)$，则我们可以引入一个特定实例 $c$，使得 $P(c)$ 为真。

全称量词泛化：如果 $P(a)$ 对任意的 $a$ 都成立，则可以推广为 $\forall xP(x)$。

### 1.5	嵌套量词

量词可以进行嵌套。

**将量化当作循环**：在处理多个变量的表达式时，推荐使用嵌套循环方法，循环每一个量词的变量来判断命题的真假。

**量词的顺序**：量词的顺序会影响命题的真假，对于同一个命题，量词的顺序发生改变，命题的真假也可能会发生改变。

以下面例子解释：

$\exist y \forall xP(x,y)$为真，则$\forall x\exist yP(x,y)$必定也是真。

但是如果$\forall x \exist y P(x,y)$为真，$\exist y \forall xP(x,y)$可能为假。



还有一些嵌套量词的翻译，推荐看书上的例子。



**嵌套量词的否定**：从左边到右边依次否定即可。

e.g:	$\forall x \exist y (xy=1)$的否定为$\urcorner \forall x \exist y(xy\le1)=\exist x \forall y(xy > 1)$。

全称量词的否定为存在量词，存在量词的否定为全称量词。



**逻辑表达式：**逻辑表达式可以包含谓词、运算符（如 ¬,∧,∨,→）和量词（全称量词或存在量词）。这些表达式使我们能够表示变量之间的复杂逻辑关系。

### 1.6	推理规则

#### 命题逻辑的推理规则

一些英语名词：

| 英文       | 中文           |
| ---------- | -------------- |
| Postulates | 基本条件，前提 |
| conjecture | 猜想           |
| theorem    | 定理           |
| corollary  | 推论           |
| axioms     | 公理           |
| lemma      | 引理           |
| paradox    | 悖论           |
| argument   | 论证           |
| premise    | 前提           |
| fallacy    | 谬论           |
| clause     | 子句           |



推理规则：相对简单的论证形式，可以用来构造更加复杂的情况。

| 推理规则                                  | 永真式                                         | 名称                 |
| ----------------------------------------- | ---------------------------------------------- | -------------------- |
| $p$且$p->q$，则$q$                        | $(p\and (p\and q))->q$                         | 假言推理（肯定前件） |
| $\urcorner q$且$p->q$，则$\urcorner p$    | $(\urcorner q \and (p->q))-> \urcorner p$      | 取拒式（否定后件）   |
| $p->q$且$q->r$，则$p->r$                  | $((p->q) \and (q->r))->(p->r)$                 | 假言三段论           |
| $p \or q$且$\urcorner p$，则$q$           | $((p \or q) \and \urcorner p)->q$              | 析取三段论（消解法） |
| $p$，则$p\or q$                           | $p->(p\or q)$                                  | 附加律（加法）       |
| $p \and q$，则$p$                         | $p\and q->p$                                   | 化简律（简化法）     |
| $p，q$，则$p\and q$                       | $((p)\and (q))-> (p\and q)$                    | 合取律（）           |
| $p\or q， \urcorner p \or r$，则$q \or r$ | $((p \or q)\and (\urcorner p \or r))->q \or r$ | 消解律               |



**消解律**：以上推理规则中比较重要的一个。可以使用其来构建自动定理证明系统，这里假设和结论必须作为子句（子句指的是变量或者否定的析取式，如：$p \or (q \and r)\equiv (p\or q)\and (p \or r)$，其中$(p \or r)(p \or q)$就是子句）。

下面给一个证明的例子：$(((p\and q) \or r )\and(r->s))->p\or s$。

证明：$((p \and q)\or r)->(p\or r)\and (q\or r)$，$(r->s)->(\urcorner r \or s)$，则$(p\or r)\and (\urcorner r \or s)->(p \or s)$。



#### 量化命题的推理规则

全称实例：从前提$\forall xP(x)$得到$P(c)$为真。

全称引入：对论域内的所有元素$c$都有$P(c)$为真的前提，推导出$\forall xP(x)$。

存在实例：知道$\exist xP(x)$，推导出存在一个元素$c$，使得$P(c)$为真。

存在引入：从一个特定元素$c$，$P(c)$为真时，得到$\exist xP(x)$为真。

对应的，书上有一些例题证明，这部分推荐看书。



### 1.7	证明导论

**有效论证是指仅当结论从前提中逻辑地推导出来时才成立。在有效论证中，前提为真而结论为假的情况是不可能发生的。**



#### 证明定理的方法

书上有很多例题：推荐看。

**直接证明法**：证明$p->q$为真：第一步假设$p$为真，第二步利用推理规则，第三步得到$q$也必须为真。

**反证法（间接法）**：利用$(p->q)\equiv (\urcorner q -> \urcorner p)$，可以通过证明后者为真来证明命题成立。

​		这里假定$q$为假，那么$\urcorner q$为真，然后得到前提$\urcorner p$为真（也就是把原来的条件否定了），即$p$为假，矛盾，说明$q$必定为真。

**空证明**：当$p$为假时，很容易得到$p->q$为真，利用这个特点来进行证明（证明$p$为假，自然$p->q$为真）。

**平凡证明**：当$q$为真时，很容易得到$p->q$为真，利用这个特点来进行证明（证明$q$为真，自然$p->q$为真）。

**归谬证明法**：证明$p$为真，利用$\urcorner p->q$为真，找到一个$q$为假，即可$\urcorner p$为假。$q$可以选取$r \and \urcorner  r$。

​			主要时从$\urcorner p$得到两个相反的结论都成立，主要就可以说明$p$为真，一般可能其中一个结论是已经给出的。

**等价证明法**：多个命题等价，可以写成循环的方式：$p_1<->p_2<->p_3<->······<->p_{n}$，

​			可以通过证明$p_1->p_2,p_2->p_3,p_3->······p_n->p_1$来证明这$n$个命题相互等价。



## 第二章

### 2.1	集合

有很多都是熟悉的知识，这里只讲一些没见过的或者比较重要的，又或者与原来的知识有些不同的知识点。

集合介绍

花名册方法：就是枚举集合中的元素。又称列举法

集合构造器：用一些特征或者公式来描述集合中的元素。又称为生成函数法

文氏图：就是韦恩图。

子集：不解释。这里介绍如何证明一个集合是另外一个集合的子集。

**证明A是B的子集**：为了证明$A\subseteq B$，需要证明如果$x$属于$A$则$x$也属于$B$。

**证明A不是B的子集**：为了证明$A\nsubseteq B$，需要找一个$x$属于$A$且$x$不属于$B$。

每一个集合至少有两个子集：空集和它本身。

基数：即集合的大小，集合`A`中的元素数目，记作$|A|$。

幂集：集合`S`的幂集是集合`S`所有子集的集合，记作$\mathcal{P}(S)$。

如果一个集合有`n`个元素，那么它的幂集就会有$2^{n}$个元素。（取与不取）

**两个集合 A 和 B 相等，当且仅当它们包含相同的元素，记作 A=B。**



有序`n`元组：以$a_1$为第一个元素，$a_2$为第二个元素，······，$a_n$为第`n`个元素的有序聚集。

当`n`为2时，又称为序偶。

两个有序`n`元组相等，需要$a_i=b_i$，其中$i=1、2、···n$。



笛卡尔积：用$A\times B$表示，（其中`A`和`B`都是集合），是所有序偶$(a,b)$的集合，其中$a\in A$，$b\in B$,

故$A \times B = \{ (a,b)|a\in A \and b \in B \}$。

可以推广到`n`维。

笛卡尔积$A \times B$的一个子集$R$被称作从集合$A$到集合$B$的关系。

从集合$A$到自身的一个关系称为是$A$上的一个关系。



真值集：给定谓词$P$和论域$D$，定义$P$的真值集为$D$中使得$P(x)$为真的元素$x$的集合。$P(x)$的真值集记作

$\{ x \in D|P(x)\}$。



### 2.2	集合运算

主要有并集、交集、差集、补集等。

注意：$A$和$B$的差集，用$A-B$表示，是一个集合，表示属于$A$但是不属于$B$的元素。又称为$B$相对于$A$的补集。可以表示为$A\cap \bar{B}$



集合的计算机表示：

计算机使用比特串来表示集合：假设集合$U$有`n`个元素，那么可以用长度为`n`的比特串来表示集合$U$的子集$A$

第$i$位表示$a_i$，如果有，则为1，则第`i`位为1，否则为0。

并集使用按位或运算，交集使用按位与运算。



多重集合：同一个元素在集合中出现的次数超过一次。使用$\{  m_1·a_1、m_2·a_2、m_3·a_3······\}$表示。其中$m_i$是元素$a_i$重复的次数。

多重集合的基数是其元素重复数的总和。



多重集合有并、交、和、差运算。

并：取元素重复数中的最大值。

交：取元素重复数中的最小值。

和：取两个集合元素重复数的和。

差：取前者元素的重复数对后者元素的重复数的差，如果是负数，则记作0，不用写出来。



另外还有一些集合恒等式：比较困难的是证明。后续再深究。

证明集合相等的方法：

- **通过恒等律：** 使用恒等律证明两个集合相等。
- **通过成员表：** 列出两个集合的元素并检查它们是否匹配。

常见方法：通过证明$A$中的每一个元素都在$B$中，反之亦然，证明$A=B$。



### 2.3	函数

函数：又称为**变换**或**映射**。包含了定义域、陪域、定义域中元素到陪域的映射。

函数：**从集合 A 到集合 B 的函数记作$ f:A→B$，意味着对于每个元素 $x∈A$，存在唯一的元素 $y∈B$，使得 $f(x)=y$。**一个输入对应多个输出的关系不是函数。

陪域：函数中所有可能输出值的集合，但不一定是实际输出。

值域：陪域的子集，其中的每一个值都能找到对应的元素（就是自变量）。也就是函数实际的输出值集合。

相等：具有相同的定义域、陪域、映射关系。如果改变定义域或者陪域，那么函数将发生改变。



实值函数：陪域是实数集合。

整数值函数：陪域是整数集合。

具有相同的定义域的两个实值函数或者整数值函数可以相加或者相乘。

$(f_1+f_2)(x)=f_1(x)+f_2(x)$。

$(f_1f_2)(x)=f_1(x)f_2(x)$。



令$f$为从$A$到$B$的函数，$S$为$A$的一个子集，那么$S$在$f$下的像就是由$S$中的元素的像组成的$B$的子集（很绕口）。

写作：$f(S)= \{ t| \exists s\in S(t=f(s)) \}$



一对一函数：又称为单射，$f(a)=f(b)$时，必定有$a=b$，反之也成立。

映上：又称满射，**当且仅当值域中的每个元素至少有一个域中的元素映射到它。**

双射：满足上面两个条件，又称为$f$是一一对应的。



反函数：用$f^{-1}$表示，含义你懂的。存在反函数的条件是$f$是一一对应的。

可以通过限制定义域，使得一个不存在反函数的函数$f$存在$f^{-1}$函数。



合成函数：就是复合函数，记作$(f \circ g)(a)=f(g(a))$。

左边表示的是$f$和$g$的合成。



函数的图：就是函数的图像，使用序偶表示。



还有一些比较重要的函数：上取整函数，下取整函数，阶乘函数。

有很多的性质，后续再补充。以及一些证明。



### 2.4	序列

序列：其实就是数列。

一些常见的有：几何级数（等比数列）、算术级数（等差数列）。



递推：使用前面某些项来表示当前项，它们之间一般存在一些关系。

如果一个序列满足该递推关系，那么该序列就称作该递推关系的一个解。



闭公式：其实就是通项公式，一般可以使用迭代法解决。



比较特殊的序列有：斐波那契数列、卢卡斯数列。

它们都满足$F_n=F_{n-1}+F_{n-2}$。

不同的地方是：斐波那契数列中：$f_0=0,f_1=1$

卢卡斯数列中：$L_1=1,L_2=3$.



求和：将序列中的连续一段进行求和：使用$\sum_{j=m}^{n}a_j$表示，下标表示的起点，上标表示的是终点。

求和时比较有用的方法是：平移下标。

举例：$\sum_{j=1}^{5}j^2=\sum_{k=0}^{4}(k+1)^2$。



常用的求和公式：

| 和                               | 闭形式                          | 和                                  | 闭形式                 |
| -------------------------------- | ------------------------------- | ----------------------------------- | ---------------------- |
| $\sum_{k=0}^{n} ar^{k}(r \ne 0)$ | $\frac{ar^{n+1}-a}{r-1},r\ne 1$ | $\sum_{k=1}^{n} k^3$                | $\frac{n^2(n+1)^2}{4}$ |
| $\sum_{k=1}^{n}k$                | $\frac{n(n+1)}{2}$              | $\sum_{k=0}^{\infty}x^k,|x|<1$      | $\frac{1}{1-x}$        |
| $\sum_{k=1}^{n} k^2$             | $\frac{n(n+1)(2n+1)}{6}$        | $\sum_{k=1}^{\infty}kx^{k-1},|x|<1$ | $\frac{1}{(1-x)^2}$    |



### 2.6	矩阵

矩阵定义

矩阵算术：加法、乘法

矩阵的转置、矩阵的幂

0-1矩阵：只由0和1构成的矩阵，对应有矩阵的交和并（对应每一个元素做交或并运算）。

布尔积：用$A\odot B$表示，其实就是矩阵的乘法。

$A$的$r$次布尔幂是$r$个$A$的布尔积，记作$A^{[r]}$，等价于$A\odot A \odot A···\odot A$。

定义$A^{[0]}$为$I_n$，其中$I^{[n]}$是单位阵。



## 第三章

### 3.1	计数的基础

基本的计数原则：乘法原则和加法原则。这两个是高中就学过的知识，这里不解释了。

减法原则：其实就是容斥原理，这里也不解释了。



比较新奇的是除法原则，课本上讲的概念术语有点抽象，可以类比组合问题（选取出的排列的所有可能情况除以内部的排列情况）。

还可以利用树图解决问题：通过一定的先后顺序枚举每一层，列出所有的可能情况。



### 3.2	鸽巢原理

鸽巢原理：如果`k+1`个或者更多的物体放入`k`个盒子，那么至少有一个盒子包含了2个或者更多的物体。该定理又称为迪利克雷抽屉原理。

由此存在一些相关的推论：一个从有`k+1`甚至更多个元素的集合到`k`个元素的集合的函数$f$不是一对一函数。



广义鸽巢原理：如果$N$个物品放入$k$个盒子，那么至少有一个盒子包含了$\lceil N/k\rceil$个物体。



鸽巢原理比较困难的是一些应用证明（当然也很有趣）。

定理：每个由$n^2+1$个不同实数构成的序列都包含一个长为$n+1$的严格递增子序列或者严格递减子序列。

拉姆齐数：使用$R(m,n)$表示，假设晚会上每两个人是朋友或者是敌人，那么在一个晚会上使得或者有$m$个人两两都是朋友，或者有$n$个人两两都是敌人所需要的最少人数。拉姆齐数具有对称性。

常见的性质有$R(2,n)(n\ge 2)=n$，$R(4,4)=18$。



### 3.3	排列组合

排列组合的概念不用再解释了。主要的知识点就是排列组合的计算公式，以及一些性质。难点还是证明。



### 3.4	二项式系数和恒等式

二项式定理：都学过。$(x+y)^n=C_{n}^{0}x^n y+C_{n}^{1}x^{n-1}y^1+······+C_{n}^{n-1}x y^{n-1}+C_{n}^{n}y^n$。

可以通过对$x,y$赋值，获得不同的展开式。常见的有$x=1,y=-1$。



帕斯卡恒等式：其实就是杨辉三角。$C_{n+1}^{k}=C_{n}^{k-1}+C_{n}^{k}$，相当于从$n+1$个数中抽取$k$个数，有两种方法：先取出一个数，再从剩下的$n$个数中抽取$k-1$个即可。或者不取，直接从剩下的数中取出$k$个数。



范德蒙德恒等式：设$m、n、r$是非负整数，其中$r$不超过$m$或$n$，那么$C_{m+n}^{r}=\sum\limits_{k=0}^{r}C_{m}^{r-k}C_{n}^{k}$，这个不等式的含义其实也好理解。证明的话请看书吧，这里直接省略了。



推论：令$m=n,r=n$，可以得到：$C_{2n}^{n}=\sum\limits_{k=0}^{n} (C_{n}^{k})^2$。



定理：$C_{n+1}^{r+1}=\sum\limits_{k=r+1}^{n+1}C_{k-1}^{r}(r+1\le k\le n+1)$。令$j=k-1$，可以得到$C_{n+1}^{r+1}=\sum\limits_{j=r}^{n} C_{j}^{r}$。

证明：一个$n+1$位的比特床含有$r+1$个1。那么最后一个1一定出现在$r+1$到$n+1$的范围内，那么设最后一个1出现在第$k$位，一定有$r$个1出现在前$k-1$位，对应的所有可能的情况是：$C_{k-1}^{r}$，由于$r+1\le k \le n+1$，再进行求和即可得到上面的式子，令$j=k-1$即可得到最后的结果。



### 3.5	排列组合的推广

具有`n`个物体的集合允许重复的`r`排列数是$n^r$。

`n`个元素的集合允许重复的`r`组合有$C_{n+r-1}^{r}=C_{n+r-1}^{n-1}$。（联系高中的取物隔板法）



## 第四章

### 4.5	容斥原理

两个集合的容斥不再赘述，可以了解下推广的。（证明看书）

容斥原理（Inclusion-Exclusion Principle）是一个计算集合并集的基数的数学工具。它的基本思想是通过先加上各个集合的基数，然后减去两两交集的基数，再加上三三交集的基数，依此类推，来准确计算出所有集合并集的基数。

设有 $n$ 个集合 $( A_1, A_2, \dots, A_n )$，则它们的并集 $( \bigcup_{i=1}^n A_i )$ 的基数（即集合中元素的个数）为：

$$
\left| \bigcup_{i=1}^n A_i \right| = \sum_{i=1}^n |A_i| - \sum_{1 \leq i < j \leq n} |A_i \cap A_j| + \sum_{1 \leq i < j < k \leq n} |A_i \cap A_j \cap A_k| - \cdots + (-1)^{n+1} |A_1 \cap A_2 \cap \cdots \cap A_n|
$$
其中：

- $( \left| \bigcup_{i=1}^n A_i \right| )$ 表示所有集合 $( A_1, A_2, \dots, A_n )$ 的并集的基数；
- $( |A_i| )$)表示集合 $( A_i )$ 的基数；
- $( |A_i \cap A_j| )$ 表示集合 $( A_i )$ 和 $( A_j )$ 的交集的基数；
- ($ |A_i \cap A_j \cap A_k| $) 表示集合 $( A_i, A_j, A_k )$ 三者的交集的基数；
- 以此类推，最后一项 $( |A_1 \cap A_2 \cap \cdots \cap A_n| )$ 表示所有集合的交集的基数。

这个公式的推导基于加减交集的方式，逐步修正由于重叠部分带来的过度计数问题。



## 第五章

### 5.4	关系的闭包

1. **定义**

   - 在离散数学中，闭包（Closure）是对集合以及集合上的运算的一种概念。给定一个集合 $A$ 和一个在 $A$ 上定义的运算（比如关系运算），闭包是包含 $A$ 的最小集合，这个最小集合在该运算下是封闭的。 

   - 例如，对于关系 $R$ 是集合 $A$ 上的二元关系，$R$ 的自反闭包（用 $r(R)$ 表示）是包含 $R$ 的最小自反关系。如果 $A = \{1, 2, 3\}$，$R=\{(1,2)\}$，那么 $R$ 的自反闭包 $r(R)=\{(1,2),(1,1),(2,2),(3,3)\}$。因为自反关系要求对于集合 $A$ 中的每个元素 $x$，$(x,x)$ 都在关系中，所以在原关系 $R$ 的基础上添加了 $(1,1)$、$(2,2)$ 和 $(3,3)$ 使其成为自反闭包。 

2. **关系闭包的类型**   

   - **自反闭包（Reflexive Closure）**

     - 定义：设 $R$ 是集合 $A$ 上的关系，$R$ 的自反闭包 $r(R)$ 是满足以下条件的关系：$r(R)=R\cup I_A$，其中 $I_A=\{(a,a)|a\in A\}$，也就是 $A$ 上的恒等关系。

     - 例如，若 $A = \{a, b, c\}$，$R=\{(a,b),(b,c)\}$，则 $I_A=\{(a,a),(b,b),(c,c)\}$，$r(R)=\{(a,b),(b,c),(a,a),(b,b),(c,c)\}$。

   - **对称闭包（Symmetric Closure）**     
     - 定义：设 $R$ 是集合 $A$ 上的关系，$R$ 的对称闭包 $s(R)$ 是满足以下条件的关系：$s(R)=R\cup R^{-1}$，其中 $R^{-1}=\{(y,x)|(x,y)\in R\}$，也就是 $R$ 的逆关系。     
     - 例如，若 $R = \{(a,b),(b,c)\}$，则 $R^{-1}=\{(b,a),(c,b)\}$，$s(R)=\{(a,b),(b,c),(b,a),(c,b)\}$。   -
     
   - **传递闭包（Transitive Closure）** 
   
     - 定义：设 $R$ 是集合 $A$ 上的关系，$R$ 的传递闭包 $t(R)$ 是包含 $R$ 的最小传递关系。传递关系是指如果 $(a,b)\in R$ 且 $(b,c)\in R$，那么 $(a,c)\in R$。对于有限集合 $A$，可以通过算法（如Warshall算法）来计算传递闭包。
   
     - 例如，若 $A=\{1,2,3\}$，$R = \{(1,2),(2,3)\}$，则 $t(R)=\{(1,2),(2,3),(1,3)\}$，因为根据传递性，由 $(1,2)$ 和 $(2,3)$ 可以推出 $(1,3)$。 
   
3. **闭包的性质和用途**

   - **性质**   

     - 对于关系闭包，如果 $R_1$ 和 $R_2$ 是集合 $A$ 上的关系，那么有 $r(R_1\cup R_2)=r(R_1)\cup r(R_2)$，$s(R_1\cup R_2)=s(R_1)\cup s(R_2)$，$t(R_1\cup R_2)\supseteq t(R_1)\cup t(R_2)$（这里是包含关系，因为传递闭包的并可能不是最小传递关系）。 

   - **用途**  

       在计算机科学中，闭包概念用于很多领域。例如，在编译原理中，语法分析器可以利用闭包来处理语法规则的递归定义。在图论中，传递闭包可以用于判断图中节点之间是否存在路径（如果有向图的关系 $R$ 表示边的连接关系，那么其传递闭包可以判断从一个节点是否能通过一系列边到达另一个节点）。在数据库系统中，闭包可以用于处理数据之间的关联关系，如判断数据之间的可达性或者完整性约束等。

可以简单的理解：我们在集合$A$的基础上，为了满足某种特性，从而往$R$添加一些新关系得到的集合。

## 第六章

### 6.1	图和图模型

> 在图论中，图是一组顶点（或称为节点）和连接这些顶点的边的集合。以下是常见图的定义：
>
> 1. **有限图（Finite Graph）**:
>    - 顶点和边的数量都是有限的。
>    - 常见的研究对象，因为其顶点和边的数量都是可数的。
>
> 2. **无限图（Infinite Graph）**:
>    - 顶点或边的数量是无限的。
>    - 例如，一条无限延伸的路径或由无限个节点组成的图。
>
> 3. **简单图（Simple Graph）**:
>    - 不包含自环（即没有从一个顶点指向它自身的边）。
>    - 任意两顶点之间至多只有一条边。
>
> 4. **多重边（Multiple Edges 或 Parallel Edges）**:
>    - 两个顶点之间有多于一条边连接。
>    - 例如，在顶点 A 和 B 之间存在两条或更多条边。
>
> 5. **多重图（Multigraph）**:
>    - 允许存在多重边。
>    - 即两个顶点之间可以有多条边，且不包含自环。
>
> 6. **环（Cycle）**:
>    - 一条路径的起点和终点是同一个顶点，且路径上其他顶点不重复。
>    - 环通常被用来表示图中的闭合回路。
>
> 7. **伪图（Pseudograph）**:
>    - 允许存在自环和多重边的图。
>    - 自环是指一条边从一个顶点出发又回到该顶点。
>



以下是比较简单图、多重图、伪图、简单有向图、有向多重图和混合图的表格，从**边的方向性**、**是否允许多重边**、**是否允许环**三个角度进行比较：

| 图类型         | 边的方向性         | 允许多重边 | 允许环 |
| -------------- | ------------------ | ---------- | ------ |
| **简单图**     | 无向               | 否         | 否     |
| **多重图**     | 无向               | 是         | 否     |
| **伪图**       | 无向               | 是         | 是     |
| **简单有向图** | 有向               | 否         | 否     |
| **有向多重图** | 有向               | 是         | 否     |
| **混合图**     | 有向和无向均可存在 | 是         | 是     |

- **边的方向性**：表示图中的边是否有方向。如果边有方向，则从一个顶点指向另一个顶点；如果边无方向，则表示连接的两个顶点之间可以双向通行。
- **允许多重边**：指是否允许两个顶点之间有多条边。
- **允许环**：指是否允许边连接到自身，即从一个顶点出发又回到该顶点。



### 6.2	图的术语和几种特殊的图

还有一堆专业术语，这里使用这篇文章[图论相关概念 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/concept/)来介绍一下。

内容很多跟算法竞赛相关，可以看一些相关的文章：[二分图 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/bi-graph/#二分图最大匹配)。

------

**无向图有偶数个度为奇数的顶点。**

**图**：图 $G$ 由一组顶点 $V$ 和一组边 $E$ 组成，每条边是两个顶点的有序或无序对。

**顶点**：图中的一个点，通常用 $v$ 表示。

**边**：两个顶点之间的连接，对于无向图用 $(u,v)$ 表示，指向图用 $(u→v)$ 表示。

**完全图**：每一对不同的顶点都有一条独特的边相连的图。

**二分图**：图的顶点可以分为两个不相交的集合，并且每一条边都连接一个集合中的顶点和另一个集合中的顶点。

**完全二分图**：每个集合中的每个顶点都与另一个集合中的每个顶点相连接的二分图。

**n - 立方体**：表示 n- 维立方体的顶点和边的图。顶点表示长度为 n 的所有二进制序列，如果两个序列在一个位置上有所不同，则它们之间有一条边。

> **握手定理（Handshake Theorem）**是图论中的一个基本定理，它表明任意无向图中所有顶点度数之和等于边数的两倍。用数学表达式表示为：
>$$
> \sum_{v \in V} \text{deg}(v) = 2E 
>  $$
> 其中：
> - $$\sum_{v \in V} \text{deg}(v)$$ 表示图中所有顶点的度数之和。
> - $E$ 表示图中的边数。
> 
>### 握手定理的解释：
> - 在一个无向图中，每一条边都连接两个顶点，所以每条边都会对两个顶点的度数各贡献1。因此，所有顶点的度数之和必然等于边数的两倍。
> 
>### 握手定理的推论：
> - 由握手定理可以推导出，任意无向图中度数为奇数的顶点个数总是偶数。这是因为奇数度顶点的总和也是一个偶数（2E）。
> 
>### 示例：
> 考虑一个简单的无向图，包含4个顶点和3条边：
> - 顶点A的度数为2（连接B和C）。
> - 顶点B的度数为1（连接A）。
> - 顶点C的度数为1（连接A）。
> - 顶点D的度数为2（连接C和B）。
> 
>度数之和为 $2 + 1 + 1 + 2 = 6$，而边数 $E = 3$，所以 $2E = 6$，握手定理成立。

补充：

**有向图**：有向图中所有顶点的入度之和等于所有顶点的出度之和，两者都等于边的数量，公式为：
$$
\sum_{v\in V}deg^-(v)= \sum_{v \in V}deg^+(v)=|E|
$$


> **二分图（Bipartite Graph）**是图论中的一种特殊图，它的顶点集可以划分为两个不相交的子集，使得图中的每一条边都只连接来自不同子集的顶点。换句话说，二分图的顶点集可以被划分为两个部分 $U$ 和 $V$，使得图中没有任何一条边连接同一个部分中的顶点。
>
> ### 判断一个简单图是否为二分图的方法：
> 要判断一个简单图是否是二分图，可以使用以下几种方法，最常用的是基于图的**染色法**或**BFS/DFS**遍历法：
>
> #### 1. **染色法（Two-Coloring Algorithm）**：
>    - 将图的一个顶点染成一种颜色（比如红色），然后将它的所有相邻顶点染成另一种颜色（比如蓝色）。
>    - 接着，依次对图中的每个顶点重复这个过程。如果能够完成整个图的染色，使得相邻顶点始终有不同颜色，则该图是二分图。
>    - 如果在染色过程中发现一个顶点和它的相邻顶点必须染成同一种颜色，则该图不是二分图。
>
> #### 2. **BFS/DFS 遍历法**：
>    - 使用 BFS 或 DFS 从任意一个顶点开始遍历图，给该顶点标记一个子集（比如 U），然后将它的所有相邻顶点标记为另一个子集（比如 V）。
>    - 在遍历过程中，如果发现相邻的两个顶点已经被标记为相同的子集，则该图不是二分图。
>    - 如果遍历结束后没有发现这种情况，则该图是二分图。
>
> ### 例子：
> 假设有一个简单图，顶点集为 $\{A, B, C, D\}$，边集为 $\{(A, B), (B, C), (C, D), (D, A)\}$。
> - 如果从顶点 $A$ 开始染色，将 $A$ 染成红色，则 $B$ 被染成蓝色，接着 $C$ 被染成红色，$D$ 被染成蓝色。因为在这个过程中没有发现相邻顶点被染成相同颜色，说明这个图是二分图。
>
> ### **总结**：
> - **二分图的定义**：顶点可以分成两个部分，图中的边只连接来自不同部分的顶点。
> - **判断方法**：使用染色法或 BFS/DFS 遍历法检查是否能够满足二分图的条件。



> **完全二分图（Complete Bipartite Graph）**是二分图的一种特殊形式。在完全二分图中，顶点集可以划分为两个不相交的子集 $U$ 和 $V$，且满足以下条件：
>
> - **每一个子集 $U$ 中的顶点与子集 $V$ 中的所有顶点都有且仅有一条边相连**。
>
> 换句话说，完全二分图中的每条边都连接来自两个不同子集的顶点，且两个子集中任意两个顶点之间必然有一条边相连。
>
> ### 表示方法：
> 完全二分图通常表示为 $K_{m,n}$，其中 $m$ 和 $n$ 分别表示两个子集 $U$ 和 $V$ 中顶点的数量。
> - $K_{m,n}$ 表示子集 $U$ 中有 $m$ 个顶点，子集 $V$ 中有 $n$ 个顶点，并且每个 $U$ 中的顶点都与 $V$ 中的所有顶点相连。
>
> ### 性质：
> 1. **边数**：完全二分图 $K_{m,n}$ 的边数为 $m \times n$，因为每个 $U$ 中的顶点与 $V$ 中的每个顶点都有一条边相连。
> 2. **无环性**：如果 $m = 1$ 或$n = 1$，则 $K_{m,n}$ 是一棵树（特例是星图）。
> 3. **连通性**：完全二分图 $K_{m,n}$ 只有当 $m \geq 1$ 且 $n \geq 1$ 时是连通图。
>
> ### 例子：
> - **$K_{3,3}$**：这是一个完全二分图，其中 $U$ 和 $V$ 各有3个顶点。这个图中有 $3 \times 3 = 9$ 条边，每个 $U$ 中的顶点都与 $V$ 中的3个顶点相连。
>
> ### 应用：
> 完全二分图常用于表示某些实际问题的模型，例如在配对问题中，两个不相交的集体之间的可能配对关系可以用完全二分图来表示。



#### 图的匹配

可以看看：[图匹配 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/graph-matching/graph-match/#图的匹配)。

> ### 最大匹配（Maximum Matching）
>
> **最大匹配**是指在一个图中包含最多边的匹配。具体地说，对于一个给定的图 $ G = (V, E) $，最大匹配是一个匹配 $ M \subseteq E $，其中没有两条边共享相同的顶点，并且 $ M $ 的边数最多。
>
> #### 特性
> - **边的最大数**：最大匹配包含的边数是可能的匹配中最多的。图的不同匹配可能有不同的大小，最大匹配是其中边数最多的匹配。
> - **非唯一性**：最大匹配可能不唯一。例如，对于某些图，可能有多个匹配都包含相同的最大边数。
>
> ### 完美匹配（Perfect Matching）
>
> **完美匹配**是指在一个图的匹配中，每个顶点都恰好与另一顶点配对。对于一个二分图 $ G = (U \cup V, E) $，如果存在一个匹配 $ M $ 使得每个顶点都在 $ M $ 中有一条边相连（即每个顶点都参与匹配），则这个匹配称为完美匹配。
>
> #### 特性
> - **完备性**：完美匹配要求图的每个顶点都参与匹配，即没有顶点被遗漏。这意味着图中的顶点数必须为偶数，否则不可能存在完美匹配。
> - **唯一性**：完美匹配也可能不唯一，尤其是在存在多种配对方式时。
>
> ### 霍尔婚姻定理（Hall's Marriage Theorem）
>
> 霍尔婚姻定理（Hall's Marriage Theorem）是二分图匹配中的一个经典定理，它给出了一个二分图存在完美匹配的充要条件。
>
> #### 定理内容
> 考虑一个二分图 $ G = (U \cup V, E) $，其中 $ U $ 和 $ V $ 是两个顶点集。对于 $ U $ 中的任意一个子集 $ S \subseteq U $，令 $ N(S) $ 表示 $ S $ 在 $ V $ 中的邻接顶点集，即与 $ S $ 中顶点相连的 $ V $ 中顶点的集合。霍尔定理表明：
>
> - **充要条件**：二分图 $ G $ 存在一个从 $ U $ 到 $ V $ 的完美匹配，当且仅当对于 $ U $ 中的任意子集 $ S $，满足 $ |N(S)| \geq |S| $ 。（即 $ S $ 的邻接集的大小至少等于 $ S $ 的大小。）
>
> #### 定理的解释
> 霍尔婚姻定理可以形象地解释为婚姻问题。假设 $ U $ 是一组男性，$ V $ 是一组女性，每个男性只愿意与某些特定的女性结婚，二分图的边表示可能的婚姻配对。定理告诉我们，存在一个可以使每个男性都结婚的匹配（即存在一个完美匹配）的前提条件是，对于男性的任意子集 $ S $，他们“喜欢”的女性数量 $ N(S) $ 必须至少与男性数量相同。
>
> #### 应用
> 霍尔婚姻定理在许多实际问题中有广泛应用，比如：
> - **任务分配**：在任务分配问题中，霍尔定理可以用来检查是否可能为每个任务分配一个适当的工人。
> - **婚姻问题**：可以用于解决经典的稳定婚姻问题，确保在特定条件下每个人都能找到合适的配偶。
>
> ### 总结
> - **最大匹配**是指包含最多边的匹配，可能不唯一。
> - **完美匹配**是指每个顶点都参与匹配的匹配，也可能不唯一。
> - **霍尔婚姻定理**给出了二分图存在完美匹配的充要条件，通过考察子集的邻接集大小来判断匹配的可能性。
>



> 在图论中，操作图的结构以研究其性质或简化问题是常见的技术。以下是关于子图、删除或增添边、删除顶点、边的收缩、缩点、图的合并等概念的详细介绍：
>
> ### 1. 子图（Subgraph）
> **子图**是由原图中的一部分顶点和边构成的图。给定一个图 $ G = (V, E) $，它的子图 $ H $ 是一个图 $ H = (V', E') $，其中 $ V' \subseteq V $ 且 $ E' \subseteq E $。子图中每条边的两个顶点都必须在 $ V' $ 中。
>
> - **诱导子图（Induced Subgraph）**：给定图 $ G $ 的一个顶点集 $ V' \subseteq V $，由 $ V' $ 诱导的子图是包含 $ V' $ 中所有顶点以及这些顶点之间所有边的子图。即 $ E' $ 包含所有连接 $ V' $ 中顶点的边。
>   
> - **生成子图（Spanning Subgraph）**：给定图 $ G $，它的一个生成子图 $ H $ 是指与 $ G $ 具有相同顶点集 $ V $ 且边集 $ E' \subseteq E $ 的子图。
>
> ### 2. 删除或增添边（Edge Deletion/Addition）
>
> - **删除边（Edge Deletion）**：从图 $ G = (V, E) $ 中删除一条边 $ e $ 意味着在保留所有顶点 $ V $ 的同时移除边集 $ E $ 中的边 $ e $。生成的新图 $ G' = (V, E \setminus \{e\}) $ 是原图的一个子图。
>   
> - **增添边（Edge Addition）**：向图 $ G = (V, E) $ 中增添一条新边 $ e $ （连接 $ u $ 和 $ v $），若 $ e $ 不属于 $ E $，那么新图 $ G' = (V, E \cup \{e\}) $ 拥有与 $ G $ 相同的顶点集，并且边集增加了一条边。
>
> ### 3. 删除顶点（Vertex Deletion）
>
> **删除顶点**是指从图 $ G = (V, E) $ 中移除一个顶点 $ v $ 及其所有关联的边。删除顶点 $ v $ 后得到的图是 $ G' = (V \setminus \{v\}, E') $，其中 $ E' $ 包含 $ E $ 中所有不涉及 $ v $ 的边。
>
> - **影响**：删除顶点不仅移除了该顶点，还同时移除了与该顶点相连的所有边，可能导致图的连通性发生变化，或者原来存在的某些路径被断开。
>
> ### 4. 边的收缩（Edge Contraction）
>
> **边的收缩**是指将图中的一条边收缩为一个单一顶点，从而合并这条边的两个端点。给定图 $ G = (V, E) $ 和边 $ e = (u, v) $，收缩边 $ e $ 生成的新图 $ G' $ 是通过合并 $ u $ 和 $ v $ 为新顶点 $ w $，并且将所有与 $ u $ 或 $ v $ 相连的边重新连接到 $ w $。
>
> - **性质**：边的收缩通常用来简化图的结构。对于某些算法（如最小割问题），边收缩是一个重要的步骤。
>
> ### 5. 缩点（Vertex Contraction）
>
> **缩点**是指将图中的多个顶点收缩为一个单一顶点，从而合并这些顶点和它们之间的边。通常，如果 $ G $ 中的顶点集 $ S \subseteq V $ 被缩成一个顶点 $ v' $，那么 $ S $ 中的所有顶点与其他顶点的边将会汇集到 $ v' $ 上。
>
> - **性质**：缩点操作常用于图的简化，特别是在研究强连通分量或割点时。
>
> ### 6. 图的合并（Graph Union/Merging）
>
> **图的合并**是指将两个或多个图结合成一个图。给定两个图 $ G_1 = (V_1, E_1) $ 和 $ G_2 = (V_2, E_2) $，它们的合并图 $ G = (V, E) $ 定义为：
> - **顶点集** $ V = V_1 \cup V_2 $。
> - **边集** $ E = E_1 \cup E_2 $。
>
> - **顶点合并**：如果两个图有公共顶点，则合并时这些顶点被视为同一个顶点。
> - **无公共顶点**：如果两个图的顶点集不相交，那么图的合并实际上是两个不连通子图的并集。
>
> ### 总结
> - **子图** 是原图的一个部分，包含某些顶点和边。
> - **删除或增添边** 通过移除或添加边来修改图的结构。
> - **删除顶点** 会移除该顶点及其所有相连的边。
> - **边的收缩** 将一条边的两个端点合并为一个顶点。
> - **缩点** 是将多个顶点合并为一个顶点。
> - **图的合并** 是将两个或多个图组合成一个图。
>



### 6.3	图的表示和同构

#### 图的表示

可以看这篇文章：[图的存储 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/save/)



> ### 1. 邻接矩阵（Adjacency Matrix）
>
> **邻接矩阵**是一种使用二维数组表示图的方法。给定一个图 $ G = (V, E) $，其中 $ V $ 是顶点集，$ E $ 是边集，邻接矩阵 $ A $ 是一个 $ |V| \times |V| $ 的矩阵：
>
> - **无向图**：如果顶点 $ i $ 和 $ j $ 之间有一条边，则 $ A[i][j] = 1 $；否则 $ A[i][j] = 0 $。
> - **有向图**：如果存在从顶点 $ i $ 到顶点 $ j $ 的有向边，则 $ A[i][j] = 1 $；否则 $ A[i][j] = 0 $。
> - **带权图**：矩阵中的元素 $ A[i][j] $ 可以是边的权值，而不仅仅是 1 或 0。
>
> #### 特性
> - **存储空间**：需要 $ O(V^2) $ 的空间，因此对于顶点较多而边较少的稀疏图来说，空间效率较低。
> - **查询效率**：查询两个顶点之间是否存在边的时间复杂度是 $ O(1) $。
> - **适用场景**：适用于稠密图（边的数量接近 $ V^2 $）或需要频繁检查顶点间连接的场景。
>
> ### 2. 邻接表（Adjacency List）
>
> **邻接表**是一种使用链表或数组表示图的方法。对于图 $ G = (V, E) $，每个顶点 $ v $ 都有一个与之关联的链表，链表中的每个元素代表 $ v $ 的一个邻接顶点：
>
> - **无向图**：如果顶点 $ i $ 和 $ j $ 之间有一条边，则 $ j $ 出现在 $ i $ 的邻接链表中，$ i $ 也出现在 $ j $ 的邻接链表中。
> - **有向图**：如果存在从顶点 $ i $ 到顶点 $ j $ 的有向边，则 $ j $ 仅出现在 $ i $ 的邻接链表中。
> - **带权图**：链表中的每个元素还可以存储与边相关的权值信息。
>
> #### 特性
> - **存储空间**：需要 $ O(V + E) $ 的空间，因此对于稀疏图（边的数量远小于 $ V^2 $）来说更为节省空间。
> - **查询效率**：查询两个顶点之间是否存在边的时间复杂度为 $ O(\text{邻接表长度}) $。
> - **遍历效率**：遍历一个顶点的所有邻接顶点的时间复杂度为 $ O(\text{邻接表长度}) $。
> - **适用场景**：适用于稀疏图以及需要高效遍历的场景。
>



> **关联矩阵（Incidence Matrix）** 是一种表示图的方式，用于描述图中顶点与边之间的关系。它是一种矩阵形式的图表示方法，广泛应用于图论和网络分析中。
>
> ### 定义
>
> 给定一个图 $ G = (V, E) $，其中 $ V $ 是顶点集，$ E $ 是边集，图的关联矩阵 $ B $ 是一个 $ |V| \times |E| $ 的矩阵，用于表示顶点与边的关联关系。
>
> - **无向图**：如果顶点 $ v_i $ 与边 $ e_j $ 关联（即 $ e_j $ 是以 $ v_i $ 为一个端点的边），则矩阵 $ B[i][j] = 1 $；否则 $ B[i][j] = 0 $。
> - **有向图**：对于有向图，关联矩阵可以表示方向性。如果边 $ e_j $ 从顶点 $ v_i $ 指向 $ v_k $，则矩阵 $ B[i][j] = 1 $（表示出度），$ B[k][j] = -1 $（表示入度）；其他顶点与该边无关联，值为 $ 0 $。
>
> ### 例子
>
> 考虑一个简单的无向图 $ G $ ，其中有 3 个顶点和 3 条边：
>
> - 顶点集 $ V = \{v_1, v_2, v_3\} $
> - 边集 $ E = \{e_1, e_2, e_3\} $，其中
>   - $ e_1 $ 连接 $ v_1 $ 和 $ v_2 $
>   - $ e_2 $ 连接 $ v_2 $ 和 $ v_3 $
>   - $ e_3 $ 连接 $ v_1 $ 和 $ v_3 $
>
> 关联矩阵 $ B $ 为：
>
> $
> B = \begin{pmatrix}
> 1 & 0 & 1 \\
> 1 & 1 & 0 \\
> 0 & 1 & 1
> \end{pmatrix}
> $
>
> - 第一行代表顶点 $ v_1 $，它与边 $ e_1 $ 和 $ e_3 $ 关联，所以 $ B[1][1] = 1 $ 和 $ B[1][3] = 1 $。
> - 第二行代表顶点 $ v_2 $，它与边 $ e_1 $ 和 $ e_2 $ 关联，所以 $ B[2][1] = 1 $ 和 $ B[2][2] = 1 $。
> - 第三行代表顶点 $ v_3 $，它与边 $ e_2 $ 和 $ e_3 $ 关联，所以 $ B[3][2] = 1 $ 和 $ B[3][3] = 1 $。
>
> ### 特性
>
> - **存储空间**：对于图 $ G $ 的顶点数为 $ |V| $ 和边数为 $ |E| $ 的情况下，关联矩阵的存储空间需求是 $ O(|V| \times |E|) $。对于稠密图，存储效率不如邻接矩阵和邻接表。
> - **图的性质**：通过关联矩阵，可以方便地分析图的一些性质，比如某个顶点的度（通过一行中的非零元素个数）等。
> - **适用场景**：关联矩阵更常用于数学分析中，比如研究图的结构性质和网络流问题。
>
> ### 有向图的关联矩阵
>
> 对于有向图，关联矩阵中每个元素的取值为 1、-1 或 0：
>
> - **1** 表示该顶点是某条边的起点。
> - **-1** 表示该顶点是某条边的终点。
> - **0** 表示该顶点与该边无直接关联。
>
> 假设有向图 $ G $ 中有 3 个顶点和 2 条边：
>
> - 边 $ e_1 $ 从 $ v_1 $ 指向 $ v_2 $
> - 边 $ e_2 $ 从 $ v_2 $ 指向 $ v_3 $
>
> 关联矩阵 $ B $ 为：
>
> $
> B = \begin{pmatrix}
> 1 & 0 \\
> -1 & 1 \\
> 0 & -1
> \end{pmatrix}
> $



图的同构没有太多知识点，只有定义等，判断同构的方法未知。

> **图的同构（Graph Isomorphism）** 是图论中的一个概念，用于描述两个图在结构上是相同的，即使它们的顶点和边的标记可能不同。换句话说，如果两个图可以通过重新标记顶点使得它们的结构相同，那么这两个图就是同构的。
>
> ### 1. 定义
>
> 设有两个图 $ G_1 = (V_1, E_1) $ 和 $ G_2 = (V_2, E_2) $，如果存在一个双射 $ f: V_1 \rightarrow V_2 $，使得对于 $ G_1 $ 中的任意一对顶点 $ u, v $，有 $ (u, v) \in E_1 $ 当且仅当 $ (f(u), f(v)) \in E_2 $，那么我们说 $ G_1 $ 和 $ G_2 $ 是同构的，记作 $ G_1 \cong G_2 $。
>
> ### 2. 理解同构的方式
>
> - **拓扑结构相同**：同构的图在拓扑结构上是完全相同的，即它们具有相同的连接方式。顶点的连接关系完全一致，只是顶点的标记或排列顺序不同。
> - **无向图的同构**：无向图的同构关系表示图的顶点可以重新排列，使得两图的边集保持一致。例如，两个三角形形状的无向图都是同构的，不论顶点的标记如何。
> - **有向图的同构**：有向图的同构则要求不仅边的存在性相同，边的方向也必须一致。
>
> ### 3. 同构的性质
>
> - **自同构（Automorphism）**：一个图的自同构是该图与自身之间的同构映射。自同构可以理解为图的对称性。例如，一个正方形的四个顶点之间的映射，即使旋转或翻转，正方形的结构仍保持不变。
>   
> - **同构的不变量**：如果两个图是同构的，那么它们的一些图论性质必须是相同的，例如：
>   - 顶点数和边数相同
>   - 每个顶点的度数（即连接的边数）相同
>   - 环路的数量和长度相同
>   - 连通分量的数量相同
>   - 图的特征多项式相同
>
> ### 4. 判断图同构的困难性
>
> 判断两个图是否同构是一项计算上具有挑战性的任务，称为**图同构问题**。虽然已知多项式时间算法可以有效解决某些特殊图类（如树、平面图、图的谱分解等）的同构问题，但对于一般图同构问题，目前尚无已知的多项式时间算法。
>
> 在2020年，数学家拉兹博罗夫（László Babai）提出了一个准多项式时间复杂度的算法，这是图同构问题研究中的一项重要突破。
>
> ### 5. 例子
>
> 考虑两个无向图 $ G_1 $ 和 $ G_2 $：
>
> - $ G_1 $ 的顶点集 $ V_1 = \{1, 2, 3\} $，边集 $ E_1 = \{(1, 2), (2, 3), (3, 1)\} $。
> - $ G_2 $ 的顶点集 $ V_2 = \{a, b, c\} $，边集 $ E_2 = \{(a, b), (b, c), (c, a)\} $。
>
> 通过将 $ f(1) = a $，$ f(2) = b $，$ f(3) = c $，可以发现 $ G_1 $ 和 $ G_2 $ 是同构的，因为顶点的映射使得它们的边集完全对应。



### 6.4	连通性

通路：边的序列，从图的一个顶点开始沿着图中的边行经图中相邻的顶点。

简单回路：除第一项顶点和最后一项顶点相同，其余顶点不会重复出现的回路。

**简单通路**（Simple Path）是指一条从起始顶点到终止顶点的路径，其中所有的顶点都不重复出现。也就是说，在这条路径上，没有任何一个顶点被访问超过一次。



#### 连通性

1. **无向图的连通性**：
   - **连通图**：如果在无向图中，任意两个顶点之间都存在路径，则称该图是连通的（Connected）。换句话说，在一个连通图中，从任意一个顶点都可以通过某条路径到达任意其他顶点。
   - **连通分量**：在无向图中，每个顶点之间至少有一条路径连接的最大子图称为连通分量（Connected Component）。一个无向图可能由多个连通分量组成。

2. **有向图的连通性**：
   - **强连通图**：如果在有向图中，任意两个顶点之间都存在有向路径（即对于任意两个顶点 $u$ 和 $v$，既存在从 $u$ 到 $v$ 的路径，也存在从 $v$ 到 $u$ 的路径），则称该图是强连通的（Strongly Connected）。
   - **弱连通图**：如果将有向图中的所有边都看作无向边后，图是连通的，则称该图是弱连通的（Weakly Connected）。
   - **强连通分量**：在有向图中，每个顶点之间存在有向路径的最大子图称为强连通分量（Strongly Connected Component, SCC）。



#### 割点和桥

> 在图论中，**割点**（Cut Vertex）和**桥**（Bridge）是与图的连通性密切相关的概念，用来描述图中某些关键顶点或边，它们的移除会影响图的连通性。
>
> ### 割点（Cut Vertex）
> 割点是指在一个连通图中，如果移除这个顶点（以及与它相连的所有边）会导致图的连通性被破坏，使得图中至少有两个顶点间不再连通，则称这个顶点为割点。
>
> - **形式化定义**：给定一个连通图 $G = (V, E)$ 和其中的一个顶点 $v \in V$。如果移除顶点 $v$ 以及所有与之相关联的边后，图 $G$ 的剩余部分不再是连通图（即图被分成了两个或更多个连通分量），那么 $v$ 就是割点。
>
> ### 桥（Bridge）
> 桥（也叫割边，Cut Edge）是指在一个连通图中，如果移除这条边会导致图的连通性被破坏，使得图被分成两个或多个连通分量，则称这条边为桥。
>
> - **形式化定义**：给定一个连通图 $G = (V, E)$ 和其中的一条边 $e \in E$。如果移除边 $e$ 后，图 $G$ 的剩余部分不再是连通图（即图被分成了两个或更多个连通分量），那么 $e$ 就是桥。
>
> ### 示例说明
> - **割点**：设有一个图 $G$，其中某个顶点 $v$ 连接了两个大的子图。如果移除 $v$ 后，这两个子图将变得不连通，那么 $v$ 是割点。
> - **桥**：设有一个图 $G$，其中某条边 $e$ 是连接两个大的子图的唯一通道。如果移除 $e$ 后，这两个子图将变得不连通，那么 $e$ 是桥。





#### 点连通性（Vertex Connectivity）
点连通性是指在一个连通图中，需要移除的最少顶点数，使得图变得不连通或只有单个顶点。

- **形式化定义**：给定一个连通图 $G = (V, E)$，图的点连通性 $ \kappa(G) $ 是指从图中移除的最少顶点数，使得剩余的图不再是连通的。
- 如果 $G$ 是一个完全图（即任意两点之间都有一条边），那么点连通性等于顶点数减一。
- 如果 $ \kappa(G) = k $，意味着移除任意少于 $k$ 个顶点，图仍然是连通的，但移除恰好 $k$ 个顶点时，图可能会变得不连通。

#### 边连通性（Edge Connectivity）
边连通性是指在一个连通图中，需要移除的最少边数，使得图变得不连通。

- **形式化定义**：给定一个连通图 $G = (V, E)$，图的边连通性 $ \lambda(G) $ 是指从图中移除的最少边数，使得剩余的图不再是连通的。
- 如果 $ \lambda(G) = k $，意味着移除任意少于 $k$ 条边，图仍然是连通的，但移除恰好 $k$ 条边时，图可能会变得不连通。

**示例说明**

1. **点连通性**：
   - 考虑一个三角形（完全图 $K_3$），图的点连通性为 2，因为移除任意两个顶点，图就变成了孤立的顶点。
   - 对于一个链状图（类似于一条直线上的顶点链），图的点连通性为 1，因为移除任意一个中间顶点，图就会分成两部分。

2. **边连通性**：
   - 对于一个四边形，图的边连通性为 2，因为移除任意两条边，可以使图分为两个部分。
   - 对于一个链状图（类似于一条直线上的顶点链），图的边连通性为 1，因为移除任意一条边，图就会分成两部分。

**点连通性与边连通性之间的关系**

- 对于任意连通图 $G$，其点连通性 $ \kappa(G) $ 总是小于等于边连通性 $ \lambda(G) $。
- 在一个完全图中，点连通性和边连通性是相等的。



#### **一连通**、**双练通**和**K连通**

 $ \kappa(G) $越大，$G$的连通性越好。

若$G$含有$n$个顶点，那么$0\leq \kappa(G) \leq n-1$，等于0的情况只有$G$是不连通的，或者$G=K_1$。

同理，若$G$含有$n$个顶点，那么$0\leq \lambda(G) \leq n-1$，等于0的情况只有$G$是不连通的，或者$G$只有一个顶点。

若$G$含有$n$个顶点，且$\lambda(G)=n-1$，那么只有$G=K_n$时才成立。若$G$不是完全图，那么$\lambda(G)\leq n-2$。

> 在图论中，**一联通**、**双联通**和**$k$联通**用于描述图的连通性强度。它们通过分析图中顶点或边的冗余度来衡量图的连通性。以下是它们的定义：
>
> ### 一联通（1-Connected）
> **一联通**，也称为**连通图**，是指图中任意两个顶点之间至少存在一条路径。如果移除一个顶点或边会导致图变得不连通，那么这个图就是一联通的。
>
> - **形式化定义**：一个图 $G$ 是一联通的，如果图 $G$ 是连通的，即在图中，任意两个顶点之间至少存在一条路径。
> - **特点**：一联通图的最小点割集或边割集的大小为1。这意味着，移除一个顶点或一条边可能会使图变得不连通。
>
> ### 双联通（2-Connected）
> **双联通**，也称为**2-连通**，是指图在移除任意一个顶点的情况下，仍然保持连通。如果一个图是双联通的，那么图中不存在割点。
>
> - **形式化定义**：一个图 $G$ 是双联通的，如果对于图中的任意一个顶点 $v$，移除 $v$ 及其相关的边后，剩余的图仍然是连通的。
> - **特点**：
>   - 图中任意两个顶点之间至少存在两条不共享顶点的路径。
>   - 双联通图中没有割点，也就是说，移除任意一个顶点不会使图变得不连通。
>   - 双联通图的最小点割集的大小为2。
>
> ### $k$联通（$k$-Connected）
> **$k$联通**是对连通性概念的进一步推广。一个图是$k$联通的，表示移除任意少于$k$个顶点后，图仍然保持连通。
>
> - **形式化定义**：一个图 $G$ 是$k$联通的，如果对于图中的任意顶点集合 $S$ ，其中 $ |S| < k $，移除这些顶点及其相关的边后，剩余的图仍然是连通的。
> - **特点**：
>   - 图中任意两个顶点之间至少存在 $k$ 条不共享顶点的路径。
>   - $k$联通图中，最小点割集的大小为$k$。
>   - $k$越大，图的连通性越强，即移除的顶点越多，图仍然保持连通的能力越强。
>
> ### 示例说明
>
> 1. **一联通**：简单的路径图或树状图是典型的一联通图。移除某个顶点或边，图可能会变得不连通。
>
> 2. **双联通**：一个三角形图（完全图 $K_3$）是双联通的，因为移除任意一个顶点后，剩下的两个顶点仍然是连通的。
>
> 3. **$k$联通**：对于一个完全图 $K_n$，它是 $n-1$ 联通的。比如，完全图 $K_4$ 是3联通的，因为移除任意少于3个顶点，图仍然保持连通。
>
> ### 关系与区别
>
> - **一联通**是最弱的连通性要求，保证了任意两点间至少有一条路径。
> - **双联通**进一步要求在移除任意一个顶点后，图仍然连通。
> - **$k$联通**则推广了这一概念，要求移除任意少于 $k$ 个顶点后，图仍然连通。
>
> **总结**：**一联通**、**双联通**和**$k$联通**是衡量图连通性的不同级别，它们描述了图在面对顶点或边的移除时，保持连通的能力。$k$联通性越高，图的连通性就越强。



#### Whitney 不等式

一个联系点连通度，边连通度和最小点的度的不等式：
$$
\kappa(G)\leq \lambda(G)\leq min_{v\in V} deg(v)
$$
这个不等式对所有情况都成立。

特别的，当这是一个完全图时：
$$
\kappa(K_n)=\lambda(K_n)=min_{v\in V}deg(v)=n-1
$$

### 6.5	欧拉通路与哈密顿通路

#### 欧拉通路

##### 定义

欧拉回路：通过图中**每条边恰好一次**的回路

欧拉通路：通过图中**每条边恰好一次**的通路

欧拉图：具有欧拉回路的图

半欧拉图：具有欧拉通路，但是不具有欧拉回路的图



**欧拉路径条件**

- **必要条件**：图必须是连通的，可能有孤立的顶点。
- **充分条件**：图有欧拉路径当且仅当它恰好有两个顶点的度数是奇数（或者对于欧拉回路，所有顶点的度数都是偶数）。

**欧拉回路条件**：

- **必要且充分条件**：一个连通图当且仅当它的每个顶点的度数都是偶数时，才有欧拉回路。



##### 性质

欧拉图中的所有顶点的度数都是偶数。

若$G$是欧拉图，则它是若干个环的并，且每条边被包含在奇数个环内。

具有欧拉通路但是没有欧拉回路的图：当且仅当它恰有2个度为奇数的顶点。（很好理解，除了起点和终点度数为1，其他顶点度数都是2）。

##### 实现

**Hierholzer算法**

###### 过程

算法流程为从一条回路开始，每次任取一条目前回路中的点，将其替换为一条简单回路，以此寻找到一条欧拉回路。如果从路开始的话，就可以寻找到一条欧拉路。



###### 代码实现

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409050951790.webp)



#### 哈密顿通路

##### 定义

哈密顿通路：通过图中所有顶点一次且仅有一次的通路。

哈密顿回路：通过图中所有顶点一次且仅有一次的回路。

哈密顿图：具有哈密顿回路的图。

半哈密顿图：具有哈密顿通路而不具有哈密顿回路的图。



##### 存在条件

没有已知的充要条件来判断哈密顿回路的存在性。

不过存在一些性质可以判断是否存在：

如：带有度数为1的顶点的图没有哈密顿回路。因为哈密顿回路中的每个顶点都关联两条边。

此外，若图中有度为2的顶点，则关联这个顶点的两条边术语任意一条哈密顿回路。

还有一些特别的情况：

- 当$3 \leq n$，$K_n$有哈密顿回路。
- **哈密顿回路的充分条件**：如果一个图是**完全图**（即每对顶点之间都有边），则它必定有哈密顿回路。
- 一般来说，一个图的边越多，这个图就越有可能是哈密顿回路。
- 狄拉克定理：如果$G$是有$n$个顶点的简单图，其中$3 \leq n$，其中$G$中的每个顶点的度数至少都是$\frac{n}{2}$，则$G$具有哈密顿回路。
- 欧尔定理：如果$G$是有$n$个顶点的简单图，其中$3 \leq n$，并且对于$G$中的每一对不相邻的顶点$u$和$v$来说，都有$n \leq deg(u)+deg(v)$，则$G$具有哈密顿回路。



### 6.6	最短通路问题

- **哈密顿回路的充分条件**：如果一个图是**完全图**（即每对顶点之间都有边），则它必定有哈密顿回路。
- **最短路径问题**：寻找两顶点之间的路径，使得路径上所有边的权重和最小。

主要是介绍了迪杰斯特拉算法。

这个直接看相关的算法竞赛文章：

[单源（全源）最短路及其应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/651688492)

[算法学习笔记(6)：最短路问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/96621396)



旅行商问题简单了解一下就行。

> 旅行商问题（Travelling Salesman Problem, TSP）是计算机科学和运筹学中的经典优化问题。它的目标是找到一条最短的闭合路径，使得旅行商访问每个城市恰好一次，并最终回到起点城市。TSP 的具体定义如下：
>
> ### 问题定义
>
> 给定一个包含 $ n $ 个城市的图（通常是一个完全图），每对城市之间有一个非负的距离（或成本）。旅行商问题要求找到一条路径，使得这条路径经过每个城市一次且仅一次，并返回到起始城市，同时路径的总长度（或总成本）最小。
>
> ### TSP 的数学模型
>
> 假设有 $ n $ 个城市，其中城市 $ i $ 到城市 $ j $ 的距离为 $ d_{ij} $。我们需要找到一个循环路径，使得：
> $ \text{Minimize} \sum_{i=1}^{n} d_{i, \sigma(i)} $
> 其中 $ \sigma $ 是一个排列，使得路径包含所有城市且每个城市都被访问一次，最后返回到起始城市。
>
> ### TSP 的复杂性
>
> TSP 是一个 NP-hard 问题，这意味着没有已知的多项式时间算法可以解决所有 TSP 实例。因此，解决 TSP 通常依赖于启发式算法或近似算法。
>
> ### 解决 TSP 的方法
>
> 1. **暴力搜索**：
>    - 穷举所有可能的路径，并计算每条路径的总长度。这种方法在实际应用中通常不可行，因为路径的数量是 $ (n-1)! $，随着城市数量增加，计算量极大。因为可以使用相反的顺序来经过同一条路线，所以只需要检查$\frac{(n-1)!}{2}$条路径即可。
>
> 2. **动态规划**：
>    - 使用动态规划（如 Held-Karp 算法）可以在 $ O(n^2 2^n) $ 的时间复杂度内解决问题。虽然比暴力搜索效率高，但对于大规模实例仍然不可行。
>
> 3. **近似算法**：
>    - 使用启发式或近似算法来找到一个较好的解，例如：
>      - **贪心算法**：每次选择最近的城市作为下一步。
>      - **遗传算法**：模拟自然选择和遗传变异过程来寻找解。
>      - **模拟退火**：模拟物质在冷却过程中达到最低能量状态的过程。
>      - **蚁群算法**：模拟蚂蚁寻找食物路径的过程来找到解。
>      - **局部搜索**：从一个初始解开始，通过局部调整不断改进解。
>
> 4. **分支限界法**：
>    - 一种系统地探索所有可能解的策略，通过剪枝减少搜索空间。
>



### 6.7	平面图

平面图：在平面中的一个图，其没有任何边是交叉的。可以嵌入平面中的图，意味着它可以在平面上绘制而不产生任何边交叉。

**图的平面表示**：平面图的绘制方式，使得图中的边不交叉。



#### 平面图性质

> 1. **欧拉公式**：
>    - 对于连通的平面图，假设图中有 $ V $ 个顶点，$ E $ 条边，$ F $ 个面（区域），欧拉公式表明：
>      $
>      V - E + F = 2
>      $
>      其中，面（包括无限面，即外部区域）是图将平面划分的区域。
>
> 2. **边数的上界**：
>    - 对于没有自环和多重边的简单平面图，存在以下不等式：
>      $
>      E \leq 3V - 6
>      $
>      对于没有三角形（即所有面都至少有四条边）的平面图，有：
>      $
>      E \leq 2V - 4
>      $
>
> 3. **平面性判定**：
>    - 可以使用库拉托夫斯基定理（Kuratowski's Theorem）判断图的平面性。该定理指出，一个图是平面图，当且仅当它不包含 $ K_5 $（完全五边图）或 $ K_{3,3} $（完全二分图）的子图。
>



又或者表述如下：

若$G$是$e$条边和$v$个顶点的连通平面简单图，其中$ 3 \leq v$，则$e \leq 3v-6$。

由此可以得到以下结论：若$G$是连通平面简单图，则$G$中有度数不超过5的顶点。



若$G$是$e$条边和$v$个顶点的连通平面简单图，其中$ 3 \leq v$，且没有长度为3的回路，则$e \leq 2v-4$。



**初等细分**：若一个图是平面图，则通过删除一条边$\{u,v\}$并且添加一个新顶点$w$和两条边$\{u，w\}$与$\{w,v\}$获得的任何图也是平面图。

**同胚**：可以从相同的图通过一系列初等细分来获得图$G_1=\{V_1,E_1\}$，$G_2=\{V_2,E_2\}$。



> 库拉图斯基定理（Kuratowski's Theorem）是图论中的一个重要定理，用于判断一个图是否是平面图。该定理由波兰数学家卡齐米日·库拉图斯基（Kazimierz Kuratowski）于1930年提出。
>
> ### 库拉图斯基定理的内容
>
> **定理陈述**：
> 一个无向图是平面图的充要条件是它不包含 $ K_5 $（完全五边图）或 $ K_{3,3} $（完全二分图）的**任意子图的同胚**。
>
> 这里的“同胚”指的是通过对图的一些边进行**细分**（即在边上添加额外的顶点），或者将某些顶点的度为2的顶点去掉来简化结构，但不改变图的连通性或边的相对关系。
>
> ### 完全五边图 $ K_5 $ 和完全二分图 $ K_{3,3} $
>
> - **$ K_5 $** 是一个包含5个顶点、且任意两个顶点之间都有一条边的完全图。它的每个顶点都有4条边相连，总共10条边。
>
> - **$ K_{3,3} $** 是一个二分图，它有两组顶点，每组有3个顶点，且每个顶点都与另一组的所有顶点相连。这个图常用于表示“三桥问题”。
>
> ### 定理的意义
>
> 库拉图斯基定理为平面图的判定提供了一个明确的标准。如果我们能够在一个图中找到 $ K_5 $ 或 $ K_{3,3} $ 的同胚子图，那么这个图就不是平面图，反之，如果没有这样的子图，图就是平面图。
>
> ### 如何使用库拉图斯基定理
>
> 要判定一个图是否是平面图，可以按照以下步骤：
>
> 1. **寻找 $ K_5 $ 或 $ K_{3,3} $ 子图**：
>    - 检查图中是否可以找到与 $ K_5 $ 或 $ K_{3,3} $ 同构的子图。
>
> 2. **检查同胚子图**：
>    - 通过细分或简化的方法，看看图中是否可以通过操作形成 $ K_5 $ 或 $ K_{3,3} $ 的同胚子图。
>
> 3. **判定平面性**：
>    - 如果找到这样的子图，则图不是平面图；如果找不到，图是平面图。
>
> ### 示例
>
> 考虑一个图 $ G $ ，它包含6个顶点和9条边，边的集合为：
> $ E(G) = \{(1,2), (1,3), (1,4), (2,3), (2,5), (3,6), (4,5), (4,6), (5,6)\} $
>
> 1. 我们首先检查图中是否存在与 $ K_5 $ 同构的子图。由于图只有6个顶点，而 $ K_5 $ 需要5个顶点并且每对顶点之间都有一条边（需要10条边），因此不可能存在 $ K_5 $ 的同构子图。
>
> 2. 接下来检查是否存在与 $ K_{3,3} $ 同构的子图。我们可以通过查看顶点的连接方式判断是否有两个大小为3的集合，每个集合内的点没有边相连，而是完全连接到另一组的点。如果没有这样一种结构，图就不会包含 $ K_{3,3} $ 的子图。
>
> 如果上述检查都不成立，我们可以推断这个图是平面图。
>
> ### 图的平面性判断的实际应用
>
> 库拉图斯基定理在网络设计、电子电路设计、地理信息系统等领域中有重要应用。在这些领域，确定图的平面性有助于设计高效且易于实现的布局和连接方式。
>
> 总结来说，库拉图斯基定理为图的平面性提供了一个直观的判定方法，通过查找特定的子图结构，可以快速判断图是否能在平面上绘制而没有边的交叉。



> 在图论中，**同构**（isomorphic）指的是两个图的结构相同，即它们的顶点和边可以通过重新标记顶点来一一对应。如果两个图是同构的，那么从一个图可以通过重新命名顶点获得另一个图，而图的结构或连接方式不会改变。
>
> ### 什么是同构的子图？
>
> 一个图 $ G $ 的子图 $ H $ 是从 $ G $ 中选取一部分顶点和这些顶点之间的边构成的图。如果子图 $ H $ 和某个标准图（比如 $ K_5 $ 或 $ K_{3,3} $）是同构的，意味着在 $ G $ 中存在一个结构与 $ K_5 $ 或 $ K_{3,3} $ 完全相同的子图。也就是说，这个子图的顶点和边可以被重新标记为 $ K_5 $ 或 $ K_{3,3} $ 中的顶点和边。
>
> ### 示例解释
>
> #### 1. **$ K_5 $ 同构的子图**
>    - **$ K_5 $** 是一个包含5个顶点的完全图，意味着每对顶点之间都有一条边。总共有5个顶点和10条边。
>
>    - 如果我们在一个图 $ G $ 中找到一个子图，它包含5个顶点，并且这些顶点之间的边数和连接方式与 $ K_5 $ 相同，那么这个子图就是与 $ K_5 $ 同构的子图。
>
> #### 2. **$ K_{3,3} $ 同构的子图**
>    - **$ K_{3,3} $** 是一个完全二分图，具有两组顶点，每组有3个顶点。每个顶点与另一组的所有顶点相连，而同一组内部没有任何连接。总共有6个顶点和9条边。
>
>    - 如果我们在一个图 $ G $ 中找到一个子图，它可以被划分为两个顶点集，每个集有3个顶点，并且只有两个集之间有连接，而集内部没有边，那么这个子图就是与 $ K_{3,3} $ 同构的子图。
>
> ### 示例图
>
> 假设我们有如下图 $ G $：
>
> ```
> 1 -- 2 -- 3
> |  \  |  / |
> 4 -- 5 -- 6
> ```
>
> 在这个图中，假设我们检查是否存在一个与 $ K_5 $ 同构的子图：
>
> 1. 选择顶点 1, 2, 3, 5, 6。
> 2. 这些顶点之间的连接方式形成一个完全图，每对顶点都有一条边。因此，这个子图与 $ K_5 $ 同构。
>
> 现在假设我们检查是否存在一个与 $ K_{3,3} $ 同构的子图：
>
> 1. 分成两组顶点，假设第一组是 {1, 4, 5}，第二组是 {2, 3, 6}。
> 2. 每个顶点组中的顶点都与另一组中的顶点相连，并且同一组中的顶点之间没有连接。因此，这个子图与 $ K_{3,3} $ 同构。
>
> ### 总结
>
> 当一个图包含与 $ K_5 $ 或 $ K_{3,3} $ 同构的子图时，这意味着图中存在与这些标准图结构相同的部分。这对于判断一个图是否是平面图至关重要，因为库拉图斯基定理表明，若图中存在这样的子图，那么该图就不是平面图。



### 6.8	图着色

对无向图顶点着色，且相邻顶点不能同色。若 G 是$k$可着色的，但不是$(k-1)$可着色的，则称$k$是 G 的色数，记为 $\chi{(G)}$。

> 在图论中，**对偶图**（Dual Graph）是与给定图相关联的另一个图，通常用于平面图（即可以在平面上绘制而不会有边相交的图）中。对偶图的定义如下：
>
> 1. **顶点**：给定平面图的每个面（包括外面）对应对偶图的一个顶点。
>    
> 2. **边**：对偶图中的一条边对应于原图中两条相邻面的公共边。换句话说，如果两个面在原图中共享一条边，那么对偶图中这两个面对应的顶点之间就有一条边。
>
> 简单来说，对偶图的顶点表示原图的面，而对偶图的边表示原图中相邻面的连接关系。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409090933436.webp)



**图着色**：简单图的着色是对该图的每个顶点都指定一种颜色，使得没有两个相邻的顶点颜色相同。

**图的着色数**：着色这个图所需要的最少颜色数。图$G$的着色数记作$\chi{(G)}$。

**四色定理**：平面图的着色数不超过4。任何平面图都可以用至多四种颜色着色，使得没有两个相邻的区域（或顶点）颜色相同。



证明一个图的着色数为$n$需要做两件事：首先必须证明：用$n$种颜色可以着色这个图。构造出这样的着色就可以完成这件事。其次证明：用少于$n$种颜色不能着色这个图。



$K_n$的着色数是$\chi{(K_n)}=n$。因为这个图中的每两个顶点都是相邻的。（注意$5 \leq n$时，$K_n$不是平面图，所以与四色定理不冲突）。



完全二分图$K_{m,n}$的着色数是2。因为$K_{m,n}$十年二分图。



图$C_n$（$3 \leq n$）的着色数需要分类讨论：（图$C_n$是带有$n$个顶点的圆圈）

- $n$为奇数：我们先拆成链，然后进行计算：我们可以交替两种颜色，`n`为奇数的情况下，第一个顶点和最后一个顶点颜色都是相同的。所以最后成环时不满足题意，需要再多一个颜色。
- $n$为偶数：还是进行一样的处理。但是这个时候第一个顶点和最后一个顶点颜色时不同的，所以只需要两种颜色即可。





## 第七章

### 7.1	树的概述

定义：树是没有简单回路的连通无向图。

如果不连通，则是**森林**。

一个无向图是树当且仅当它的每对顶点之间存在唯一简单通路。

有根树：指定一个点为根，并且每条边的方向都离开根的树。

一些术语直接看[树基础 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/tree-basic/#有根树)。

树的顶点若没有孩子则称为树叶，否则称为内点。



`m`叉树：有根树的每个内点都有不超过`m`个孩子，则称它为`m`叉树。若恰好都有`m`个孩子，则成为满`m`叉树。

有序根树：每个内点的孩子都排序的有根树。



接下来是一些树的相关性质：

- 带有`n`个顶点的树含有`n-1`条边。
- 带有`i`个内点的满`m`叉树含有`mi+1`个孩子。
- 一个满`m`叉树如果有：
  1. `n`个顶点，则有`(n-1)/m`个内点和`((m-1)n+1)/m`个树叶。
  2. `i`个内点，则有`mi+1`个顶点和`(m-1)i+1`个树叶。
  3. `l`个树叶，则有`n=(ml-1)/(m-1)`个顶点和`i=(l-1)/(m-1)`个内点。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409091006749.webp)



**平衡**：若一棵高度为$h$的$m$叉树的所有树叶都在$h$层或者$h-1$层，则这颗树时平衡的。



**在高度为`h`的`m`叉树种最多有$m^k$个树叶**。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409091014048.webp)



### 7.2	树的应用



## 第八章

只介绍前两节，后面的内容在数字逻辑都有介绍。

### 8.1	布尔函数

#### 基本概念

> ### 布尔变元（Boolean Variable）
> 布尔变元是一种只能取两个值的变量：`True`（真）或 `False`（假）。在布尔代数中，布尔变元通常用字母如 `x`、`y`、`z` 等来表示，它们的值可以是 `0`（假）或 `1`（真）。
>
> ### 布尔函数（Boolean Function）
> 布尔函数是一种从布尔变元映射到布尔值的函数。也就是说，布尔函数的输入是布尔变元（或它们的组合），输出是 `True` 或 `False`（或者等价的 `1` 或 `0`）。一个典型的布尔函数可以由布尔运算（如 `AND`、`OR`、`NOT`）构成。
>
> #### 布尔函数的常见运算：
> 1. **AND（与运算）**：`A AND B`，当且仅当 `A` 和 `B` 都为真时，结果为真。
>    - 逻辑表达式：`A ∧ B`
>    - 例如：`1 AND 0 = 0`
>
> 2. **OR（或运算）**：`A OR B`，当 `A` 或 `B` 至少一个为真时，结果为真。
>    - 逻辑表达式：`A ∨ B`
>    - 例如：`1 OR 0 = 1`
>
> 3. **NOT（非运算）**：`NOT A`，将布尔值取反。
>    - 逻辑表达式：`¬A`
>    - 例如：`NOT 1 = 0`
>
> #### 布尔函数的例子：
> 假设有两个布尔变元 `A` 和 `B`，一个简单的布尔函数可以是：
> $ F(A, B) = A \land \neg B $
> 当 `A` 为真且 `B` 为假时，`F(A, B)` 的值为真，否则为假。
>
> 布尔函数是数字电路、计算机逻辑、逻辑编程和离散数学的基础构件。



表示同一个函数的不同的布尔表达式是**等价的**。

布尔函数$F$的补函数为$\bar{F}$。



#### 布尔恒等式

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409091718252.webp)



#### 补充定义

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409091720351.webp)



### 8.2	布尔函数的表示

#### 积之和展开式

> ### 积之和（Sum of Products，简称 **SOP**）
>
> **积之和**是一种表示布尔函数的标准形式，常用于逻辑电路设计和布尔代数中的简化。积之和形式是布尔表达式的一种**规范形式**，其中每个子表达式是**与运算**的结果，这些子表达式通过**或运算**组合在一起。
>
> ### 积之和的结构
> - 每一个与运算（**AND**）的结果称为一个“**积项**”。
> - 多个积项通过或运算（**OR**）连接起来。
> - 每个积项是由一个或多个布尔变元（可能取反）通过与运算组合得到的。
>
> **例如：**
> \[ F(A, B, C) = (\neg A \land B \land C) \lor (A \land \neg B \land C) \lor (A \land B \land \neg C) \]
>
> 这个函数的每个积项（如 `\neg A \land B \land C`）都是与运算，而整个函数则是多个积项的或运算。
>
> ### 构造积之和形式
> 要将布尔函数写成积之和的形式，可以使用函数的**真值表**：
> 1. 找出函数为 `1`（真） 的所有输入组合。
> 2. 对于每个 `1` 的输入组合，构造对应的积项。每个布尔变量在对应输入值为 `1` 时保持原样，为 `0` 时取反。
> 3. 将所有这些积项通过或运算连接起来。
>
> ### 举例
> 假设我们有一个布尔函数的真值表如下：
>
> | A    | B    | C    | F(A, B, C) |
> | ---- | ---- | ---- | ---------- |
> | 0    | 0    | 0    | 0          |
> | 0    | 0    | 1    | 1          |
> | 0    | 1    | 0    | 0          |
> | 0    | 1    | 1    | 1          |
> | 1    | 0    | 0    | 0          |
> | 1    | 0    | 1    | 1          |
> | 1    | 1    | 0    | 0          |
> | 1    | 1    | 1    | 1          |
>
> 在这个真值表中，`F(A, B, C)` 在 `A=0, B=0, C=1`，`A=0, B=1, C=1`，`A=1, B=0, C=1`，`A=1, B=1, C=1` 时为真。
>
> 对应的积项为：
> - 对于 `A=0, B=0, C=1`，积项是：`(\neg A \land \neg B \land C)`
> - 对于 `A=0, B=1, C=1`，积项是：`(\neg A \land B \land C)`
> - 对于 `A=1, B=0, C=1`，积项是：`(A \land \neg B \land C)`
> - 对于 `A=1, B=1, C=1`，积项是：`(A \land B \land C)`
>
> 最终，布尔函数的积之和形式为：
> \[ F(A, B, C) = (\neg A \land \neg B \land C) \lor (\neg A \land B \land C) \lor (A \land \neg B \land C) \lor (A \land B \land C) \]
>
> ### 积之和的重要性
> - **逻辑电路实现**：积之和形式与电路实现密切相关。每个积项可以表示为一个与门，每个或运算可以表示为一个或门。这种形式便于从布尔表达式直接转化为电路结构。
> - **规范化**：积之和是布尔表达式的一种标准化表示，便于分析和化简布尔函数。
>
> 通过使用 **卡诺图** 或 **奎因-麦克拉斯基算法**，还可以对积之和形式进行简化，以优化逻辑电路的实现。



直接用例题介绍好一些。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409091727631.webp)



#### 函数完备性

> ### 布尔函数的完备性（Functional Completeness）
> 在布尔代数中，**完备性**是指一组布尔运算是否能够表示所有可能的布尔函数。换句话说，如果某个运算集是**完备的**，那么你可以用该集合中的运算组合出任何布尔函数。
>
> #### 常见的完备运算集：
> 1. **AND、OR、NOT**：这是一个经典的完备运算集。通过这三个运算，可以组合出任意布尔函数。例如，任意布尔函数都可以通过合适的与、或、非运算来实现。
>    
> 2. **NAND**（与非）：这是一个非常重要的运算，因为**NAND**（即“与非”运算）是一个完备的运算。仅仅使用 NAND 运算，你就可以实现所有布尔运算：
>    - `NOT A = A NAND A`
>    - `A AND B = NOT(A NAND B)`
>    - `A OR B = (NOT A) NAND (NOT B)`
>
> 3. **NOR**（或非）：类似地，**NOR**（即“或非”运算）也是完备的。仅使用 NOR 运算也可以构造出任意布尔函数：
>    - `NOT A = A NOR A`
>    - `A AND B = (NOT A) NOR (NOT B)`
>    - `A OR B = A NOR (B NOR B)`
>
> ### 如何判断一组运算的完备性？
> 布尔函数的完备性可以通过以下两个条件之一判断：
> 1. **闭包**：如果某个运算集能够通过自身组合生成 `AND`、`OR` 和 `NOT`，则它是完备的。
> 2. **Sheffer’s 定理**：如果一个布尔运算不能满足下列三个条件之一，那么它是完备的：
>    - 它是恒等的（即输出与输入相同）。
>    - 它只生成常量函数（即输出总是 0 或 1）。
>    - 它是单调的（即输入的真值不减少时输出不会减少）。
>
> ### 完备运算集的重要性
> 在实际应用中，完备的布尔运算集使得设计电路和编写程序变得更加灵活。数字电路中广泛使用的 NAND 门或 NOR 门就是因为它们的完备性，可以通过简单的硬件实现所有的逻辑运算。
