# 简答题

### What is the difference between a subroutine and an interrupt-service routine?

Solution:

**子程序**：它执行的是调用它的那个程序所需要的功能。所以，对于状态信息以及寄存器内容可能出现的变化，是在预期范围内的。

**中断服务程序**：它可能和接收到中断请求时正在执行的程序部分没有任何关联。因此，在开始执行中断服务程序之前，那些在该程序执行过程中可能会以不可预期的方式被改变的处理器寄存器状态信息以及寄存器内容，都必须先进行保存。而且，在被中断的程序恢复执行之前，这些保存好的信息还需要被恢复回来。



**子程序是通过程序指令调用的，用于执行调用程序所需的功能。**

**中断服务程序是由事件触发的，例如输入操作或硬件错误。它执行的功能可能与发生中断时正在执行的程序完全无关。因此，中断服务程序不能影响与该程序相关的任何数据或状态信息。**



### What are the advantages and disadvantages of hardwired and microprogrammed control?

**Solution:**

硬件：优点是速度更快

缺点是成本高，设计复杂，不够灵活

 

微程序：优点是灵活，消耗低

缺点是速度慢，在高性能计算机中可能成为一个问题



### Explain the drawback of the ripple carry full adder when you need to design 64-bit CPU core. And give a solution for the drawback. (Just give a name of the circuit. You don’t need to draw a circuit of solution).

**Solution:**

1. **在64位CPU核心设计中，行波进位全加器的缺点**

  - **传播延迟**：

   - 行波进位全加器用于构建多位加法器（如64位加法器）时存在严重的传播延迟问题。在这种加法器中，一级的进位输出是下一级的进位输入，进位信号要从最低有效位（LSB）“逐位传递”到最高有效位（MSB）。

   - 对于n位行波进位加法器，最坏情况下的传播延迟与n成正比。在64位行波进位加法器中，这个延迟会很大，会限制加法器的运算速度，进而影响CPU核心的整体速度。例如，若每个全加器级的传播延迟是$t_{pd}$，在64位行波进位加法器中，总的进位传播延迟可能高达$64\times t_{pd}$。

2. **解决方案**

- 可以使用**超前进位加法器（Carry - Lookahead Adder，CLA）**来解决这个问题。超前进位加法器通过更并行、更具前瞻性的方式生成进位信号，减少了进位传播延迟。它不是等待进位逐位传递，而是根据输入位同时计算所有级的进位输入信号，这大大减少了总体传播延迟，能实现更快的加法运算，这对64位CPU核心的高效运行很关键。





### A system has 48-bit virtual addresses and 36-bit physical addresses. If the system uses 4096-byte pages, how many virtual and physical pages can the address space support? 

**Solution:**

**The following steps will help us calculate the number of virtual and physical pages supported by the address space:**

**1. 计算虚拟页面数量**

我们已知页面大小为4096字节，等同于$2^{12}$字节。虚拟地址空间为48位。

虚拟页面数量$N_{v}$可通过将整个虚拟地址空间除以页面大小来计算。

虚拟地址空间中不同地址的总数是$2^{48}$个。由于每个页面有$2^{12}$字节，所以虚拟页面数量$N_{v}$可由以下公式得出：

$$
N_{v}=\frac{2^{48}}{2^{12}} = 2^{48 - 12}=2^{36}
$$
**2. 计算物理页面数量**

物理地址空间为36位。物理地址空间中不同地址的总数是$2^{36}$个。

因为每个页面的大小为$2^{12}$字节，所以物理页面数量$N_{p}$由以下公式给出：

$$
N_{p}=\frac{2^{36}}{2^{12}}= 2^{36 - 12} = 2^{24}
$$


因此，虚拟地址空间能够支持$2^{36}$个虚拟页面，而物理地址空间能够支持$2^{24}$个物理页面。



### What is the difference between DRAM and SRAM, in terms of characteristics such as speed, size, cost and application? 

Solution:
DRAM：速度较慢，密度高，成本低，一般用于实现存储器
SRAM：速度快，密度低，成本高，一般用于实现高速缓存

**速度**

  - SRAM快，数据访问时间通常在10纳秒以下，因为用双稳态触发器存储数据。
  - DRAM相对慢，数据访问时间一般在几十纳秒左右，因其基于电容存储，且读取写入涉及复杂过程。

**尺寸**

  - SRAM存储单元电路复杂，存储密度低，相同面积下存储数据量少。
  - DRAM存储单元结构简单，存储密度高，能在较小面积存储大量数据。

**成本**

  - SRAM高，因电路复杂、存储密度低，制造材料和工艺要求高。
  - DRAM低，存储单元结构简单、存储密度高，大规模生产价格亲民。

**应用**

  - SRAM用于对速度要求极高的地方，如CPU高速缓存、小型嵌入式系统。
  - DRAM是计算机主存主要成分，也用于GPU显存等大容量存储设备。



### In what circumstance will arithmetic overflow occur when two integers represented by 2's complement form are added? And write out the logic expression to detect overflow.

**Solution:**

当两个操作数的符号（减法转换为加法处理）与得到的结果符号不同时，会产生溢出。

可以根据这个得到表达式：
$$
overflow &= x_ny_n \overline{s_n} + \overline{x_n} \ \overline{y_n} s_n \\
overflow &= c_n \oplus c_{n-1}
$$


### Describe the process of interrupt processing. 

**Solution:**

1. **中断请求**：外部设备或内部事件通过中断请求线向CPU发送信号，请求CPU处理紧急事务。
2. **中断响应**：CPU在当前指令周期结束后检查请求，若符合条件则暂停当前程序，保存上下文后发送响应信号。
3. **中断识别**：通过查询中断向量表或中断控制器确定中断源。
4. **中断服务程序执行**：CPU跳转到对应的中断服务程序入口，执行程序处理中断事件。
5. **中断返回**：中断服务程序执行完后，CPU恢复被中断程序的上下文并继续执行。





**(1) CPU响应时间的差异**

 **DMA（直接内存访问）方法**

- DMA请求通常在外部设备准备好进行批量数据传输时发出。例如，当硬盘控制器准备好将一批数据写入内存，或者从内存读取一批数据时，就会向CPU发出DMA请求。

- CPU响应DMA请求的时机相对灵活。它可以在当前机器周期完成后，将系统总线的控制权交给DMA控制器。在整个数据传输过程中，CPU不需要逐字节地参与数据传输，只要在传输开始和结束阶段进行一些必要的协调。

- 例如，在数据传输期间，CPU可以去执行其他与该数据传输不冲突的任务，如进行内部运算、处理其他设备的一些简单请求等。

- **中断驱动方法**

- 中断请求是在外部设备完成某个特定操作或者出现需要CPU立即处理的事件时发出。比如，当打印机打印完一行字符，或者键盘有按键按下时，相应的设备就会发出中断请求。

- CPU必须在当前指令执行完毕后，立即检查是否有中断请求。如果有中断请求且满足响应条件（如中断优先级高于当前任务的优先级等），CPU就会暂停当前程序的执行，转而处理中断。这种响应是比较及时的，因为中断往往代表着一些需要紧急处理的事件，如实时性要求较高的设备输入输出操作。

**(2) CPU确认请求后的工作差异**

- **DMA（直接内存访问）方法**

- 当CPU确认DMA请求后，它主要做的工作是将系统总线的控制权交给DMA控制器。这包括让出数据总线、地址总线和控制总线的控制权。

- CPU然后可以继续执行其他任务，只要这些任务不涉及正在被DMA传输操作的内存区域和相关的I/O设备。例如，在DMA传输期间，CPU可以执行一些内部的数据处理任务，或者对其他未参与DMA传输的设备进行简单的管理操作。

- 当DMA传输完成后，DMA控制器会向CPU发出一个传输完成的信号，CPU这时可能需要对传输结果进行一些后续处理，比如检查数据传输是否正确等。

- **中断驱动方法**

- CPU在确认中断请求后，首先要保存当前程序的上下文，包括程序计数器（PC）的值、各个寄存器的内容等。这些信息被保存到特定的栈或者内存区域，以便在中断处理完成后能够恢复原来程序的执行。

- 然后，CPU根据中断源确定要执行的中断服务程序（ISR）。中断服务程序是专门用于处理该中断事件的一段程序代码。例如，对于键盘中断，中断服务程序可能会读取键盘缓冲区中的按键码，并将其转换为对应的字符或命令，然后进行相应的处理，如将字符显示在屏幕上或者将命令传递给应用程序。

- 在执行完中断服务程序后，CPU要恢复之前保存的程序上下文，然后继续执行被中断的程序，就好像中断没有发生过一样。



### For a write operation in a cache memory system, what is the difference between write back and write through? 

**Solution:**

**写直达（Write-through）**：缓存位置和主存位置同时更新。这样可以确保缓存和主存始终保持一致。但是所有的写操作都需要访问主存，这会导致系统速度变慢。

**写回（Write-back）**：仅更新缓存位置，并通过脏位（dirty bit）标记该位置已被修改。当包含被标记的字的块从缓存中移除时，才更新主存中的该字位置。相比写直达，写回更快，因为不会花费时间访问主存，且写入块内多个字只需要一次主存写操作。但主存的部分数据可能变得无效，并且缓存中需要额外的位来表示哪个块已经被修改。