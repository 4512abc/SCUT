# 简答题

**总结：数据库所拥有的相关部分**

- 相互关联的数据集合
- 用于访问数据的程序集合
- 便捷且高效的使用环境



文件系统作为数据库的缺点

- 数据冗余与不一致性
- 数据访问困难
- 数据隔离
- 完整性问题
- 更新的原子性
- 并发访问
- 安全问题



数据库的抽象层次

- 物理层：**描述记录的存储方式**

- 逻辑层：描述数据库中**存储的数据及其相互关系**

- 视图层：应用程序，**其隐藏了数据类型的细节**，为保障安全性，视图层还可以隐藏部分信息

- 架构图：

  ![image-20251119161150546](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251119161150546.png)



- Schema：数据库的逻辑结构
  - **Physical schema**: database design at the physical level
  - **Logical schema**: database design at the logical level
- Instance：特定时间点下，数据库的实际内容
- 类比：Schema 和 Instance 的关系，类似 Type 和 Variables
- Physical Data Independence：修改物理模式而无需更改逻辑模式的能力
  - 实现了多个模式的相互隔离
  - 各个层次的模式接口明确定义



数据模型：用于描述以下内容的工具集合

- 数据
- 数据关系
- 数据语义
- 数据约束



分类：

- 关系模型
- E-R模型：用于数据库设计
- 基于对象的数据模型
- XML模型
- 网状模型
- 层次模型



SQL：广泛使用的非过程化DML

应用程序访问数据库的方式：

1. 使用支持 **嵌入式SQL 的语言扩展**
2. 支持将**SQL查询**发送至数据库的 **应用程序接口**



Data Definition Language：用于定义数据库模式的规范表示法

==过程（？）：写一组DDL语言，DDL编译器将生成一组表模板，存储在数据字典中==

数据字典：可以理解为数据的蓝图，包含了数据的相关信息

- 数据库模型
- 完整性约束
  - 主键
  - 参照完整性
- 授权



设计数据库总体结构的过程：

- 逻辑设计：确定数据库模型
  - 目标：找到优质的关系模式集合
  - 角度：
    - 业务决策：哪些属性？
    - 计算机决策：采用哪些关系模式？属性如何在各模式间分配？
- 物理设计：决定数据库的物理布局（分布）



存储管理器：负责提供数据库中**存储的底层数据**与应用程序及提交给**系统的查询之间的接口**

任务：

- 与文件管理器进行交互
- 高效存储、检索、更新数据

问题：

- 存储方法
- 文件组织
- 索引和哈希



过程

1. Parsing and translation（解析与转换）
2. Optimization（优化）
3. Evaluation（执行）
   - 多种方法
     - 等价表达式
     - 不同算法

目的：

1. 优化的好坏，对执行方式的成本消耗差距极大
2. 需要估算操作成本
   - 依赖于数据库必须维护的关系 **的相关统计信息**
   - 需要**估算中间结果的统计信息**，从而**计算复杂表达式的成本**



事务：数据库应用中**执行单一逻辑功能的一系列操作集合**。**事务是程序执行的一个单元**，它会访问并可能更新多个数据项。

事务管理组件确保数据库**在系统故障（如电源故障、操作系统崩溃）和事务故障时仍保持一致（正确）状态**

并发控制管理器**控制并发事务间的交互，确保数据库一致性**



数据库架构：受底层计算机系统的影响

- 集中式
- 客户端-服务器模式
- 并行模式
- 分布式



数据库是有多个关系组成的

设计糟糕的设计库可能会出现如下问题：

- 信息重复
- 使用 null 值



关系查询语言

- 分类：过程化与非过程化
- 纯语言
  - 关系代数
  - 元组关系计算
  - 域关系计算
- 关系运算符



## E-R设计决策要点

1. 用属性还是实体集表示对象。
2. 现实世界概念用实体集还是关系集表示。
3. 用三元关系还是多个二元关系表示关联。
4. 用强实体集还是弱实体集。
5. 是否使用特化/泛化（提升设计模块化）。
6. 是否使用聚合（将关系视为抽象实体，简化复杂关联）。



### 磁盘块访问优化

1. 块（Block）：单个磁道上**连续的扇区序列**，是**内存与磁盘之间数据传输的最小单位**，1个块包含**多个连续扇区**，大小通常为**512Byte到数KB**（当前典型块大小为4-16 KB）。
   - 小块：磁盘传输次数增多。
   - 大块：部分填充的块会造成空间浪费。
2. 文件组织（File Organization）：通过**合理组织块的存储位置**，**优化块访问时间**（如将**相关数据存储在同一或相邻柱面**）。
3. 文件碎片（Fragmentation）：
   - 成因：文件插入/删除操作、磁盘空闲块分散导致新建文件的块**分散存储**。
   - 影响：顺序访问碎片文件会**增加磁头臂移动次数，降低效率**。
   - 解决方案：使用**文件系统碎片整理工具，重组文件块以加速访问**。



### 索引更新（Index Update）

**1. 删除（Deletion）**

- 稠密索引：类似文件记录删除，**直接移除对应索引条目**。
- 稀疏索引：若待删除的搜索键**存在索引条目**，**用文件中该键的下一个搜索键值替换（若下一个键已有索引条目，则直接删除原条目）**。（原来最小的已经被删除了，选择新的最小，就是下一个搜索键）



**2. 插入（Insertion）**

- 稠密索引：若插入的搜索键值**不在索引中，新增索引条目。**

- 稀疏索引：**仅当插入操作创建新数据块时，将新块的最小搜索键值插入索引。**（没有创建新块的话，插入的位置）

  由于稀疏索引的索引项通常是**数据块的首记录键值**（或固定间隔的记录键值），插入 / 删除时的核心原则是：

  - 若操作**不改变数据块的首记录键值** → **仅修改数据文件**，**无需修改**稀疏索引；
  - 若操作**改变了**数据块的首记录键值 → 必须**同步更新稀疏索引**的对应索引项。

- 多级索引更新：是单级索引更新逻辑的简单扩展。



### 辅助索引的特点

**适用场景**：需通过非排序属性查找记录，例如：

- 查找特定部门的所有教师（instructor表的dept_name属性）。
- 查找特定薪水或薪水范围的所有教师（instructor表的salary属性）。

**结构特点**

- 必须是**稠密索引**，每个搜索键值对应一条索引记录。
- 索引记录指向一个“桶”，桶中存储**所有该搜索键值**对应的**记录的指针**。

**优缺点**

- **优势：大幅提升非排序属性的查询效率。**
- 劣势：
  - 维护开销高：**文件修改时，所有相关辅助索引都需更新。**
  - 顺序扫描低效：通过辅助索引进行全表扫描时，可能频繁读取不同磁盘块（磁盘I/O开销远高于内存访问）。



## B+树索引文件（B+-Tree Index Files）

**背景**：

- 索引顺序文件的性能会随文件增长下降（产生大量溢出块），需定期重组；
- 而B+树索引可通过**局部小幅调整**自动维护性能，**无需全文件重组**。



**优缺点**

- 优势：**插入/删除时自动局部重组，维持查询效率**；广泛应用于数据库系统。
- 劣势：相比索引顺序文件，**插入/删除有额外开销，占用更多存储空间**。



## B+树索引文件（B+-Tree Index Files）

**背景**：

- 索引顺序文件的性能会随文件增长下降（产生大量溢出块），需定期重组；
- 而B+树索引可通过**局部小幅调整**自动维护性能，**无需全文件重组**。



**优缺点**

- 优势：**插入/删除时自动局部重组，维持查询效率**；广泛应用于数据库系统。
- 劣势：相比索引顺序文件，**插入/删除有额外开销，占用更多存储空间**。



**结构特性**

![image-20251223115333788](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223115333788.png)

B+树是一棵有根树，满足以下规则：

1. 根到叶子节点的所有路径长度相同。
2. 内部节点（非根、非叶子）：有$[\lceil n/2\rceil, n]$个子节点（ $n$ 为节点最大子节点数，一般称为 order n）。
3. 叶子节点：有$[\lceil(n-1)/2\rceil, n-1]$个搜索键值。一般说叶子节点有多少个，指的是搜索键值。
4. 根节点：若为非叶子节点，至少有2个子节点；若为叶子节点，可包含0到 $n-1$ 个键值。



### 节点结构

**通用结构**

- 包含搜索键值$K_1<K_2<...<K_{n-1}$，以及指针$P_1,P_2,...P_n$

- 非叶子节点：$P_i$为子节点指针。

  - 形成多级稀疏索引，引导查找路径。
  - 每个非叶子节点的键值用于划分子节点的搜索键范围。

  $$
  P_1 < K_1 \leq P_2 < K_2 \leq P_3 < K_3 \leq ... < P_{n-1} < K_{n-1} \leq P_n
  $$

- 叶子节点：$P_i$为记录或记录桶的指针。

  - **叶子节点按搜索键值排序，**通过指针 $P_n$ 链接成有序链表（便于范围查询）。
  - 存储记录指针（B+树索引）或直接存储记录（B+树文件组织）。

  $$
  P_1 = K_1 < P_2 = K_2 < P_3 = K_3 < ... < P_{n-1} = K_{n-1} < P_n
  $$

  

### B+树的关键观察

1. **逻辑相邻的块（搜索键值相近）无需物理相邻（通过指针连接）。**

   ![image-20251223115507644](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223115507644.png)

2. 树的高度低：若 $n=100$（每个索引条目40字节，节点大小4KB），100万条搜索键的B+树高度仅为 $\lceil log_{50}(10^6)\rceil=4$ ，查找时仅需访问4个节点（磁盘I/O开销低）。

   总结：如果文件中有 $m$ 个搜索键，则树的高度不超过 $\lceil log_{\lceil\frac{n}{2} \rceil}(m) \rceil$。

3. **插入/删除效率高：可在对数时间内完成索引重组。**



### B+树查询流程（Queries on B+-Trees）

1. 从根节点开始，判断当前节点是否为叶子节点。
2. 非叶子节点：找到首个**大于等于**目标键 $V$ 的 $K_i$（即 $V \leq K_i$），按规则选择子节点指针（ $V=K_i$选 $P_{i+1}$，$V<K_i$ 选 $P_i$，无 $K_i$ 选最后一个非空指针），递归访问子节点。
3. 叶子节点：查找等于 $V$ 的 $K_i$ ，若存在则通过对应 $P_i$ 访问记录；否则无匹配记录。



### B+树文件组织（B+-Tree File Organization）

- B+树索引：可以解决索引文件性能下降问题

- B+树文件组织：可以解决 数据文件 性能下降问题

- 核心差异：

  - 叶子节点（B+树文件组织）直接存储记录（而非指针），
    - 仍需满足“半满”要求（因记录比指针占用空间大，叶子节点最大记录数少于非叶子节点最大指针数）。

  - 数据库中**绝大多数 B + 树是 “索引”**，叶子节点存指针；仅当 B + 树直接作为**数据文件的存储结构**时，叶子节点才存完整记录

- 优化：为了**提升**空间利用率，**分裂或合并**节点期间，可**涉及多个兄弟节点进行重新分配**。
  - e.g：涉及两个兄弟节点进行重新分配，节点至少包含$2n/3$条记录。



## 有序索引与散列的比较（Comparison of Ordered Indexing and Hashing）

| 对比维度      | 有序索引                                                     | 散列                                     |
| ------------- | ------------------------------------------------------------ | ---------------------------------------- |
| 等值查找      | 效率较高                                                     | 效率更高                                 |
| 范围查找      | 支持且高效                                                   | 不支持（需全表扫描）                     |
| 文件重组      | 索引顺序文件需定期重组，B+树无需                             | 静态散列需定期重组，动态散列无需         |
| 插入/删除开销 | B+树有一定开销                                               | **静态散列开销低，动态散列有一定开销**   |
| 数据库支持    | 主流数据库（Oracle、SQL Server、PostgreSQL）均支持（B+树为主） | PostgreSQL支持但不推荐，Oracle等支持有限 |



## SQL中的索引定义（Index Definition in SQL）

**创建索引**

```sql
create index <索引名> on <关系名> (<属性列表>);
```

- 示例：为instructor表的dept_name属性创建索引  
  `create index dept_index on instructor (dept_name);`
- 唯一索引：`create unique index`，间接强制**搜索键为候选键**（与SQL的unique约束功能重叠）。

**删除索引**

```sql
drop index <索引名>;
```

**扩展功能**

多数数据库支持指定索引类型（如B+树、散列）和聚集属性（是否为聚集索引）。





## 数据字典存储（Data-Dictionary Storage）

数据字典（又称系统目录）存储元数据（metadata），即“关于数据的数据”。

### 存储内容

1. 关系相关信息：
   - 关系名称
   - 属性名称及类型。
   - 视图名称及定义。
   - 完整性约束。
2. 用户与计费信息（如用户名、加密密码）。
3. 统计描述数据（如每个关系的元组数量）。
4. 物理文件组织信息：
   - 关系的**存储方式**（顺序/哈希/堆）。
   - 关系的**物理存储位置**。
5. 索引相关信息（详见第11章）。



### 2.4 等价表达式的枚举

- 基本方法：查询优化器利用**等价规则**，系统地生成与给定表达式等价的所有表达式
  - 重复：对已找到的**每个等价表达式**的所有**子表达式**应用**所有适用的等价规则**，将新生成的表达式加入等价表达式集合
  - 终止：无新的等价表达式生成
- 问题：上述方法时空开销极大
- 优化方案：
  1. 基于**转换规则**的优化计划生成
  2. 针对**仅含选择、投影和连接**的查询的特殊处理方法
  3. 共享公共子表达式（通过指针共享相同子树，减少空间占用）
  4. 动态规划（避免生成所有表达式，降低时间开销）



## 4. 评估计划的选择

### 4.1 评估技术的相互影响

- 独立选择**每个操作的最优算法未必能得到整体最优算法**
  - 示例1：归并连接可能比哈希连接成本高，但能提供排序后的输出，降低外层聚合操作的成本
  - 示例2：嵌套循环连接可支持流水线执行，减少磁盘I/O
- 实际查询优化器的两种核心方法：
  1. **搜索所有可能的计划**，**基于成本选择最优计划**
  2. 利用**启发式规则**选择计划



### 4.2 基于成本的优化

#### 4.2.1 连接顺序优化的复杂度

- $n$ 个关系的连接顺序数量：$(2(n-1))!/(n-1)!$
  - $n=7$ 时，数量为665280
  - $n=10$ 时，数量超过1760亿
- 优化方法：动态规划，仅计算并存储$\{r_1, r_2, ..., r_n\}$ 的每个子集的最优连接顺序，避免重复计算



#### 4.2.2 连接顺序优化算法

- 数据结构：

  ```
  structure bestplan {
      cost;  
      plan;  
  };
  
  bestplan[S].plan	// 连接集合S中所有关系的最优计划
  bestplan[S].cost    // 最优计划的成本
  ```

- 算法步骤：

  1. 过程 `findbestplan(S)`：
     - 若`bestplan[S].cost`已计算（非无穷大），返回`bestplan[S]`
     - 若S仅包含一个关系：基于该关系的选择条件和索引，设置 `bestplan[S].plan` 和`bestplan[S].cost`
     - 否则，对 S 的每个非空真子集 S ：
       - `P1 = findbestplan(S1)`
       - `P2 = findbestplan(S - S1)`
       - `A = 连接 P1 和 P2 结果的最优算法`
       - 计算总成本 = `P1.cost + P2.cost + A的成本`
       - 若总成本小于当前 `bestplan[S].cost`，更新`bestplan[S].cost`和`bestplan[S].plan`
     - 返回`bestplan[S]`



#### 4.2.3 优化的成本

- 动态规划的时间复杂度：$O(3^n)$
  - $n=10$时，计算量约为59000（远低于1760亿）
- 空间复杂度：$O(2^n)$



### 4.3 左深连接树

- 定义：每个连接的右输入是一个关系，而非中间连接的结果

  ![image-20251218194217528](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251218194217528.png)

- 优化算法修改：

  - 将"遍历 $S$ 的所有非空真子集 $S_i$"改为"遍历 $S$ 中的每个关系 $r$，令$S_i = S - r$"

- 复杂度：

  - 时间复杂度：$O(n\times 2^ⁿ)$
  - 空间复杂度：$O(2^n)$

- 适用场景：典型查询的关系数量 $n$ 较小（通常<10），基于成本的优化虽有开销但值得



### 4.4 启发式优化

- 适用场景：降低**基于成本优化的开销**
- 核心规则（通常能提升执行性能，但非绝对）：
  1. **尽早执行选择操作**（减少元组数量）
  2. **尽早执行投影操作**（减少属性数量）
  3. 先执行**限制性最强的选择和连接**操作（即**结果集最小的操作**）
- 实际应用：部分系统仅使用启发式优化，部分系统结合启发式优化与部分基于成本的优化



## ACID特性

**为保证数据完整性**，数据库系统必须确保事务满足ACID特性：

### 原子性（Atomicity）

事务的**所有操作要么全部正确反映到数据库中，要么全部不反映**。

### 一致性（Consistency）

事务隔离执行时，会保持数据库的一致性。

### 隔离性（Isolation）

多个事务并发执行时，**每个事务都应感觉不到其他事务的存在，中间结果需对其他事务隐藏。**

### 持久性（Durability）

事务成功完成后，其**对数据库的修改必须永久保留，即使发生系统故障**。





## 并发执行（Concurrent Executions）

### 并发执行的优势

1. **提高处理器和磁盘利用率**，提升事务吞吐量（如一个事务使用CPU时，另一个事务读写磁盘）。
2. **减少事务平均响应时间**（短事务无需等待长事务完成）。



### 并发控制方案（Concurrency Control Schemes）

用于**实现隔离性和一致性，控制并发事务间的交互，避免破坏数据库一致性**。



## 调度（Schedules）

调度是指定**并发事务指令执行 chronological（按时间排序） 顺序**的指令序列。

### 调度的要求

1. 包含**所有参与事务**的**全部指令**。
2. 保留**每个事务内部指令的原有顺序**。

### 事务的结束指令

1. 成功完成的事务：最后一条语句为**提交指令（默认隐含）**。
2. 执行失败的事务：最后一条语句为**中止指令**。



## 可串行化（Serializability）

### 基本假设

每个**单独执行的事务**都能**保持数据库一致性**，因此**串行执行一组事务也能保持一致性**。

### 定义

**若一个（可能并发的）调度等价于某个串行调度，则称该调度是可串行化的**。最核心的类型是冲突可串行化（conflict serializability）。

### 简化假设

仅关注事务的读写指令，忽略其他计算操作（假设事务可在本地缓冲区中对数据进行任意计算）。

## 冲突指令（Conflicting Instructions）

### 冲突条件

**事务T的指令t和事务F的指令f冲突，当且仅当：**

1. **两者访问同一个数据项Q；**
2. **至少有一个指令是写操作（write(Q)）。**

### 冲突情况示例

1. t=read(Q)，f=read(Q)：不冲突；
2. t=read(Q)，f=write(Q)：冲突；
3. t=write(Q)，f=read(Q)：冲突；
4. t=write(Q)，f=write(Q)：冲突。

### 无冲突指令的交换性

若调度中两条**连续**指令**不冲突**，则交换它们的顺序后，调度结果不变。



## 冲突可串行化（Conflict Serializability）

### 定义

若调度S**可通过一系列无冲突指令的交换，转换为串行调度S2**，则称S与S2冲突等价；若S冲突等价于某个串行调度，则S是冲突可串行化的。



## 可串行化测试（Testing for Serializability）

### 优先级图（Precedence Graph）

1. 顶点：参与调度的各个事务。
2. 边：若满足以下任一条件，绘制边T1→T2：
   - T1执行write(Q)后，T2执行read(Q)；
   - T1执行read(Q)后，T2执行write(Q)；
   - T1执行write(Q)后，T2执行write(Q)。

### 判定定理

一个调度是冲突可串行化的，当且仅当其优先级图是无环的。

### 测试步骤

![image-20251222172604730](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251222172604730.png)

1. 构建调度的优先级图；
2. 检测图中是否存在环（环检测算法时间复杂度为O(n²)，优化算法为O(n+e)，n为顶点数，e为边数）；
3. 若无环，可通过拓扑排序得到串行化顺序（拓扑排序结果为与优先级图一致的线性顺序）。



## 可恢复调度（Recoverable Schedules）

### 定义

若事务T读取了事务F修改的数据项Q（即T的read(Q)与F的write(Q)冲突，即 F 先操作，T 后操作），**且F先提交后T才提交，则该调度是可恢复的**。（简单说，先做，先交）

### 非可恢复调度示例

事务T8执行write(A)后，事务T9执行read(A)并立即提交，若后续T8中止，T9已读取不一致的数据并可能对外输出，导致数据库状态不可恢复。

### 核心要求

数据库必须确保**所有调度都是可恢复的，以应对事务失败的影响**。



## 级联回滚（Cascading Rollbacks）

### 定义

单个事务失败导致一系列事务回滚。

- 示例：事务T10执行write(A)后，T11读取A并执行write(A)，T12读取A，若T10中止，T11和T12必须**同时回滚以保持一致性，但会撤销大量已完成工作**。

![image-20251129122323049](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251129122323049.png)

## 无级联调度（Cascadeless Schedules）

### 定义

**不会发生级联回滚的调度，要求：对于冲突的事务对{T,F}，F先执行write(Q)并提交后，T再执行read(Q)并提交。**

- 核心规则：不允许读取未提交的数据，**仅能读取已提交的数据**。
- 特性：所有无级联调度**都是可恢复的，是更优的调度类型**。



| 调度类型   | 核心要求                  | 故障恢复难度         | 并发效率 |
| ---------- | ------------------------- | -------------------- | -------- |
| 可恢复调度 | 依赖事务先提交            | 中等（可能级联回滚） | 高       |
| 无级联调度 | 禁止脏读，依赖事务先提交  | 低（无关联回滚）     | 中       |
| 严格调度   | 禁止脏读+禁止写未提交数据 | 极低                 | 低       |



## 并发控制（Concurrency Control）

### 调度的核心要求

1. **冲突可串行化或视图可串行化（保证隔离性）；**
2. **可恢复（保证一致性）；**
3. **优选无级联（降低回滚开销）。**



### 并发控制协议的目标

开发并发控制协议，**确保调度满足上述要求**，而非事后检测可串行性。



### 权衡关系

并发控制协议需在允许的并发度和自身开销之间权衡：

1. 仅允许串行执行事务：开销低，但并发度极差；
2. 部分协议仅允许冲突可串行化调度，部分允许非冲突可串行化的视图可串行化调度。



## 基于锁的协议（Lock-Based Protocols）

### 锁的定义与作用

锁是**控制数据项并发访问**的机制：通过**限制事务对数据项的操作权限，避免并发冲突**。

### ==锁的两种模式==

1. **排他锁（Exclusive, X 锁）**：允许事务对数据项进行读写操作，通过 `lock-X` 指令请求。
2. **共享锁（Shared, S 锁）**：仅允许事务对数据项进行读操作，通过 `lock-S` 指令请求。

### 锁兼容性矩阵

| 请求锁\持有锁 | S 锁            | X 锁            |
| ------------- | --------------- | --------------- |
| S 锁          | 兼容（true）    | 不兼容（false） |
| X 锁          | 不兼容（false） | 不兼容（false） |

- 规则：仅当**请求锁**与数据项上**已持有的其他锁兼容**时，并发控制管理器**才授予该锁**；若**不兼容**，**请求事务需等待**，直至**所有不兼容锁**被释放。



## 两阶段锁协议（Two-Phase Locking Protocol）

### 核心规则

通过将事务的加锁、解锁过程分为两个阶段，确保冲突可串行化：

1. **增长阶段（Growing Phase）**：事务可获取锁，但不能释放锁。
2. **收缩阶段（Shrinking Phase）**：事务可释放锁，但不能获取锁。

### 特性

1. **优点**：**严格保证冲突可串行化**（通过**锁的冲突机制**，==强制并发事务的冲突操作按 “先加锁者优先” 的顺序执行，等价于构造了一个串行执行的顺序==。），事务可按“锁点”（获取最后一个锁的时刻）排序。
2. **缺点**：
   - **仍可能发生死锁。**
   - **可能出现级联回滚。**





### 改进版本

#### 1. 严格两阶段锁（Strict Two-Phase Locking）

- 规则：事务**需持有所有排他锁（X 锁）直至提交或中止**。
- 作用：**避免级联回滚，确保未提交事务的写操作不会被其他事务读取**。
- 示例：T3 需在 `commit` 后，再执行 `unlock(B)→unlock(A)`。

#### 2. 强两阶段锁（Rigorous Two-Phase Locking）

- 规则：事务需**持有所有锁（S 锁和 X 锁）直至提交或中止**。
- 作用：进一步增强隔离性，**事务可按提交顺序串行化，但并发度最低**。
- 示例：T4 需在 `commit` 后，再执行 `unlock(B)→unlock(A)`。

### 锁转换（Lock Conversions）

两阶段锁协议**支持锁转换，减少锁竞争开销**：

1. **增长阶段**：
   - 可直接获取 S 锁或 X 锁。
   - 可将 S 锁升级（upgrade）为 X 锁。
2. **收缩阶段**：
   - 可释放 S 锁或 X 锁。
   - 可将 X 锁降级（downgrade）为 S 锁。

- 优势：避免**“释放 - 重获”锁过程中的死锁窗口期**。（避免发生死锁）
- 局限：**增加锁管理的复杂性**。



## 锁的自动获取与释放

### 读操作（read(D)）的处理逻辑

1. 若事务已持有 D 的 S 锁，直接执行读操作。（暗示兼容）
2. 否则：
   - **等待直至 D 上无其他事务的 X 锁。**
   - **授予事务 D 的 S 锁，执行读操作。**

### 写操作（write(D)）的处理逻辑

1. 若事务已持有 D 的 X 锁，直接执行写操作。（暗示兼容）
2. 否则：
   - **等待直至 D 上无其他事务的任何锁。**
   - 若事务已持有 D 的 S 锁，将其升级为 X 锁；否则直接授予 X 锁。
   - 执行写操作。

所有锁在事务提交或中止后自动释放。





### 核心思想

对所有数据项定义偏序关系（`→`），事务访问数据项时需遵循该顺序（若 `di→dj`，则事务访问 dj 前必须先访问 di）。数据项集合可视为**有向无环图**（数据库图），树协议是最典型的基于图的协议。

### 树协议（Tree Protocol）

#### 规则

1. 仅**支持排他锁**（X 锁）。
2. 事务的**第一个锁可加在任意数据项上。**
3. 后续加锁的 data Q 需满足：Q 的**父节点当前已被该事务锁定。**（强制**所有事务的加锁顺序一致**，避免 “循环等待”（死锁的必要条件之一））
4. **数据项可随时解锁。**（优势：相比 2PL，锁的**持有时间更短，并发度更高**）
5. **事务解锁后，不能再重新锁定该数据项。**（防止事务**重复加锁导致的锁竞争**，进一步规避死锁）

#### 特性

| 特性         | 说明                             |
| ------------ | -------------------------------- |
| 冲突可串行化 | 是                               |
| 无死锁       | 是（严格的访问顺序避免循环等待） |
| 可恢复性     | 否                               |
| 无级联       | 否                               |
| 并发度       | 高于两阶段锁协议（可提前解锁）   |
| 锁开销       | 可能更高（需锁定未访问的父节点） |

## 各协议特性对比

| 协议                                         | 冲突可串行化 | 无死锁 | 可恢复性 | 无级联 |
| -------------------------------------------- | ------------ | ------ | -------- | ------ |
| 两阶段锁协议（Two-Phase Locking）            | 是           | 否     | 否       | 否     |
| 严格两阶段锁协议（Strict Two-Phase Locking） | 是           | 否     | 是       | 是     |
| 强两阶段锁协议（Rigorous Two-Phase Locking） | 是           | 否     | 是       | 是     |
| 树协议（Tree Protocol）                      | 是           | 是     | 否       | 否     |







## 事务状态

1. **活动状态（Active）**：初始状态，事务正在执行中。
2. **部分提交状态（Partially Committed）**：==事务执行完最后一条语句，但修改尚未写入稳定存储。==
3. **失败状态（Failed）**：发现无法继续正常执行（如故障或逻辑错误）。
4. **中止状态（Aborted）**：事务回滚后，数据库**恢复到事务开始前的状态**。
   - 后续操作：
     1. 重启事务（仅当**无内部逻辑错误**时）；
     2. 终止事务。
5. **提交状态（Committed）**：事务成功完成，其提交日志记录已写入稳定存储。

### 状态流转

![image-20251129114159137](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251129114159137.png)



## 1. 引言

- 评估==给定查询的多种替代方式==
  - 等价表达式
  - 同一操作可采用不同算法
- 评估计划：明确**每个操作所用算法**及操作执行的**协调方式**
- 评估计划的成本差异：不同计划的执行成本可能极为悬殊（例如：几秒 vs. 几天）
- 基于成本的查询优化步骤：
  1. 利用==等价规则==生成==逻辑等价表达式==
  2. 为结果表达式**添加注解**，得到**替代查询计划**（Annotate resultant expressions to get alternative query plans）
  3. 基于**估算成本**选择最优计划
- 计划成本估算依据：
  1. **关系**的统计信息（如元组数量、属性的不同值数量等）
  2. **中间结果**的统计信息估算（用于计算复杂表达式的成本）
  3. 利用统计信息计算的**算法成本公式**
