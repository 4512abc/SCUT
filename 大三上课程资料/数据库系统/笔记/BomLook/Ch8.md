# Ch8

## 章节概述
良好关系设计的特性、原子域与第一范式、基于函数依赖的分解、函数依赖理论、函数依赖的算法、基于多值依赖的分解、更高范式、数据库设计流程

## 模式合并与分解的核心问题
### 模式合并的冗余问题
若将`instructor`（教师）和`department`（部门）合并为`inst_dept`模式，会导致信息重复（如同一部门的`building`（办公楼）和`budget`（预算）在多名教师的记录中重复存储）。

### 无冗余合并的情况
将`sec_class(sec_id, building, room_number)`（班级-教室）和`section(course_id, sec_id, semester, year)`（班级）合并为`section(course_id, sec_id, semester, year, building, room_number)`，无信息重复（`building`和`room_number`与`sec_id`一一对应，无冗余）。

### 模式分解的判断依据
若从`inst_dept`模式拆分出`instructor`和`department`，核心依据是**函数依赖**：`dept_name → building, budget`（部门名称决定办公楼和预算）。由于`dept_name`（部门名称）不是`inst_dept`的超码，导致信息重复，因此需要分解。

### 有损分解与无损连接分解
1. **有损分解（Lossy Decomposition）**：分解后**无法还原原始关系**。
   - 示例：将`employee(ID, name, street, city, salary)`分解为`employee1(ID, name)`和`employee2(name, street, city, salary)`。若存在同名员工，合并后会产生错误关联，无法还原原始记录。
2. **无损连接分解（Lossless-Join Decomposition）**：分解后**通过自然连接可还原原始关系**。
   - 示例：将`R(A, B, C)`分解为`R1(A, B)`和`R2(B, C)`，因`R1∩R2 = {B}`且`B→C`，自然连接后可完全还原`R`。

## 关系设计的核心目标
设计理论需解决以下问题：
1. 判断一个关系模式是否为“良好形式”（无冗余、无异常，**异常指的是操作异常，包括了插入异常、删除异常、更新异常**）。
2. 若模式不佳，将其分解为一组满足以下条件的模式：
   - 每个模式均为良好形式。
   - 分解为无损连接分解。
   - **优选保持依赖的分解**。
3. 核心理论基础：函数依赖（重点）、多值依赖（了解）。

### “良好形式”与分解的权衡
- “良好形式”：无冗余，通过BCNF分解实现。
- 好的分解：需满足无损连接、保持依赖。
- 权衡：BCNF分解无法100%保证保持依赖，3NF分解可保证保持依赖但允许少量冗余，需在二者间平衡。

## 第一范式（First Normal Form）
### 原子域（Atomic Domain）
域的元素被视为不可分割的单元。非原子域示例：集合类型、复合属性、可拆分的标识号（如`CS101`可拆分为`CS`和`101`）。

### 第一范式定义
若关系模式`R`的**所有属性的域均为原子域**，则`R`属于第一范式。非原子值会增加存储复杂度，且**容易导致数据冗余**。

### 原子性的实际考量
原子性取决于域的使用方式：
- 字符串通常视为原子值，但若从学号`SE0012`中提取前两位`SE`表示部门，则学号的域不再是原子域（这种设计不推荐，会导致信息编码依赖应用程序，而非数据库本身）。

## 函数依赖（Functional Dependencies）
### 定义
函数依赖是对合法关系的约束，指**一组属性的值可唯一确定另一组属性的值**，是键概念的推广。
- 形式化表示：设`R=(A1, A2, …, An)`为关系模式，`α⊆R`，`β⊆R`，若对`R`的任意合法关系`r`，任意两个元组`t1`和`t2`满足`t1[α] = t2[α]`，则`t1[β] = t2[β]`，记为`α→β`（`α`函数决定`β`）。
- 等价表述：`α`是模式`(α, β)`的超码。

### 示例
- 关系`r(A, B)`的实例为`{(1,5), (1,4), (3,7)}`，则`A→B`不成立（无唯一对应关系），但`B→A`成立（每个`B`值对应唯一`A`值）。
- `inst_dept`模式中，`dept_name→building, budget`（部门名称决定办公楼和预算）、`ID→salary`（教师ID决定薪水）成立，但`dept_name→salary`（部门名称决定薪水）不成立。

### 平凡与非平凡函数依赖
- 平凡函数依赖：`α→β`且`β⊆α`（如`ID, name→ID`、`name→name`），所有关系都满足，无实际约束意义。
- 非平凡函数依赖：`β⊈α`（如`dept_name→building`），是数据库设计中需关注的核心约束。

### 函数依赖的作用
1. 检验关系是否合法（判断关系实例是否满足给定的函数依赖集）。
2. 定义关系的合法实例集（所有满足函数依赖集`F`的关系称为`F`在`R`上成立）。
- 注意：某一关系实例可能偶然满足某函数依赖，但**该依赖未必在所有合法实例中成立**（如某`instructor`实例中`name→ID`偶然成立，但并非普遍约束）。

> 函数依赖（Functional Dependency，FD）是**数据库规范化理论的核心基础**，核心作用是**精准描述属性间的关联关系**，进而帮我们设计“无冗余、无异常”的良好关系模式，具体作用可概括为3点，简单易懂：
>
> 1.  **判断关系模式是否“规范”（核心作用）**  
>     函数依赖是划分1NF、2NF、3NF、BCNF等规范化等级的**唯一依据**：  
>     - 2NF要求消除“部分函数依赖”（非主键属性只依赖主键的一部分）；  
>     - 3NF要求消除“传递函数依赖”（非主键属性依赖另一个非主键属性）；  
>     - BCNF要求所有函数依赖的左部都是候选键。  
>     简单说，通过识别函数依赖，能快速发现模式中的冗余和异常（如更新异常），指导我们拆分表、优化结构。
>
> 2.  **消除数据冗余和操作异常**  
>     函数依赖清晰界定了“哪些属性是冗余的”——如果一个属性能通过其他属性（函数依赖）推导出来，它就是冗余的。  
>     例：员工表中，`员工号→部门号→部门名称`，“部门名称”可通过“部门号”推导（传递依赖），冗余存储会导致部门改名时需改所有员工记录（更新异常）。  
>     借助函数依赖，我们能精准拆分表（员工表+部门表），消除冗余和异常。
>
> 3.  **指导数据库设计（表结构、约束）**  
>     - 帮我们确定**主键/候选键**：能唯一决定所有其他属性的属性集，就是候选键（如`学号→姓名、年龄、专业`，学号就是候选键）；  
>     - 帮我们设计**完整性约束**：通过函数依赖可明确外键关联（如`订单表.用户号→用户表.用户号`），保证数据一致性；  
>     - 避免“无用属性”：删除无法通过函数依赖与主键关联的孤立属性，简化表结构。
>
> 一句话总结：函数依赖是“诊断”关系模式好坏的“工具”，通过它能找到冗余和异常的根源，进而设计出高效、可靠的数据库表结构。
>

## 范式：关系模式的“良好形式”标准
### BCNF（Boyce-Codd Normal Form）
#### 定义
若关系模式`R`对于函数依赖集`F`满足：对`F⁺`中所有函数依赖`α→β`（`α⊆R`，`β⊆R`），至少满足以下条件之一，则`R`属于BCNF：
1. `α⊇β`（平凡依赖）。
2. `α`是`R`的超码。

#### 示例（非BCNF模式）
`inst_dept(ID, name, salary, dept_name, building, budget)`：
- 函数依赖`dept_name→building, budget`成立，但`dept_name`不是`inst_dept`的超码，因此该模式不属于BCNF。

### 3NF（Third Normal Form）
#### 定义
若关系模式`R`对于函数依赖集`F`满足：对`F⁺`中所有函数依赖`α→β`，至少满足以下条件之一，则`R`属于3NF：
1. `α⊇β`（平凡依赖）。
2. `α`是`R`的超码。
3. `β−α`中的每个属性都包含在`R`的某个候选码中（允许非超码的`α`决定候选码属性）。

#### 与BCNF的关系
- BCNF是3NF的特例（满足BCNF的模式必满足3NF）。
- 3NF是BCNF的最小松弛，确保保持依赖（BCNF分解可能破坏依赖）。



> ### 核心概念回顾：函数依赖与键
>
> 在理解范式之前，必须明确两个概念：
> *   **函数依赖**：如果知道属性集 A 的值，就能唯一确定属性集 B 的值，则称 **B 函数依赖于 A**，记作 A → B。
>     *   例如：`学号 → 学生姓名`，`(学号, 课程号) → 成绩`。
> *   **候选键**：一个或多个属性的集合，它可以唯一标识整个元组，并且其任何真子集都不能唯一标识。一个表可能有多个候选键。
> *   **主属性**：包含在**任何一个候选键**中的属性。
> *   **非主属性**：不包含在任何候选键中的属性。
>
> ---
>
> ### 1. 第三范式
>
> **定义**：一个关系模式 R 满足第三范式，当且仅当对于 R 中的**每一个非平凡的函数依赖** X → Y，**至少满足以下一条**：
> 1.  **X 是超键**（即 X 包含某个候选键）。
> 2.  **Y 是主属性**（即 Y 是构成某个候选键的一部分）。
>
> 更直观、更常用的等价表述是：
> **3NF 要求所有非主属性都必须直接依赖于整个候选键，而不能传递依赖于候选键，也不能部分依赖于候选键**。
>
> **判断条件（检查每个非平凡函数依赖 X → A，其中 A 是单个属性）**：
> *   如果 A 是**主属性**，则这个依赖天然满足 3NF（符合上述第2条）。
> *   如果 A 是**非主属性**，则必须检查 X 是否是**超键**（即 X 必须包含某个候选键）。如果 X 不是超键，则违反 3NF。
>
> **违反 3NF 的典型例子（传递依赖）**：
> 关系模式：`学生选课(学号, 课程号, 成绩, 教师姓名, 教师职称)`
> *   候选键：`(学号, 课程号)`
> *   函数依赖：
>     1.  `(学号, 课程号) → 成绩`
>     2.  `(学号, 课程号) → 教师姓名`
>     3.  `教师姓名 → 教师职称` （这里产生了传递依赖）
> *   分析：
>     *   对于依赖 3：`教师姓名 → 教师职称`。
>     *   `教师姓名` 不是超键（仅凭教师姓名不能确定是哪个学生的哪门课）。
>     *   `教师职称` 是非主属性。
>     *   **结论**：存在一个非主属性`教师职称`传递依赖于候选键`(学号, 课程号)`，违反了 3NF。这会导致数据冗余（同一教师职称存储多次）和更新异常。
>
> ---
>
> ### 2. BCNF
>
> **定义**：一个关系模式 R 满足 BCNF，当且仅当对于 R 中的**每一个非平凡的函数依赖** X → Y，**X 都必须是超键**。
>
> **判断条件（检查每个非平凡函数依赖 X → A，其中 A 是单个属性）**：
> *   直接检查 **X** 是否是超键。如果不是，则违反 BCNF。
> *   **注意**：BCNF 的判断**不区分主属性和非主属性**，对所有依赖一视同仁，要求更严格。
>
> **BCNF 与 3NF 的关系**：
> *   **BCNF 比 3NF 更严格**。所有满足 BCNF 的关系模式必然满足 3NF。
> *   3NF 允许一种 BCNF 不允许的特殊情况：当函数依赖 `X → Y` 中，`X` 不是超键，但 `Y` 是主属性时，这满足 3NF 但违反 BCNF。
>
> **违反 BCNF 但满足 3NF 的经典例子**：
> 关系模式：`授课(学生, 教师, 课程)`，语义：一位教师只教一门课，但一门课可以由多位教师教；一个学生选定某门课后，就对应一位固定的教师。
> *   候选键：`(学生, 课程)` 和 `(学生, 教师)`。（两者都能唯一确定一条记录）
> *   函数依赖：
>     1.  `(学生, 课程) → 教师`
>     2.  `(学生, 教师) → 课程`
>     3.  `教师 → 课程` （关键依赖）
> *   分析：
>     *   所有属性都是主属性（都出现在候选键中），所以它**一定满足 3NF**（因为 3NF 对主属性构成的依赖没有限制）。
>     *   检查 BCNF：对于依赖 3 `教师 → 课程`。
>         *   `教师` 是超键吗？不是。仅凭教师无法确定是哪个学生。
>         *   因此，**这个依赖违反了 BCNF**。
>     *   该模式存在冗余：如果一位教师教 100 个学生，`教师 → 课程` 这个事实就会被存储 100 次。
>     *   解决方案：分解为 `(教师, 课程)` 和 `(学生, 教师)` 两个模式，两者都满足 BCNF。
>
> ---
>
> ### 总结对比
>
> | 特性         | 3NF                                                          | BCNF                                                     |
> | :----------- | :----------------------------------------------------------- | :------------------------------------------------------- |
> | **核心要求** | 消除非主属性对候选键的**传递依赖**和**部分依赖**。           | 消除**所有属性**（包括主属性）对非超键的依赖。           |
> | **判断条件** | 对于每个 `X → A`：<br>1. X 是超键，**或**<br>2. A 是主属性。 | 对于每个 `X → A`：<br>**X 必须是超键**。                 |
> | **宽松程度** | 较宽松，允许“主属性对非超键的依赖”这种特殊情况。             | 更严格，不允许任何“决定因素不是超键”的情况。             |
> | **设计目标** | 在保持无损连接和依赖保持的前提下，尽可能消除冗余和异常。     | 彻底消除所有基于函数依赖的冗余和异常。                   |
> | **分解结果** | 总能得到**无损连接且依赖保持**的分解。                       | 总能得到无损连接的分解，但**不一定能保持所有函数依赖**。 |
> | **关系**     | BCNF ⊂ 3NF。满足 BCNF 的一定满足 3NF，反之则不一定。         |                                                          |
>
> ### 实践建议
> 1.  **先检查 3NF**：通常数据库设计会先满足 3NF，因为它能保证依赖保持，这在业务逻辑一致性上很重要。
> 2.  **再考虑 BCNF**：如果发现某些冗余或异常在 3NF 下依然存在（通常是涉及主属性的依赖），可以进一步考虑向 BCNF 分解，但需要评估是否值得牺牲依赖保持性。
> 3.  **工具辅助**：在实际设计中，可以通过计算属性集的闭包来准确找到所有候选键和函数依赖，然后系统性地应用上述条件进行判断。



## 函数依赖理论
### 超码与候选码的函数依赖表示
- 超码：`K`是`R`的超码当且仅当`K→R`（`K`决定`R`的所有属性）。
- 候选码：`K`是`R`的候选码当且仅当`K→R`，且无`α⊂K`满足`α→R`（最小超码）。

### 函数依赖的闭包（Closure of Functional Dependencies）
#### 定义
给定函数依赖集`F`，所有逻辑蕴含于`F`的函数依赖构成的集合称为`F`的闭包，记为`F⁺`。
- 示例：若`F={A→B, B→C}`，则`A→C`（传递律）、`AG→CG`（增广律）均属于`F⁺`。

####  Armstrong公理（Armstrong's Axioms）
用于推导`F⁺`，具有可靠性（推导的依赖均成立）和完备性（所有成立的依赖均可推导）：
1. 自反律（Reflexivity）：若`β⊆α`，则`α→β`。
2. 增广律（Augmentation）：若`α→β`，则`γα→γβ`。
3. 传递律（Transitivity）：若`α→β`且`β→γ`，则`α→γ`。

#### 导出规则（由Armstrong公理推导）
1. 合并律（Union）：若`α→β`且`α→γ`，则`α→βγ`。
2. 分解律（Decomposition）：若`α→βγ`，则`α→β`且`α→γ`。
3. 伪传递律（Pseudotransitivity）：若`α→β`且`γβ→δ`，则`αγ→δ`。

#### `F⁺`的计算流程
1. 初始化`F⁺=F`。
2. 对`F⁺`中的每个依赖应用自反律和增广律，将结果加入`F⁺`。
3. 对`F⁺`中的每对依赖应用传递律，将结果加入`F⁺`。
4. 重复步骤2-3，直至`F⁺`不再变化。

### 属性集的闭包（Closure of Attribute Sets）
#### 定义
给定属性集`α`和函数依赖集`F`，`α`的闭包`α⁺`是所有能由`α`函数决定的属性集合（`α⁺={A | α→A ∈ F⁺}`）。

#### 计算算法
```
result := α;
while (result发生变化) do
    for each β→γ in F do
        if result ⊇ β then
            result := result ∪ γ;
```

#### 示例
- `R=(A,B,C,G,H,I)`，`F={A→B, A→C, CG→H, CG→I, B→H}`。
- 计算`(AG)⁺`：
  1. `result=AG`。
  2. 由`A→B`和`A→C`，`result=ABCG`。
  3. 由`CG→H`（`CG⊆ABCG`），`result=ABCGH`。
  4. 由`CG→I`（`CG⊆ABCGH`），`result=ABCGHI`（最终结果）。

#### 应用场景
1. 判断`α→β`是否成立：只需检查`β⊆α⁺`。
2. 判断`α`是否为超码：只需检查`α⁺⊇R`。（用于判断一个非平凡依赖 `α→β`，是否违反了BCNF。将其推广，针对关系 R 的函数依赖集合 F 中的每一个 `α→β` 都进行检查，即可判断 关系 R 是否属于 BCNF ）
3. 计算`F⁺`：通过所有属性集的闭包推导。



## 模式分解算法

### BCNF 判断

如何检查一个非平凡依赖 `α→β` 是否违反 BCNF？

- 计算 $\alpha^+$ ，即 $\alpha$ 的属性闭包
- 然后检查  `R ⊆ ` $\alpha^+$ 是否成立，如果成立，则不违反。
- 通俗说，即看 $\alpha$ 是否为超键。

如何检查一个关系 R 是否是 BCNF？

- 针对 F 中的每一个函数依赖，检查其是否违反 BCNF，如果都不违反，就是 BCNF。（==优点是不需要计算 F+==）
- **注意：在检查分解后的 子关系是否属于 BCNF 时，需要计算 F+ 进行检查，可能存在 没有任何一个属性完整属于某个子关系的情况**。

### BCNF分解
#### 分解规则
若关系模式`R`不属于BCNF，存在非平凡依赖`α→β`（`α`不是超码，`α∩β=∅`），则将`R`分解为：
- `R1=α∪β`（包含`α`和`β`的所有属性）。
- `R2=R−β`（包含`R`中除`β`外的所有属性）。

#### 示例1：`inst_dept`分解
- 原始模式：`inst_dept(ID, name, salary, dept_name, building, budget)`。
- 违规依赖：`dept_name→building, budget`（`dept_name`不是超码）。
- 分解结果：
  - `R1=(dept_name, building, budget)`（BCNF模式）。
  - `R2=(ID, name, salary, dept_name)`（BCNF模式）。

#### 示例2：`class`分解
- 原始模式：`class(course_id, title, dept_name, credits, sec_id, semester, year, building, room_number, capacity, time_slot_id)`。
- 函数依赖：
  - `course_id→title, dept_name, credits`（课程ID决定课程名称、部门、学分）。
  - `building, room_number→capacity`（办公楼+房间号决定容量）。
  - `course_id, sec_id, semester, year→building, room_number, time_slot_id`（课程ID+班级ID+学期+年份决定教室和时间段）。
- 分解步骤：
  1. 由`course_id→title, dept_name, credits`分解为`course(course_id, title, dept_name, credits)`（BCNF）和`class-1(course_id, sec_id, semester, year, building, room_number, capacity, time_slot_id)`。
  2. 由`building, room_number→capacity`分解`class-1`为`classroom(building, room_number, capacity)`（BCNF）和`section(course_id, sec_id, semester, year, building, room_number, time_slot_id)`（BCNF）。

#### BCNF分解算法流程
```
result := {R};
done := false;
compute F⁺;
while (not done) do
    if (存在模式Ri ∈ result 不属于BCNF) then
        找到Ri上的非平凡依赖α→β（α不是超码，α∩β=∅）;
        result := (result − {Ri}) ∪ {Ri−β} ∪ {α∪β};
    else
        done := true;
```
- 特性：最终分解结果均为BCNF，且是无损连接分解；但可能不保持依赖。

### 保持依赖的分解（Dependency Preservation）
#### 定义
若分解后的模式集`{R1, R2, …, Rn}`满足`(F1∪F2∪…∪Fn)⁺=F⁺`（`Fi`是`F`在`Ri`上的投影），则称分解保持依赖。

#### 示例
- 模式`R(A,B,C)`，`F={A→B, B→C}`。
  - 分解1：`R1(A,B)`、`R2(B,C)`：保持依赖（`F1={A→B}`，`F2={B→C}`，`(F1∪F2)⁺=F⁺`）。
  - 分解2：`R1(A,B)`、`R2(A,C)`：不保持依赖（`B→C`无法由`F1∪F2`推导）。

#### 保持依赖的测试方法
对`F`中的每个依赖`α→β`，按以下步骤测试：
```
result := α;
while (result发生变化) do
    for each Ri in 分解模式集 do
        t := (result ∩ Ri)⁺ ∩ Ri;  // 基于F计算闭包
        result := result ∪ t;
if β⊆result then α→β被保持;
```
- 若所有`F`中的依赖均被保持，则分解保持依赖。

### 3NF判断

给定关系 R 和 函数依赖集合 F ，如何判断 R 是否属于 3NF？

- 针对 F 中的每一个非平凡函数依赖`α→β`，检查 $\alpha$ 是否是超键
- 如果不是 $\alpha$ 不是超键，检查 $\beta$ 中的每一个属性是否都是 R 候选键。
- 3NF 的检查是一个 NP-Hard 问题。

### 3NF分解（保持依赖+无损连接）
####  canonical覆盖（Canonical Cover）
##### 定义
`F`的canonical覆盖`Fc`是与`F`等价的最小依赖集，满足：
1. 无冗余依赖（无法删除任何依赖）。
2. 每个依赖的左部和右部无冗余属性（无法删除任何属性）。
3. 每个依赖的左部唯一（无两个依赖左部相同）。

##### 冗余属性（Extraneous Attributes）
- 左部冗余：若`αx→β ∈ F`，且`(F−{αx→β})∪{α→β} ≡ F`，则`x`是左部冗余属性。
- 右部冗余：若`α→βx ∈ F`，且`(F−{α→βx})∪{α→β} ≡ F`，则`x`是右部冗余属性。

**冗余属性更加具体的判断方法**：注意都是使用 F 计算的，不要误用 $F_c$ 计算。

- 给定 $\alpha x \rarr \beta$ 和 F，判断 x 是否是冗余的？
  - 基于 F 计算 $\alpha^+$，判断 $\beta $ 是否属于 $\alpha^+$ 
- 给定 $\alpha \rarr \beta x$ 和 F，判断 x 是否冗余？
  - 先计算 $F'=\{F-\{\alpha-\beta x\} \cup \{a\rarr \beta\}\}$ 
  - 基于 $F'$ 计算 $\alpha^+$，判断 $x $ 是否属于 $\alpha^+$。

##### 计算流程
```
repeat
    用合并律替换α→β1和α→β2为α→β1β2;
    找到依赖α→β中的冗余属性（左部或右部）;
    删除冗余属性;
until F不再变化;
```

==注意：在部分属性删除之后，合并律还是有用的，需要反复使用==

#### 3NF分解算法

```
1. 计算F的canonical覆盖Fc;
2. i := 0;
3. for each α→β in Fc do
    if 无Ri包含α∪β then
        i := i+1;
        Ri := α∪β;
4. 若所有Ri均不包含R的候选码，则
    i := i+1;
    Ri := R的任意候选码;
5. 删除被其他Ri包含的模式;
return {R1, R2, …, Ri};
```
- 特性：分解结果均为3NF，且是保持依赖+无损连接分解；允许少量冗余，但确保依赖可在单个模式上验证。

#### 示例
- 模式`cust_banker_branch(customer_id, employee_id, branch_name, type)`，`F={customer_id, employee_id→branch_name, type; employee_id→branch_name; customer_id, branch_name→employee_id}`。
-  canonical覆盖`Fc={customer_id, employee_id→type; employee_id→branch_name; customer_id, branch_name→employee_id}`。
- 分解结果：`(customer_id, employee_id, type)`、`(employee_id, branch_name)`、`(customer_id, branch_name, employee_id)`（删除`(employee_id, branch_name)`，因被包含），最终为`(customer_id, employee_id, type)`、`(customer_id, branch_name, employee_id)`。

## BCNF与3NF的对比
| 特性 | BCNF | 3NF |
| ---- | ---- | ---- |
| 无损连接 | 是 | 是 |
| 保持依赖 | 否（可能破坏） | 是 |
| 消除冗余 | 是 | 否（允许少量冗余） |
| 应用场景 | 优先选择（无依赖保持需求时） | 需保持依赖时 |

### 设计目标的权衡
1. 理想目标：BCNF + 无损连接 + 保持依赖（并非总能实现）。
2. 妥协方案：
   - 方案1：选择BCNF分解，接受依赖不保持（需通过连接验证依赖，效率较低）。
   - 方案2：选择3NF分解，接受少量冗余（依赖可在单个模式验证，效率较高）。



## 更高范式：4NF（Fourth Normal Form）
### 多值依赖（Multivalued Dependencies）
#### 示例
模式`inst_info(ID, child_name, phone)`（教师ID、子女姓名、电话号码）：
- 教师可有多子女和多电话，且子女与电话无关联（如教师99999有子女David、William和电话512-555-1234、512-555-4321，需存储4条记录）。
- 该模式属于BCNF（无非平凡函数依赖），但存在插入异常（新增电话需为每个子女添加一条记录），需通过多值依赖分解。

### 4NF定义
若关系模式`R`对于函数依赖和多值依赖集`D`满足：对`D⁺`中所有非平凡多值依赖`α→→β`（`α⊆R`，`β⊆R`），至少满足以下条件之一，则`R`属于4NF：
1. `β⊆α`或`α∪β=R`（平凡多值依赖）。
2. `α`是`R`的超码。

### 4NF分解示例
将`inst_info(ID, child_name, phone)`分解为：
- `inst_child(ID, child_name)`（教师-子女）。
- `inst_phone(ID, phone)`（教师-电话）。
- 分解后无插入异常，且属于4NF。

## 数据库设计流程总结
### 设计来源
1. E-R图转换：若E-R图设计合理（正确识别实体和关系），转换后的表通常无需进一步规范化；若存在非键属性的函数依赖，需补充规范化。
2. 万能关系（Universal Relation）：包含所有相关属性，通过规范化分解为多个模式。
3. 临时设计：对现有临时表进行规范化测试和转换。

### 为性能反规范化（Denormalization）
- 场景：需优化查询性能（如频繁关联`course`和`prereq`表查询先修课程）。
- 方案：
  1. 反规范化：合并相关表为一个表（如包含`course`和`prereq`的所有属性），查询更快，但更新时需维护冗余数据。
  2. 物化视图：定义`course`和`prereq`的连接视图并存储数据，无需手动维护冗余，但占用额外空间。

