# 第15章：并发控制（Concurrency Control）
## 基于锁的协议（Lock-Based Protocols）
### 锁的定义与作用
锁是**控制数据项并发访问**的机制：通过**限制事务对数据项的操作权限，避免并发冲突**。

### 锁的两种模式
1. **排他锁（Exclusive, X 锁）**：允许事务对数据项进行读写操作，通过 `lock-X` 指令请求。
2. **共享锁（Shared, S 锁）**：仅允许事务对数据项进行读操作，通过 `lock-S` 指令请求。

### 锁兼容性矩阵
| 请求锁\持有锁 | S 锁 | X 锁 |
| ---- | ---- | ---- |
| S 锁 | 兼容（true） | 不兼容（false） |
| X 锁 | 不兼容（false） | 不兼容（false） |

- 规则：仅当**请求锁**与数据项上**已持有的其他锁兼容**时，并发控制管理器才授予该锁；若**不兼容**，**请求事务需等待**，直至**所有不兼容锁**被释放。



### 简单加锁示例与局限
事务 T2 的加锁逻辑：`lock-S(A)→read(A)→unlock(A)→lock-S(B)→read(B)→unlock(B)→display(A+B)`。
- 局限：仅这样的加锁无法保证可串行化，若 A、B 在两次读取之间被更新，会导致显示的总和错误。
- 核心：加锁协议需**定义统一规则，规范所有事务的锁请求与释放行为，限制可能的调度范围。**



### 基于锁的协议的潜在问题
#### 1. 死锁（Deadlock）
- 定义：**多个事务相互等待对方释放锁**，导致所有事务无法继续推进。
- 示例：T3 持有 B 的锁并请求 A 的锁，T4 持有 A 的锁并请求 B 的锁，双方陷入永久等待。
- 处理：需**回滚其中一个事务并释放其锁，打破死锁**。

#### 2. 饥饿（Starvation）
- 定义：某个事务**长期无法获得所需锁**，反复被其他事务抢占资源。
- 示例：T2 请求 A 的 X 锁，而一系列事务（T3、T4、T5...）持续请求并获得 A 的 S 锁，导致 T2 一直等待。
- 避免：通过合理设计并发控制管理器，**确保事务不会被无限期忽视**。



## 两阶段锁协议（Two-Phase Locking Protocol）
### 核心规则
通过将事务的加锁、解锁过程分为两个阶段，确保冲突可串行化：
1. **增长阶段（Growing Phase）**：事务可获取锁，但不能释放锁。
2. **收缩阶段（Shrinking Phase）**：事务可释放锁，但不能获取锁。

### 特性
1. **优点**：**严格保证冲突可串行化**（通过**锁的冲突机制**，==强制并发事务的冲突操作按 “先加锁者优先” 的顺序执行，等价于构造了一个串行执行的顺序==。），事务可按“锁点”（获取最后一个锁的时刻）排序。
2. **缺点**：
   - **仍可能发生死锁。**
   - **可能出现级联回滚。**



### 改进版本
#### 1. 严格两阶段锁（Strict Two-Phase Locking）
- 规则：事务**需持有所有排他锁（X 锁）直至提交或中止**。
- 作用：**避免级联回滚，确保未提交事务的写操作不会被其他事务读取**。
- 示例：T3 需在 `commit` 后，再执行 `unlock(B)→unlock(A)`。

#### 2. 强两阶段锁（Rigorous Two-Phase Locking）
- 规则：事务需**持有所有锁（S 锁和 X 锁）直至提交或中止**。
- 作用：进一步增强隔离性，**事务可按提交顺序串行化，但并发度最低**。
- 示例：T4 需在 `commit` 后，再执行 `unlock(B)→unlock(A)`。

### 锁转换（Lock Conversions）
两阶段锁协议**支持锁转换，减少锁竞争开销**：
1. **增长阶段**：
   - 可直接获取 S 锁或 X 锁。
   - 可将 S 锁升级（upgrade）为 X 锁。
2. **收缩阶段**：
   - 可释放 S 锁或 X 锁。
   - 可将 X 锁降级（downgrade）为 S 锁。
- 优势：避免**“释放 - 重获”锁过程中的死锁窗口期**。（避免发生死锁）
- 局限：**增加锁管理的复杂性**。

![image-20251223101326494](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223101326494.png)

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223101326494.png)

![image-20251223101348207](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223101348207.png)



## 锁的自动获取与释放
### 读操作（read(D)）的处理逻辑
1. 若事务已持有 D 的 S 锁，直接执行读操作。（暗示兼容）
2. 否则：
   - **等待直至 D 上无其他事务的 X 锁。**
   - **授予事务 D 的 S 锁，执行读操作。**

### 写操作（write(D)）的处理逻辑
1. 若事务已持有 D 的 X 锁，直接执行写操作。（暗示兼容）
2. 否则：
   - **等待直至 D 上无其他事务的任何锁。**
   - 若事务已持有 D 的 S 锁，将其升级为 X 锁；否则直接授予 X 锁。
   - 执行写操作。

所有锁在事务提交或中止后自动释放。





## 基于图的协议（Graph-Based Protocols）
### 核心思想
对所有数据项定义偏序关系（`→`），事务访问数据项时需遵循该顺序（若 `di→dj`，则事务访问 dj 前必须先访问 di）。数据项集合可视为**有向无环图**（数据库图），树协议是最典型的基于图的协议。

### 树协议（Tree Protocol）
#### 规则
1. 仅**支持排他锁**（X 锁）。
2. 事务的**第一个锁可加在任意数据项上。**
3. 后续加锁的 data Q 需满足：Q 的**父节点当前已被该事务锁定。**（强制**所有事务的加锁顺序一致**，避免 “循环等待”（死锁的必要条件之一））
4. **数据项可随时解锁。**（优势：相比 2PL，锁的**持有时间更短，并发度更高**）
5. **事务解锁后，不能再重新锁定该数据项。**（防止事务**重复加锁导致的锁竞争**，进一步规避死锁）

#### 特性
| 特性 | 说明 |
| ---- | ---- |
| 冲突可串行化 | 是 |
| 无死锁 | 是（严格的访问顺序避免循环等待） |
| 可恢复性 | 否 |
| 无级联 | 否 |
| 并发度 | 高于两阶段锁协议（可提前解锁） |
| 锁开销 | 可能更高（需锁定未访问的父节点） |

## 各协议特性对比
| 协议 | 冲突可串行化 | 无死锁 | 可恢复性 | 无级联 |
| ---- | ---- | ---- | ---- | ---- |
| 两阶段锁协议（Two-Phase Locking） | 是 | 否 | 否 | 否 |
| 严格两阶段锁协议（Strict Two-Phase Locking） | 是 | 否 | 是 | 是 |
| 强两阶段锁协议（Rigorous Two-Phase Locking） | 是 | 否 | 是 | 是 |
| 树协议（Tree Protocol） | 是 | 是 | 否 | 否 |



## 死锁处理（Deadlock Handling）

### 死锁定义
存在一组事务，其中每个事务都在**等待该组中另一个事务释放资源**，导致所有事务无法推进。

### 处理策略
#### 策略 1：死锁预防（Deadlock Prevention）
通过**设计规则避免死锁的必要条件**（如循环等待），主要方法：
1. **预声明所有锁**：事务开始前，**提前锁定所有需要访问的数据项**。

2. **数据项偏序访问**：按预定义的偏序关系访问数据项（如树协议）。

3. **等待 - 死亡（wait-die）策略**：非抢占式，老事务可等待新事务释放资源，新事务不可等待老事务（直接回滚）。

   - 一个事务可能经过多次死亡后，才能获取目标锁

4. **伤害 - 等待（wound-wait）策略**：抢占式，老事务可强制回滚新事务（伤害）以获取资源，新事务可等待老事务。

   - 比等待-死亡机制更少发生回滚。

   上述两种是时间戳实现的，此外回滚时，**事务仍然保留原来的时间戳**，这保证了不会发生饥饿现象。

5. **超时机制**：事务等待锁的时间**超过阈值后，自动回滚，避免无限等待**。

   - 此类方法还是可能会出现饥饿现象，且阈值难以确定。

#### 策略 2：死锁检测与恢复（Deadlock Detection and Recovery）
允许死锁发生，通过检测机制发现后进行恢复：
1. **等待图（Wait-For Graph）**：
   - 顶点：系统中的所有事务。
   - 边：若事务 $T_i$ 等待 $T_j$ 释放资源，绘制边 $T_i \rarr T_j$。

2. **死锁判定**：等待图中存在环，则系统处于死锁状态，需定期执行环检测算法。

   ![image-20251223101953600](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223101953600.png)

3. **死锁恢复**：
   - **选择牺牲者（需回滚的事务**）：优先**选择回滚代价小的事务**。需要避免**同一事务反复被选中**（发生饥饿现象）（引入回滚次数作为代价因子）。
   - **回滚方式：完全回滚（中止后重启）或部分回滚（仅回滚至打破死锁所需的步骤**）。



## 多粒度锁（Multiple Granularity）
### 核心思想
数据项可具有不同大小（粒度），并形成层次结构（如数据库→区域→文件→记录），事务锁定某个节点时，隐式锁定其所有子节点（同一模式）。

- 我们根据资源的包含关系来决定父子关系。

![image-20251223102014151](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223102014151.png)

### 粒度权衡
- **细粒度（如记录级）**：并发度高，但锁开销大（需锁定多个节点）。
- **粗粒度（如数据库级）**：锁开销小，但并发度低（锁定后其他事务无法访问该节点下任何数据）。

### 意向锁模式（Intention Lock Modes）
为支持多粒度锁，新增三种意向锁（避免锁定高层节点时需检查所有子节点）：
1. **意向共享锁（IS）**：表示**将**在下层节点加 S 锁。
2. **意向排他锁（IX）**：表示**将**在下层节点加 X 锁或 S 锁。
3. **共享意向排他锁（SIX）**：**表示当前节点加 S 锁，且将在下层节点加 X 锁**。

### 意向锁兼容性矩阵

**兼容性规则**：意向锁**仅与上层粗粒度的显式锁冲突**，与同粒度的其他意向锁兼容（核心是 “声明不冲突，实际锁才冲突”）。

| 请求锁\持有锁 | IS | IX | S | SIX | X |
| ---- | ---- | ---- | ---- | ---- | ---- |
| IS | 兼容（true） | 兼容（true） | 兼容（true） | 兼容（true） | 不兼容（false） |
| IX | 兼容（true） | 兼容（true） | 不兼容（false） | 不兼容（false） | 不兼容（false） |
| S | 兼容（true） | 不兼容（false） | 兼容（true） | 不兼容（false） | 不兼容（false） |
| SIX | 兼容（true） | 不兼容（false） | 不兼容（false） | 不兼容（false） | 不兼容（false） |
| X | 不兼容（false） | 不兼容（false） | 不兼容（false） | 不兼容（false） | 不兼容（false） |



## SQL 中的弱一致性级别

SQL 允许非可串行化的执行，提供以下一致性级别（从高到低）：
1. **可串行化（Serializable）**：默认级别，严格保证隔离性。
2. **可重复读（Repeatable Read）**：仅读取已提交记录，同一记录的多次读取返回相同值，但不防止“幻影现象”（如其他事务插入新记录）。
3. **读已提交（Read Committed）**：仅读取已提交记录，同一记录的多次读取可能返回不同的已提交值（多数系统实现为“游标稳定性”）。
4. **读未提交（Read Uncommitted）**：允许读取未提交记录，一致性最低。

### 注意事项
部分数据库系统默认一致性级别为“读已提交”，需手动设置为“可串行化”（如 `set isolation level serializable`）以满足严格隔离需求。
