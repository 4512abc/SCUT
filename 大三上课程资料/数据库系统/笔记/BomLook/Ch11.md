# Ch11

==针对上一章介绍的Hash和Index，即文件中记录的组织形式，进行深入介绍==

==思路：先介绍基本概念，再介绍三类主要索引：有序索引，B+树索引，静态哈希索引。再比较他们之间的性能，最后落实实际，查看SQK中是如何定义索引的==

## 基本概念（Basic Concepts）
**索引的作用**：通过**特定机制加速**数据访问

- 类似图书馆的作者目录，帮助快速定位目标记录。



**核心术语**

1. **搜索键（Search Key）**：用于查找**文件中的记录**的一个或多个属性。
2. **索引文件（Index File）**：由索引条目（index entries）组成，每条条目包含**“搜索键+指针”**，索引文件**通常远小于原始数据文件**。



**两种基本类型**

1. **有序索引（Ordered Indices）**：搜索键按**顺序存储**。
2. **散列索引（Hash Indices）**：通过**散列函数**将搜索键均匀分布到“桶”（buckets）中。



**评估指标**（Index Evaluation Metrics）

1. **支持的访问类型**：等值查找（指定属性值的记录）、范围查找（属性值在指定范围内的记录）。
2. **访问时间（Access Time）**：查找目标记录所需的时间。
3. **插入时间（Insertion Time）**：新增记录时更新索引的时间。
4. **删除时间（Deletion Time）**：删除记录时更新索引的时间。
5. **空间开销（Space Overhead）**：索引占用的额外存储空间。



## 有序索引（Ordered Indices）
**定义**：索引条目按搜索键的值，顺序存储，例如图书馆的作者目录。

**分类**

1. **主索引（Primary Index）**

   - 又称聚集索引（clustering index），其**搜索键与文件的物理顺序一致**（建立在顺序文件的排序属性上）搜索键通常是主键（也可非主键）。

   - 示例：按教师ID（主键）排序的instructor表，主索引的搜索键为ID。

   ![image-20251223111745333](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223111745333.png)

2. **辅助索引（Secondary Index）**

   - 又称非聚集索引（non-clustering index），建立在非排序属性上，**搜索键顺序与文件物理顺序不同。**

   - 示例：instructor表的薪水（salary）属性索引，搜索键为salary，与表的物理顺序无关。

   ![image-20251223111753148](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223111753148.png)



**索引顺序文件（Index-sequential file）**：有主索引的有序顺序文件



**核心总结**

主索引是“与数据文件物理排序绑定的‘主钥匙’”，**优先保障排序属性的查询效率**，且全局唯一；辅助索引是“灵活的‘备用钥匙’”，用于满足**非排序属性的查询需求，可多维度建立**，但需付出更高的维护和查询开销。在实际数据库设计中，**通常为表的主键建立主索引，为高频查询的非主键属性建立辅助索引**，平衡查询效率与维护成本。



### 稠密索引与稀疏索引
#### 1. 稠密索引（Dense Index Files）
- 定义：在索引文件中，**每个搜索键**都有一条**对应的索引记录**。
- 示例：instructor表的ID属性稠密索引，每个ID都有对应的索引条目。

![image-20251223112113536](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223112113536.png)

![image-20251223112120020](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223112120020.png)

#### 2. 稀疏索引（Sparse Index Files）
- 定义：仅**部分搜索键有索引记录**（index record），只适用于**记录按搜索键顺序存储**的文件（即，主索引）。

  ![image-20251223112154386](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223112154386.png)

- 查找逻辑：找到**小于目标键K的最大搜索键**对应的索引记录，从该记录指向的位置**开始顺序扫描文件**。

- 对比稠密索引：
  - 优势：占用**空间更小**，插入/删除的**维护开销更低**。
  - 劣势：定位记录的**速度通常更慢**。

- 优化方案：==为文件的每个块建立稀疏索引，索引条目对应**块中最小的搜索键值。（即首个记录键值）**==

  ![image-20251223112340322](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223112340322.png)



### 多级索引（Multilevel Index）

**适用场景**：当主索引过大无法装入内存时，访问效率会下降。

**核心思想**：将磁盘上的主索引视为顺序文件，在其上构建稀疏索引，形成多级结构：

- **外层索引（outer index）：主索引的稀疏索引。**
- **内层索引（inner index）：原始的主索引文件。**
- 扩展：若外层索引仍过大，可继续构建更高层级的索引。

![image-20251223112521604](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223112521604.png)

#### 维护要求
插入或删除记录时，需同步更新所有层级的索引。



### 索引更新（Index Update）
**1. 删除（Deletion）**

- 稠密索引：类似文件记录删除，**直接移除对应索引条目**。
- 稀疏索引：若待删除的搜索键**存在索引条目**，**用文件中该键的下一个搜索键值替换（若下一个键已有索引条目，则直接删除原条目）**。（原来最小的已经被删除了，选择新的最小，就是下一个搜索键）



**2. 插入（Insertion）**

- 稠密索引：若插入的搜索键值**不在索引中，新增索引条目。**

- 稀疏索引：**仅当插入操作创建新数据块时，将新块的最小搜索键值插入索引。**（没有创建新块的话，插入的位置）

  由于稀疏索引的索引项通常是**数据块的首记录键值**（或固定间隔的记录键值），插入 / 删除时的核心原则是：

  - 若操作**不改变数据块的首记录键值** → **仅修改数据文件**，**无需修改**稀疏索引；
  - 若操作**改变了**数据块的首记录键值 → 必须**同步更新稀疏索引**的对应索引项。

- 多级索引更新：是单级索引更新逻辑的简单扩展。



### 辅助索引的特点
**适用场景**：需通过非排序属性查找记录，例如：

- 查找特定部门的所有教师（instructor表的dept_name属性）。
- 查找特定薪水或薪水范围的所有教师（instructor表的salary属性）。

**结构特点**

- 必须是**稠密索引**，每个搜索键值对应一条索引记录。
- 索引记录指向一个“桶”，桶中存储**所有该搜索键值**对应的**记录的指针**。

**优缺点**

- **优势：大幅提升非排序属性的查询效率。**
- 劣势：
  - 维护开销高：**文件修改时，所有相关辅助索引都需更新。**
  - 顺序扫描低效：通过辅助索引进行全表扫描时，可能频繁读取不同磁盘块（磁盘I/O开销远高于内存访问）。



## B+树索引文件（B+-Tree Index Files）
**背景**：

- 索引顺序文件的性能会随文件增长下降（产生大量溢出块），需定期重组；
- 而B+树索引可通过**局部小幅调整**自动维护性能，**无需全文件重组**。



**优缺点**

- 优势：**插入/删除时自动局部重组，维持查询效率**；广泛应用于数据库系统。
- 劣势：相比索引顺序文件，**插入/删除有额外开销，占用更多存储空间**。



**结构特性**

![image-20251223115333788](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223115333788.png)

B+树是一棵有根树，满足以下规则：
1. 根到叶子节点的所有路径长度相同。
2. 内部节点（非根、非叶子）：有$[\lceil n/2\rceil, n]$个子节点（ $n$ 为节点最大子节点数，一般称为 order n）。
3. 叶子节点：有$[\lceil(n-1)/2\rceil, n-1]$个搜索键值。一般说叶子节点有多少个，指的是搜索键值。
4. 根节点：若为非叶子节点，至少有2个子节点；若为叶子节点，可包含0到 $n-1$ 个键值。



### 节点结构

**通用结构**

- 包含搜索键值$K_1<K_2<...<K_{n-1}$，以及指针$P_1,P_2,...P_n$

- 非叶子节点：$P_i$为子节点指针。

  - 形成多级稀疏索引，引导查找路径。
  - 每个非叶子节点的键值用于划分子节点的搜索键范围。

  $$
  P_1 < K_1 \leq P_2 < K_2 \leq P_3 < K_3 \leq ... < P_{n-1} < K_{n-1} \leq P_n
  $$

- 叶子节点：$P_i$为记录或记录桶的指针。

  - **叶子节点按搜索键值排序，**通过指针 $P_n$ 链接成有序链表（便于范围查询）。
  - 存储记录指针（B+树索引）或直接存储记录（B+树文件组织）。

  $$
  P_1 = K_1 < P_2 = K_2 < P_3 = K_3 < ... < P_{n-1} = K_{n-1} < P_n
  $$

  

### B+树的关键观察
1. **逻辑相邻的块（搜索键值相近）无需物理相邻（通过指针连接）。**

   ![image-20251223115507644](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223115507644.png)

2. 树的高度低：若 $n=100$（每个索引条目40字节，节点大小4KB），100万条搜索键的B+树高度仅为 $\lceil log_{50}(10^6)\rceil=4$ ，查找时仅需访问4个节点（磁盘I/O开销低）。

   总结：如果文件中有 $m$ 个搜索键，则树的高度不超过 $\lceil log_{\lceil\frac{n}{2} \rceil}(m) \rceil$。

3. **插入/删除效率高：可在对数时间内完成索引重组。**



### B+树查询流程（Queries on B+-Trees）
1. 从根节点开始，判断当前节点是否为叶子节点。
2. 非叶子节点：找到首个**大于等于**目标键 $V$ 的 $K_i$（即 $V \leq K_i$），按规则选择子节点指针（ $V=K_i$选 $P_{i+1}$，$V<K_i$ 选 $P_i$，无 $K_i$ 选最后一个非空指针），递归访问子节点。
3. 叶子节点：查找等于 $V$ 的 $K_i$ ，若存在则通过对应 $P_i$ 访问记录；否则无匹配记录。



### B+树文件组织（B+-Tree File Organization）

- B+树索引：可以解决索引文件性能下降问题

- B+树文件组织：可以解决 数据文件 性能下降问题

- 核心差异：

  - 叶子节点（B+树文件组织）直接存储记录（而非指针），
    - 仍需满足“半满”要求（因记录比指针占用空间大，叶子节点最大记录数少于非叶子节点最大指针数）。

  - 数据库中**绝大多数 B + 树是 “索引”**，叶子节点存指针；仅当 B + 树直接作为**数据文件的存储结构**时，叶子节点才存完整记录

- 优化：为了**提升**空间利用率，**分裂或合并**节点期间，可**涉及多个兄弟节点进行重新分配**。
  - e.g：涉及两个兄弟节点进行重新分配，节点至少包含$2n/3$条记录。



### 字符串索引（Indexing Strings）
- 挑战：字符串长度可变导致节点扇出（子节点数）差异大。
- 优化方案：
  - **按空间利用率而非指针数决定是否分裂节点。**
  - 前缀压缩：内部节点存储**键值前缀（仅需区分子树即可）**，叶子节点**共享公共前缀，减少存储空间**。
  
  

### B+树更新操作
#### 1. 插入（Insertion）
- 步骤：
  1. 找到目标键应插入的叶子节点。
  2. 若键已存在：新增记录，必要时更新桶指针。
  3. 若键不存在：新增记录（必要时创建桶），若叶子节点有空间则直接插入索引条目；否则分裂叶子节点。
- 节点分裂（叶子节点）：
  1. 将 $n+1$ 条（含新增）**索引条目**排序，前 $\lceil n/2\rceil$ 条保留在原节点，剩余放入新节点。
  2. 向父节点插入（新节点最小键值，新节点指针）条目，若父节点满则递归分裂，直至找到未满节点或分裂根节点（树高+1）。
- 非叶子节点分裂：类似叶子节点，**分裂后中间键值上升至父节点**。

#### 2. 删除（Deletion）
- 步骤：
  1. 找到待删除记录对应的叶子节点，移除记录及索引条目（桶为空时）。
  2. 若节点条目数低于最小值：
     - 情况1：与兄弟节点条目合并后不超过最大值，合并两节点，删除父节点中对应指针条目，递归处理父节点。
     - 情况2：合并后超过最大值，与兄弟节点 redistribution 条目，更新父节点对应键值。
- 级联删除：节点删除可能向上传播，直至根节点（根节点仅剩一个子节点时，根节点删除，子节点成为新根）。



## 静态散列（Static Hashing）

**核心概念**

1. **桶（Bucket）**：存储一条或多条记录的存储单元（通常为磁盘块）。
2. **散列函数（Hash Function）**：$h:K→B$，将搜索键集合K映射到桶地址集合B。
3. **工作原理**：
   - 通过散列函数直接获取**记录所在桶地址**，用于**访问、插入和删除**操作；
   - 同一桶中需顺序扫描查找目标记录。



**要求**

- 避免最坏情况：**所有键映射到同一桶**（访问时间与文件大小成正比）。
- 理想特性：
  - 均匀性：每个桶分配**相同数量**的**可能搜索键**值。
  - 随机性：无论实际搜索键分布如何，**每个桶分配的记录数相近。**
- 常见实现：对搜索键的二进制表示进行计算（如字符串求和后（对每个字符的编码进行求和）取模）。



**均匀性 vs 随机性 核心区别**

| 特性                | 均匀性                                  | 随机性                                  |
|---------------------|-----------------------------------------|-----------------------------------------|
| **核心目标**        | 映射结果在地址空间均匀分布              | 映射关系无规律、不可预测                |
| **关注重点**        | 结果的**分布状态**                      | 输入与输出的**关联关系**                |
| **与冲突的关系**    | 直接降低冲突概率                        | 间接降低冲突概率，同时防针对性冲突      |
| **适用场景**        | 普通哈希表、数据分片（无安全需求）      | 密码学、抗攻击场景、一致性哈希          |
| **关联**            | 均匀性是基础要求                        | 随机性是更高阶要求，强随机→大概率均匀    |



### 桶溢出处理（Handling of Bucket Overflows）
**溢出原因**

- 桶数量不足。
- **记录分布偏斜（搜索键重复过多，或散列函数非均匀）。**

上述问题发生概率可以降低，但是该问题无法避免。



**处理方案：溢出链（Overflow Chaining）**

- 为**溢出桶建立链表**，同一原始桶的所有溢出桶通过链表连接。
- 该方案属于闭散列（closed hashing），开散列（无溢出桶）不适合数据库应用。

![image-20251223131529879](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223131529879.png)





### 散列索引（Hash Indices）
- 应用场景：不仅可用于**文件组织**，还可构建**索引结构**。
- 结构：将搜索键及对应记录指针组织为散列文件结构。
- 注意：若文件本身**采用散列组织**，无需为同一搜索键构建单独的主散列索引；**散列索引通常指辅助散列索引**。



### 静态散列的缺陷（Deficiencies of Static Hashing）
- 桶数量固定，无法适应数据库的增长或收缩：
  - 桶数量不足：**文件增长导致溢出增多，性能下降**。
  - 预留过多桶：**初始阶段空间浪费严重**。
  - 可以阶段性使用 新的hash函数，对文件进行重新组织，但是成本高，会中断正常操作。
- 解决方案：动态调整桶数量（动态散列），避免全文件重组。



## 有序索引与散列的比较（Comparison of Ordered Indexing and Hashing）
| 对比维度 | 有序索引 | 散列 |
| ---- | ---- | ---- |
| 等值查找 | 效率较高 | 效率更高 |
| 范围查找 | 支持且高效 | 不支持（需全表扫描） |
| 文件重组 | 索引顺序文件需定期重组，B+树无需 | 静态散列需定期重组，动态散列无需 |
| 插入/删除开销 | B+树有一定开销 | **静态散列开销低，动态散列有一定开销** |
| 数据库支持 | 主流数据库（Oracle、SQL Server、PostgreSQL）均支持（B+树为主） | PostgreSQL支持但不推荐，Oracle等支持有限 |

### 选择建议
- 若频繁进行范围查询，优先选择有序索引（B+树）。
- 若仅需等值查询，散列（动态散列）效率更高。



## SQL中的索引定义（Index Definition in SQL）
**创建索引**

```sql
create index <索引名> on <关系名> (<属性列表>);
```
- 示例：为instructor表的dept_name属性创建索引  
  `create index dept_index on instructor (dept_name);`
- 唯一索引：`create unique index`，间接强制**搜索键为候选键**（与SQL的unique约束功能重叠）。

**删除索引**

```sql
drop index <索引名>;
```

**扩展功能**

多数数据库支持指定索引类型（如B+树、散列）和聚集属性（是否为聚集索引）。



## 多键访问（Multiple-Key Access）

**单属性索引的多键查询策略**

以查询“dept_name='Finance'且salary=80000的教师ID”为例，三种方法如下：
1. 用dept_name索引查找所有Finance部门教师，过滤salary=80000的记录。
2. 用salary索引查找所有薪水为80000的教师，过滤dept_name='Finance'的记录。
3. 分别获取两个索引的记录指针，取交集后访问目标记录。

**复合索引（Indices on Multiple Keys）**

- 定义：搜索键包含多个属性（如(dept_name, salary)）。
- 排序规则：字典序（如(a1,a2) < (b1,b2) 当且仅当a1<b1，或a1=b1且a2<b2）。
- 优势：可**直接高效处理**多属性等值查询（如dept_name='Finance'且salary=80000）和部分范围查询（如dept_name='Finance'且salary<80000）。
- 劣势：无法高效处理“**前导属性为范围条件**”的查询（如dept_name<'Finance'且salary=80000）。

