# 第14章：事务（Transactions）
## 事务概念
**事务是程序执行的一个单元**，它会访问并可能更新多个数据项。

### 核心问题
事务处理需解决两大核心问题：
1. 各类故障（如硬件故障、系统崩溃）
2. 多个事务的并发执行

## ACID特性
**为保证数据完整性**，数据库系统必须确保事务满足ACID特性：

### 原子性（Atomicity）
事务的**所有操作要么全部正确反映到数据库中，要么全部不反映**。
### 一致性（Consistency）
事务隔离执行时，会保持数据库的一致性。
- 示例：转账事务中，账户A和B的余额总和应保持不变。
- 通用规则：**事务执行前数据库处于一致状态，执行过程中可能暂时不一致，但执行成功后必须恢复一致状态**（包括**显式完整性约束**如**主键/外键，以及隐式约束**如所有账户余额总和不变）。
- 注意：错误的事务逻辑可能导致一致性破坏。

### 隔离性（Isolation）
多个事务并发执行时，**每个事务都应感觉不到其他事务的存在，中间结果需对其他事务隐藏。**
- 示例：若转账事务T1在步骤3和6之间，另一事务T2读取A和B的余额，会得到不一致的总和（A+B小于实际值）。
- 理想情况：对任意两个事务T和F，看起来要么F在T开始前完成，要么F在T结束后开始。
- 备注：**串行执行事务可 trivially 保证隔离性，但并发执行能提升系统性能**。

### 持久性（Durability）
事务成功完成后，其**对数据库的修改必须永久保留，即使发生系统故障**。



## 事务状态
1. **活动状态（Active）**：初始状态，事务正在执行中。
2. **部分提交状态（Partially Committed）**：==事务执行完最后一条语句，但修改尚未写入稳定存储。==
3. **失败状态（Failed）**：发现无法继续正常执行（如故障或逻辑错误）。
4. **中止状态（Aborted）**：事务回滚后，数据库**恢复到事务开始前的状态**。
   - 后续操作：
     1. 重启事务（仅当**无内部逻辑错误**时）；
     2. 终止事务。
5. **提交状态（Committed）**：事务成功完成，其提交日志记录已写入稳定存储。

### 状态流转
![image-20251129114159137](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251129114159137.png)



## 并发执行（Concurrent Executions）

### 并发执行的优势
1. **提高处理器和磁盘利用率**，提升事务吞吐量（如一个事务使用CPU时，另一个事务读写磁盘）。
2. **减少事务平均响应时间**（短事务无需等待长事务完成）。

### 并发控制方案（Concurrency Control Schemes）
用于**实现隔离性和一致性，控制并发事务间的交互，避免破坏数据库一致性**。



## 调度（Schedules）
调度是指定**并发事务指令执行 chronological（按时间排序） 顺序**的指令序列。

### 调度的要求
1. 包含**所有参与事务**的**全部指令**。
2. 保留**每个事务内部指令的原有顺序**。
- 示例：事务T1={a1,a2,…,a10}、T2={b1,b2,…,b10}，调度需完整执行所有20条指令，并保持a1到a10、b1到b10的内部顺序。

### 事务的结束指令
1. 成功完成的事务：最后一条语句为**提交指令（默认隐含）**。
2. 执行失败的事务：最后一条语句为**中止指令**。



## 可串行化（Serializability）
### 基本假设
每个**单独执行的事务**都能**保持数据库一致性**，因此**串行执行一组事务也能保持一致性**。

### 定义
**若一个（可能并发的）调度等价于某个串行调度，则称该调度是可串行化的**。最核心的类型是冲突可串行化（conflict serializability）。

### 简化假设
仅关注事务的读写指令，忽略其他计算操作（假设事务可在本地缓冲区中对数据进行任意计算）。

## 冲突指令（Conflicting Instructions）
### 冲突条件
**事务T的指令t和事务F的指令f冲突，当且仅当：**
1. **两者访问同一个数据项Q；**
2. **至少有一个指令是写操作（write(Q)）。**

### 冲突情况示例
1. t=read(Q)，f=read(Q)：不冲突；
2. t=read(Q)，f=write(Q)：冲突；
3. t=write(Q)，f=read(Q)：冲突；
4. t=write(Q)，f=write(Q)：冲突。

### 无冲突指令的交换性
若调度中两条**连续**指令**不冲突**，则交换它们的顺序后，调度结果不变。



## 冲突可串行化（Conflict Serializability）
### 定义
若调度S**可通过一系列无冲突指令的交换，转换为串行调度S2**，则称S与S2冲突等价；若S冲突等价于某个串行调度，则S是冲突可串行化的。



## 可串行化测试（Testing for Serializability）
### 优先级图（Precedence Graph）
1. 顶点：参与调度的各个事务。
2. 边：若满足以下任一条件，绘制边T1→T2：
   - T1执行write(Q)后，T2执行read(Q)；
   - T1执行read(Q)后，T2执行write(Q)；
   - T1执行write(Q)后，T2执行write(Q)。

### 判定定理
一个调度是冲突可串行化的，当且仅当其优先级图是无环的。

### 测试步骤

![image-20251222172604730](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251222172604730.png)

1. 构建调度的优先级图；
2. 检测图中是否存在环（环检测算法时间复杂度为O(n²)，优化算法为O(n+e)，n为顶点数，e为边数）；
3. 若无环，可通过拓扑排序得到串行化顺序（拓扑排序结果为与优先级图一致的线性顺序）。



## 可恢复调度（Recoverable Schedules）
### 定义
若事务T读取了事务F修改的数据项Q（即T的read(Q)与F的write(Q)冲突，即 F 先操作，T 后操作），**且F先提交后T才提交，则该调度是可恢复的**。（简单说，先做，先交）

### 非可恢复调度示例
事务T8执行write(A)后，事务T9执行read(A)并立即提交，若后续T8中止，T9已读取不一致的数据并可能对外输出，导致数据库状态不可恢复。

### 核心要求
数据库必须确保**所有调度都是可恢复的，以应对事务失败的影响**。



## 级联回滚（Cascading Rollbacks）
### 定义
单个事务失败导致一系列事务回滚。
- 示例：事务T10执行write(A)后，T11读取A并执行write(A)，T12读取A，若T10中止，T11和T12必须**同时回滚以保持一致性，但会撤销大量已完成工作**。

![image-20251129122323049](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251129122323049.png)

## 无级联调度（Cascadeless Schedules）

### 定义
**不会发生级联回滚的调度，要求：对于冲突的事务对{T,F}，F先执行write(Q)并提交后，T再执行read(Q)并提交。**

- 核心规则：不允许读取未提交的数据，**仅能读取已提交的数据**。
- 特性：所有无级联调度**都是可恢复的，是更优的调度类型**。



# 可恢复调度（Recoverable Schedule）
**可恢复调度**是数据库并发调度正确性的重要准则之一，核心目标是 **避免事务故障时出现数据不一致**，确保故障事务回滚后，其他事务可以正确恢复，不会保留“脏数据”或错误结果。

它的定义和规则围绕**事务的提交顺序**和**脏读（Dirty Read）的处理**展开，是比可串行化更基础的正确性要求。

> ## 一、 核心概念与定义
> ### 1.  基础前提：脏读与事务依赖
> 要理解可恢复调度，首先要明确两个关键概念：
> - **脏读**：事务T2读取了事务T1修改但**未提交**的数据，之后T1发生故障**回滚**，导致T2读取的是无效的“脏数据”。
> - **数据依赖**：若事务T2读取了T1修改的数据，则称 `T2依赖于T1`，记为 `T1 → T2`。
>
> ### 2.  可恢复调度的严格定义
> 对于一个并发调度中的所有事务，**如果任意事务T2依赖于事务T1（T2读了T1的未提交数据），那么T1必须在T2提交之前提交**，则称该调度为**可恢复调度**。
>
> 简单来说：**先提交“写数据的事务”，再提交“读该数据的事务”**。
> 这样的规则能保证：如果写数据的事务T1回滚，读数据的事务T2还未提交，可以跟着回滚，避免脏数据被永久保存。
>
> ## 二、 典型示例：可恢复 vs 不可恢复
> 假设存在两个事务：
> - T1：修改数据x（`WRITE(x)`） → 故障回滚（`ABORT`）
> - T2：读取T1修改的x（`READ(x)`） → 提交（`COMMIT`）
>
> ### 1.  不可恢复调度（错误案例）
> 调度顺序：`T1: WRITE(x)` → `T2: READ(x)` → `T2: COMMIT` → `T1: ABORT`
> - 问题分析：
>   1. T2读取了T1的未提交数据，形成依赖 `T1→T2`；
>   2. T2在T1提交前就提交了，永久保存了脏数据；
>   3. 后续T1回滚，x的值恢复为修改前的状态，但T2的提交结果无法撤销，导致数据不一致。
>
> ### 2.  可恢复调度（正确案例）
> 调度顺序：`T1: WRITE(x)` → `T2: READ(x)` → `T1: COMMIT` → `T2: COMMIT`
> - 优势分析：
>   1. T2依赖于T1，但T1先提交，确保修改的数据是“有效数据”；
>   2. 即使T1提交后出现故障，x的修改已经生效，T2的读取结果是正确的；
>   3. 若T1在提交前故障回滚，T2尚未提交，只需回滚T2即可，无脏数据残留。
>
> ## 三、 两类特殊的可恢复调度
> 在可恢复调度的基础上，还有两个更严格的调度规则，用于进一步降低故障恢复的复杂度：
>
> ### 1.  无级联调度（Cascadeless Schedule）
> #### 定义
> 一个可恢复调度中，**所有事务只能读取已提交事务的数据**，不允许读取未提交的数据（即完全避免脏读）。
>
> #### 核心优势
> - 彻底消除了“级联回滚”的风险：级联回滚指一个事务回滚导致依赖它的多个事务依次回滚（比如 T1回滚 → T2回滚 → T3回滚）。
> - 故障恢复简单：只需回滚发生故障的事务本身，无需影响其他事务。
>
> #### 示例（无级联调度）
> `T1: WRITE(x)` → `T1: COMMIT` → `T2: READ(x)` → `T2: COMMIT`
>
> ### 2.  严格调度（Strict Schedule）
> #### 定义
> 一个无级联调度中，**事务T1修改的数据，在T1提交或回滚之前，其他任何事务都不能对该数据执行写操作**（读操作也只能读已提交数据）。
>
> #### 核心优势
> - 不仅避免脏读，还避免了**不可重复读**和**覆盖未提交数据**的问题；
> - 是数据库中最容易实现的调度规则（比如基于**严格两阶段锁（Strict 2PL）** 的并发控制，天然满足严格调度）。
>
> #### 示例（严格调度）
> `T1: WRITE(x)` → `T1: COMMIT` → `T2: WRITE(x)` → `T2: COMMIT`
> （T2必须等T1提交后，才能写x）
>
> ## 四、 调度规则的严格性对比
> 从宽松到严格，调度规则的层级关系为：
> `可串行化调度` ← `可恢复调度` ← `无级联调度` ← `严格调度`
>
> | 调度类型       | 核心要求                                  | 故障恢复难度 | 并发效率 |
> |----------------|-------------------------------------------|--------------|----------|
> | 可恢复调度     | 依赖事务先提交                            | 中等（可能级联回滚） | 高       |
> | 无级联调度     | 禁止脏读，依赖事务先提交                  | 低（无关联回滚） | 中       |
> | 严格调度       | 禁止脏读+禁止写未提交数据                  | 极低 | 低       |
>
> ## 五、 与可串行化的关系
> 1. **可恢复调度 ≠ 可串行化调度**：
>    - 可恢复调度只保证故障时数据可恢复，不保证并发执行结果等价于串行执行；
>    - 可串行化调度是正确性的最高标准，但**不一定是可恢复的**（需要额外约束提交顺序）。
> 2. **数据库的理想目标**：
>    实际应用中，数据库会追求 **“可串行化 + 严格调度”** 的并发控制策略，既保证结果正确，又简化故障恢复（比如 InnoDB 的默认隔离级别 `REPEATABLE READ` 就满足可串行化和严格调度的核心特性）
>





## 并发控制（Concurrency Control）
### 调度的核心要求
1. **冲突可串行化或视图可串行化（保证隔离性）；**
2. **可恢复（保证一致性）；**
3. **优选无级联（降低回滚开销）。**



### 并发控制协议的目标
开发并发控制协议，**确保调度满足上述要求**，而非事后检测可串行性。



### 权衡关系
并发控制协议需在允许的并发度和自身开销之间权衡：
1. 仅允许串行执行事务：开销低，但并发度极差；
2. 部分协议仅允许冲突可串行化调度，部分允许非冲突可串行化的视图可串行化调度。



### 弱一致性级别（Weak Levels of Consistency）
部分应用可接受非可串行化的弱一致性，以换取性能提升：
- 示例：只读事务获取账户余额的近似总和、查询优化所需的数据库统计信息（允许近似）。



## SQL-92中的隔离级别
1. **可串行化（Serializable）**：默认级别，严格保证隔离性。
2. **可重复读（Repeatable Read）**：仅读取已提交记录，对同一记录的多次读取返回相同值。
3. **读已提交（Read Committed）**：仅读取已提交记录，但同一记录的多次读取可能返回不同的已提交值。
4. **读未提交（Read Uncommitted）**：允许读取未提交记录，一致性最低。

### 注意事项
部分数据库系统默认不保证可串行化（如Oracle、PostgreSQL默认支持“快照隔离”，非SQL标准），需手动配置隔离级别。



## SQL中的事务定义
### 事务的启动与结束
1. 启动：SQL中事务隐式启动（执行第一条SQL语句时）。
2. 结束：
   - 提交：`COMMIT WORK`，提交当前事务并启动新事务；
   - 中止：`ROLLBACK WORK`，回滚当前事务。

### 隐式提交
几乎所有数据库系统**默认每条SQL语句执行成功后自动提交**，可通过数据库指令关闭（如JDBC中`connection.setAutoCommit(false)`）。
