# 第16章：恢复系统（Recovery System）
## 章节概述
故障分类、存储结构、恢复与原子性、基于日志的恢复

## 故障分类（Failure Classification）
### 事务故障（Transaction Failure）
1. 逻辑错误：**事务因内部错误无法完成**（如账户A余额不足，无法完成扣款）。
2. 系统错误：数据库系统**因异常条件终止活动事务**（如死锁）。

### 系统崩溃（System Crash）
- 成因：电源故障、软硬件故障**导致系统停止运行。**
- 假设：**非易失性存储内容不会因系统崩溃损坏**（数据库系统通过完整性检查防止磁盘数据损坏）。

### 磁盘故障（Disk Failure）
- 成因：**磁头碰撞等硬件故障导致部分或全部磁盘存储损坏**。
- 检测：磁盘驱动器**通过校验和检测数据损坏**。

## 恢复算法
### 事务场景
以事务Ti为例，其功能是将50美元从账户A转账至账户B，执行步骤如下：
1. 读取账户A的余额（read(A)）
2. 账户A余额减去50美元（A := A – 50）
3. 写入更新后的账户A余额（write(A)）
4. 读取账户B的余额（read(B)）
5. 账户B余额加上50美元（B := B + 50）
6. 写入更新后的账户B余额（write(B)）

### 事务执行的核心要求
事务Ti需要将对A和B的更新均输出到数据库，才能完成完整转账。

### 潜在风险
1. 部分修改生效风险：若故障发生在步骤3之后、步骤6之前，仅账户A的余额被扣除，账户B的余额未增加，导致数据库处于不一致状态（资金“丢失”）。
2. 更新丢失风险：若事务已提交，但修改未及时写入数据库，后续发生故障会导致已提交的更新丢失。

### 恢复算法的组成
恢复算法需通过两部分操作**保障事务的原子性、一致性和持久性**：
1. 正常事务处理阶段：记录足够的**恢复信息**，确保故障后**可追溯修改过程**。
2. 故障后恢复阶段：通过已记录的信息，将数据库**恢复到符合ACID特性的一致状态**。



## 存储结构（Storage Structure）

### 三类存储介质
1. **易失性存储（Volatile Storage）**：不存活系统崩溃，示例：主存、缓存。
2. **非易失性存储（Nonvolatile Storage）**：存活系统崩溃但可能故障，示例：磁盘、磁带、闪存、电池备份RAM。
3. **稳定存储（Stable Storage）**：理论上可抵御所有故障，通过**在不同非易失性介质上维护多份副本近似实现**。

### 稳定存储的实现
1. 核心方案：为每个数据块**在独立磁盘上维护多份副本**（可跨异地存储，抵御火灾、洪水等灾难）。
2. 数据传输故障处理：
   - 正常写流程：先写入第一份副本，成功后写入第二份，两次写入均成功才算输出完成。
   - 不一致副本恢复：
     - 检测：通过非易失性存储记录进行中的磁盘写操作，**故障后仅校验这些可能不一致的块**（替代全量对比）。
     - 修复：若副本校验和错误，用另一份副本覆盖；若均无错误但内容不同，用第一份副本覆盖第二份。

## 数据访问（Data Access）
### 核心概念
- 物理块：存储在磁盘上的块。
- 缓冲块：临时存储在主存中的块。
- 数据传输操作：
  - `input(B)`：将**物理块B加载到主存缓冲块**。
  - `output(B)`：将**缓冲块B写入磁盘，覆盖对应物理块**。
- 简化假设：每个数据项可完整存储在一个块中。

### 事务数据访问流程
1. 每个事务Ti有私有工作区，存储访问数据项的本地副本（如数据项X的本地副本为xi）。
2. 数据传输指令：
   - `read(X)`：将**缓冲块中X的值赋给本地副本xi**（首次访问需先执行`input`加载块）。
   - `write(X)`：将**本地副本xi的值赋给缓冲块中的X**（无需立即执行`output`，系统可延迟写入磁盘）。
3. 约束：事务需先执行`read(X)`才能首次访问X，`write(X)`可在提交前任意时刻执行（即写回磁盘）。

## 恢复与原子性（Recovery and Atomicity）
### 核心目标
确保事务原子性，即使发生故障，**要么所有操作生效，要么全部失效**。

### 实现核心
通过**稳定存储的修改记录信息（而非直接修改数据库）**，基于日志的恢复机制是主流方案，先介绍核心概念，再详细说明恢复算法。

## 基于日志的恢复（Log-Based Recovery）
### 日志（Log）的定义与作用
日志是存储在稳定存储上的**序列日志记录，记录数据库的所有更新活动，确保故障后可追溯修改过程**。

### 日志记录类型
1. 事务开始记录：`<Ti start>`（事务Ti启动时写入）。
2. 更新记录：`<Ti, X, V1, V2>`（Ti执行`write(X)`前写入，V1为X的旧值，V2为新值）。
3. 事务提交记录：`<Ti commit>`（Ti完成所有语句后写入）。

### 事务提交的定义
当且仅当事务Ti的`<Ti commit>`**记录写入稳定存储，且所有之前的日志记录均已输出**，Ti才算提交（提交时数据更新可能仍在缓冲中，后续延迟写入磁盘）。

### 两种日志恢复方法
#### 方法1：延迟数据库修改（Deferred Database Modification）
1. 核心规则：所有修改仅记录到日志，延迟至事务部分提交（即执行完所有语句）后再实际写入数据库。
2. 正常流程：
   - 启动：写入`<Ti start>`。
   - 更新：执行`write(X)`时，仅写入`<Ti, X, V2>`（无需旧值）。
   - 提交：事务执行完所有语句后（即 `<Ti partially commits>`）将`<Ti commit>`写入日志，**读取日志，并执行所有延迟的写操作**。
3. 故障发生时机：事务正在执行原始更新，且恢复操作正在执行
3. 故障恢复规则：仅当**日志中同时存在`<Ti start>`和`<Ti commit>`**，**才对Ti执行重做（redo）操作。**
4. 示例：
   - 事务T0（A转50到B）：`read(A)→A=A-50→write(A)→read(B)→B=B+50→write(B)`，日志记录为`<T0 start>→<T0, A, 950>→<T0, B, 2050>→<T0 commit>`。
   - 故障场景：
     - 日志仅含`<T0 start>→<T0, A, 950>`：无需重做。
     - 日志含`<T0 start>→<T0, A, 950>→<T0, B, 2050>→<T0 commit>`：重做T0。

#### 方法2：立即数据库修改（Immediate Database Modification）
1. 核心规则：更新记录写入日志后，立即执行写操作（写入缓冲或磁盘），磁盘写入可在提交前后任意时刻，顺序不限。
2. 关键约束：**更新日志记录必须在数据库项修改前写入稳定存储**。
3. 故障恢复操作：
   - 重做（redo(Ti)）：按日志顺序，将Ti修改的所有数据项设为新值V2（幂等操作，表示多次执行，效果一致）。
   - 撤销（undo(Ti)）：逆日志顺序，将Ti修改的所有数据项恢复为旧值V1（幂等操作）。
4. 恢复规则：
   - 需重做：日志含`<Ti start>`和`<Ti commit>/<Ti abort>`。
   - 需撤销：日志含`<Ti start>`，但无`<Ti commit>/<Ti abort>`。
5. 示例：
   - 事务T0日志：`<T0 start>→<T0, A, 1000, 950>→<T0, B, 2000, 2050>→<T0 commit>`。
   - 故障场景：
     - 日志仅含`<T0 start>→<T0, A, 1000, 950>→<T0, B, 2000, 2050>`：撤销T0（A恢复1000，B恢复2000）。
     - 日志含`<T0 start>→<T0, A, 1000, 950>→<T0, B, 2000, 2050>→<T0 commit>→<T1 start>→<T1, C, 700, 600>`：重做T0，撤销T1（C恢复700）。

> # 两种日志恢复方法：延迟数据库修改 & 立即数据库修改
> 数据库的日志恢复机制是**崩溃恢复**的核心，其目标是在系统故障（如断电、宕机）后，将数据库恢复到**一致性状态**，保证事务的原子性和持久性。
> **延迟数据库修改（Deferred Database Modification）** 和 **立即数据库修改（Immediate Database Modification）** 是两种经典的恢复策略，核心区别在于**事务执行过程中，何时将数据修改写入磁盘数据库**。
>
> 二者都依赖 **事务日志**（Transaction Log），日志会记录事务的关键操作（如开始、修改、提交/回滚），是故障恢复的唯一依据。日志的写入遵循 **先写日志（WAL, Write-Ahead Log）** 原则：**日志记录必须先于数据修改写入磁盘**，**确保故障后能通过日志重建状态**。
>
> ## 一、 延迟数据库修改（Deferred Modification）
> ### 1.  核心思想
> 事务执行过程中，**所有数据修改仅作用于内存缓冲区**，不直接写入磁盘数据库；只有当事务执行到 **COMMIT（提交）** 阶段时，才一次性将所有修改从缓冲区写入磁盘。
> 简单来说：**内存修改延迟到事务提交后才持久化**。
>
> ### 2.  日志记录内容
> 延迟修改的日志只记录 **“重做（Redo）”** 信息，无需记录“撤销（Undo）”信息，日志条目格式通常为：
> ```
> <Ti, START>        —— 事务Ti开始
> <Ti, X, V1>        —— 事务Ti将数据项X的值修改为V1（仅记录最终修改结果）
> <Ti, COMMIT>       —— 事务Ti提交成功
> ```
> - 无Undo日志的原因：事务提交前，磁盘数据库未被修改，故障后只需放弃未提交事务的内存修改，无需撤销。
>
> ### 3.  事务执行流程
> 假设事务`T1`要将数据项`X`的值从`50`改为`100`：
> 1.  **事务开始**：写入日志 `<T1, START>` 到磁盘（遵循WAL）。
> 2.  **内存修改**：从磁盘读取`X`到内存缓冲区，修改为`100`（仅在内存生效，磁盘`X`仍为`50`）。
> 3.  **写入重做日志**：写入日志 `<T1, X, 100>` 到磁盘。
> 4.  **事务提交**：
>     - 先写入日志 `<T1, COMMIT>` 到磁盘；
>     - 再将缓冲区中`X`的新值`100`一次性写入磁盘数据库。
> 5.  **事务结束**：释放资源，清除缓冲区临时数据。
>
> ### 4.  故障恢复流程
> 系统崩溃后重启，恢复程序扫描日志文件，执行**重做（Redo）操作**，分为两步：
> 1.  **扫描日志，标记提交事务**：找出所有包含 `<Ti, COMMIT>` 的事务（如`T1`），这些是需要持久化的事务。
> 2.  **重做已提交事务**：对每个已提交事务，根据日志中的`<Ti, X, V>`记录，将数据项`X`的值更新为`V`（写入磁盘）。
> 3.  **忽略未提交事务**：未包含`<Ti, COMMIT>`的事务（如只写到`<T2, START>`的`T2`），直接丢弃其内存修改，无需处理。
>
> ### 5.  核心特点
> | 优点 | 缺点 |
> |------|------|
> | 恢复逻辑简单，仅需Redo，无需Undo | 事务提交前，所有修改都在内存，缓冲区压力大 |
> | 磁盘I/O次数少（提交时一次性写入） | 并发度低，长时间占用缓冲区，其他事务无法访问修改的数据 |
> | 无需记录Undo日志，日志体积小 | 仅支持**重做**，不支持事务执行过程中的回滚（Rollback） |
>
> ### 6.  适用场景
> 适合**短事务、只读事务为主**的场景，或对恢复逻辑简洁性要求高的小型数据库。
>
> ## 二、 立即数据库修改（Immediate Modification）
> ### 1.  核心思想
> 事务执行过程中，**数据修改会立即写入磁盘数据库**（或至少写入磁盘缓冲区），无需等待事务提交。
> 为了支持事务回滚和故障恢复，日志需要同时记录 **重做（Redo）** 和 **撤销（Undo）** 信息。
> 简单来说：**修改实时持久化，日志同时记录新旧值，支持双向恢复**。
>
> ### 2.  日志记录内容
> 立即修改的日志需要记录数据项的**旧值（用于Undo）** 和 **新值（用于Redo）**，日志条目格式通常为：
> ```
> <Ti, START>        —— 事务Ti开始
> <Ti, X, V_old, V_new> —— 事务Ti将X从旧值V_old改为新值V_new
> <Ti, COMMIT>       —— 事务Ti提交
> <Ti, ABORT>        —— 事务Ti回滚
> ```
> - **Redo**：故障后，对已提交事务，按日志将X恢复为`V_new`；
> - **Undo**：故障后，对未提交事务，按日志将X恢复为`V_old`。
>
> ### 3.  事务执行流程
> 仍以事务`T1`修改`X`（50→100）为例：
> 1.  **事务开始**：写入日志 `<T1, START>` 到磁盘（WAL原则）。
> 2.  **读取旧值**：从磁盘读取`X=50`到内存，记录旧值。
> 3.  **写入日志**：写入日志 `<T1, X, 50, 100>` 到磁盘（先写日志，再改数据）。
> 4.  **立即修改磁盘**：将内存中`X=100`写入磁盘数据库（或磁盘缓冲区，由操作系统保证刷盘）。
> 5.  **事务提交**：写入日志 `<T1, COMMIT>` 到磁盘，标记事务完成；释放相关锁资源。
>
> #### 额外场景：事务回滚（Rollback）
> 若`T1`执行过程中需要回滚（如执行失败），则：
> 1.  写入日志 `<T1, ABORT>` 到磁盘；
> 2.  根据日志中的旧值`50`，将`X`恢复为`50`（Undo操作）；
> 3.  写入回滚完成日志，释放资源。
>
> ### 4.  故障恢复流程
> 系统崩溃后重启，恢复程序需要执行 **Undo + Redo** 两步操作，分为三个阶段：
> 1.  **分析阶段（Analysis Phase）**
>     - 扫描日志，从最后一个检查点（Checkpoint）开始，标记两类事务：
>       - **已提交事务**：有`<Ti, COMMIT>`记录，需要Redo；
>       - **未提交事务**：只有`<Ti, START>`，无`<Ti, COMMIT>`，需要Undo。
>     - 记录每个数据项的最新修改状态。
>
> 2.  **撤销阶段（Undo Phase）**
>     - 对所有未提交事务，**逆序扫描日志**，执行Undo操作：将数据项恢复为日志中的旧值`V_old`。
>     - 例如：未提交事务`T2`修改了`X`，则按日志将`X`改回旧值。
>     - **写入Undo完成日志，标记这些事务为“已撤销”**。
>
> 3.  **重做阶段（Redo Phase）**
>     - 对所有已提交事务，**顺序扫描日志**，执行Redo操作：将数据项更新为日志中的新值`V_new`。
>     - 目的：**确保已提交事务的修改全部持久化**（可能部分修改因故障未写入磁盘）。
>
> ### 5.  核心特点
> | 优点 | 缺点 |
> |------|------|
> | 支持事务执行过程中的回滚（Rollback） | 恢复逻辑复杂，需要同时处理Undo和Redo |
> | 并发度高，修改实时写入磁盘，缓冲区占用时间短 | 日志体积大，需同时记录新旧值 |
> | 数据修改实时持久化，降低缓冲区溢出风险 | 磁盘I/O次数多（每次修改都要写日志+写数据） |
>
> ### 6.  适用场景
> 适合**长事务、读写混合事务为主**的场景，是现代数据库（如MySQL InnoDB、Oracle）的默认恢复策略。
>
> ## 三、 延迟修改 vs 立即修改 核心对比
> | 特性 | 延迟数据库修改 | 立即数据库修改 |
> |------|----------------|----------------|
> | **修改写入时机** | 事务提交后一次性写入磁盘 | 事务执行过程中实时写入磁盘 |
> | **日志类型** | 仅Redo日志 | Redo + Undo日志 |
> | **恢复操作** | 仅需Redo | Undo + Redo |
> | **事务回滚支持** | 不支持（提交前无磁盘修改） | 支持（通过Undo日志恢复旧值） |
> | **磁盘I/O频率** | 低（提交时一次I/O） | 高（每次修改都有I/O） |
> | **并发度** | 低 | 高 |
> | **现代数据库支持** | 极少使用 | 主流默认方案 |
>
> ## 四、 关键补充：检查点（Checkpoint）的作用
> 两种恢复方法都依赖**检查点机制**优化恢复效率：
> - 检查点是定期触发的操作，会将内存中所有脏数据（已修改未刷盘）写入磁盘，并记录当前日志的位置。
> - 故障恢复时，无需扫描全部日志，只需从**最近的检查点**开始扫描，大幅缩短恢复时间。
> - 延迟修改中，检查点主要用于清理缓冲区；立即修改中，检查点是恢复的核心起点。
>

#### 两种方法对比

| 特性 | 延迟数据库修改 | 立即数据库修改 |
| ---- | ---- | ---- |
| 修改执行时机 | **事务提交后** | **日志写入后立即执行** |
| 日志记录 | 无需旧值 | 需包含旧值和新值 |
| 恢复操作 | 仅重做 | 重做+撤销 |
| 内存开销 | 较高（需缓存所有修改） | 较低 |

后续介绍的算法均基于**立即数据库修改**。

## 并发事务的恢复考量
1. 共享资源：所有事务共享磁盘缓冲和单一日志，缓冲块可能包含多个事务的修改。
2. 隔离要求：未提交事务的更新不可被其他事务可见（通过严格两阶段锁实现：更新数据项加排他锁，直至事务提交/中止）。
3. 日志特点：不同事务的日志记录可能交错存储。

## 撤销与重做操作细节（Undo and Redo Operations）
### 重做（Redo）
- 日志记录`<Ti, X, V1, V2>`：将X的值设为新值V2**，无需写入日志。**
- 事务级重做（redo(Ti)）：**按日志顺序**，执行Ti的所有更新记录。

### 撤销（Undo）
- 日志记录`<Ti, X, V1, V2>`：将X的值恢复为旧值V1，**写入补偿日志记录`<Ti, X, V1>`。**
- 事务级撤销（undo(Ti)）：**逆日志顺序**，执行Ti的所有更新记录的撤销，**完成后写入`<Ti abort>`**。

## 检查点（Checkpoints）
### 核心作用
减少恢复时的**日志扫描范围**，提升恢复效率（避免全量扫描长期运行的日志）。

### 检查点执行流程
1. 暂停所有更新操作。
2. 将主存中的**所有日志记录写入**稳定存储。
3. 将**所有修改后的缓冲块写入**磁盘。
4. 写入日志记录`<checkpoint L>`（L为检查点时刻所有活跃的事务列表）。

### 检查点后的恢复规则
1. 扫描日志找到**最近的`<checkpoint L>`**。
2. 仅需处理：L中的事务 + 检查点后启动的事务（检查点前已提交/中止的事务，更新已写入磁盘，无需处理）。
3. 日志清理：可删除最早活跃事务`<Ti start>`之前的日志记录。

### 示例
- 检查点时刻活跃事务为{T1}，后续启动T2、T3、T4，系统崩溃时T2、T3已提交，T4活跃。
- 恢复处理：忽略T1（更新已写入磁盘），重做T2、T3，撤销T4。

## 恢复算法（Recovery Algorithm）
### 正常运行时的日志操作
1. 事务启动：写入`<Ti start>`。
2. 事务更新：执行`write(X)`时，写入`<Ti, X, V1, V2>`。
3. 事务提交：写入`<Ti commit>`。
4. 事务回滚（正常运行时）：
   - 逆日志顺序扫描Ti的更新记录，执行撤销（写入旧值V1），并**写入补偿日志记录`<Ti, X, V1>`**。
   - 扫描到`<Ti start>`后，**写入`<Ti abort>`**。

### 故障恢复流程（两阶段）
#### 第一阶段：重做阶段（Redo Phase）
1. 找到最近的`<checkpoint L>`，初始化`undo-list = L`。
2. 从`<checkpoint L>`开始正向扫描日志：
   - 遇到`<Ti, X, V1, V2>`：执行重做（X设为V2）。
   - 遇到`<Ti start>`：将Ti加入`undo-list`。
   - 遇到`<Ti commit>`或`<Ti abort>`：将Ti从`undo-list`移除。
3. 核心目标：重演所有已完成（提交/中止）和未完成事务的更新，同时确定需撤销的事务（`undo-list`中剩余事务）。

#### 第二阶段：撤销阶段（Undo Phase）
1. 从日志末尾反向扫描：
   - 遇到`<Ti, X, V1, V2>`且Ti在`undo-list`：执行撤销（X设为V1），写入补偿日志记录`<Ti, X, V1>`。
   - 遇到`<Ti start>`且Ti在`undo-list`：写入`<Ti abort>`，将Ti从`undo-list`移除。
2. 停止条件：`undo-list`为空。
3. 核心目标：撤销所有未完成事务的更新，恢复数据库一致性。

## 第16章结束