# Ch13

## 1. 引言
- 评估==给定查询的多种替代方式==
  - 等价表达式
  - 同一操作可采用不同算法
- 评估计划：明确**每个操作所用算法**及操作执行的**协调方式**
- 评估计划的成本差异：不同计划的执行成本可能极为悬殊（例如：几秒 vs. 几天）
- 基于成本的查询优化步骤：
  1. 利用==等价规则==生成==逻辑等价表达式==
  2. 为结果表达式**添加注解**，得到**替代查询计划**（Annotate resultant expressions to get alternative query plans）
  3. 基于**估算成本**选择最优计划
- 计划成本估算依据：
  1. **关系**的统计信息（如元组数量、属性的不同值数量等）
  2. **中间结果**的统计信息估算（用于计算复杂表达式的成本）
  3. 利用统计信息计算的**算法成本公式**



## 2. 关系表达式的转换
### 2.1 等价关系
- 两个关系代数表达式等价：在**每个合法数据库实例上生成相同的元组集合**（元组顺序无关）
- SQL中的等价：输入和输出均为元组的多重集合，等价指在**每个合法数据库实例上生成相同的元组多重集合**
- 等价规则：规定两种形式的表达式等价，**可相互替换**

### 2.2 等价规则
1. 合取选择操作可分解为一系列单独的选择操作
   $$
   \sigma_{\theta_1 \and \theta_2}(E) = \sigma_{\theta_1}(\sigma_{\theta_2}(E))
   $$

2. 选择操作具有交换性：
   $$
   \sigma_{\theta_1}(\sigma_{\theta_2}(E)) = \sigma_{\theta_2}(\sigma_{\theta_1}(E))
   $$

3. 投影操作序列中**仅需保留最后一个**，其余可省略：
   $$
   \prod_{L_1}(\prod_{L_2}(...(\prod_{L_n}(E))...))= \prod_{L_1}(E)
   $$

4. 选择操作可与笛卡尔积和 $\theta$ 连接结合：
   - $$
     E_1 \bowtie_{\theta} E_2 = \sigma_{\theta}(E_1 \times E_2)
     $$
     
     ==这个本身就是 **$\theta$ 连接** 的定义来着==。
     
   - $$
     \begin{aligned}
     &\sigma_{\theta_1}(E_1 \bowtie_{\theta_2} E_2) = E_1 \bowtie_{\theta_1 \and \theta_2} E_2 \\
     \text{proof:}& \\
     &\sigma_{\theta_1}(E_1 \bowtie_{\theta_2} E_2) = \sigma_{\theta_1}(\sigma_{\theta_2}(E_1 \times E_2)) = \sigma_{\theta_1 \and \theta_2}(E_1 \times E_2) = E_1 \bowtie_{\theta_1 \and \theta_2} E_2
     \end{aligned}
     $$

5. $\theta$ 连接（含自然连接）具有交换性：
   $$
   E_1 \bowtie_{\theta} E_2 = E_1 \bowtie_{\theta} E_2
   $$

6. 连接的结合性：
   - (a) 自然连接具有结合性：
     $$
     (E_1 \bowtie E_2) \bowtie E_3 = E_1 \bowtie (E_2 \bowtie E_3)
     $$

   - (b) ==$\theta$ 连接的结合性：==
     $$
     (E_1 \bowtie_{\theta_1}E_2) \bowtie _{\theta_2 \and \theta_3}E_3= E_1 \bowtie_{\theta_1 \and \theta_3} (E_2 \bowtie_{\theta2} E_3)
     \\
     \theta_2 \text{ involves atrributes from only } E_2 \text{ and } E_3.
     $$

7. **选择操作对 $\theta$ 连接的分配律：**==对应下推选择操作，及早执行 选择操作==

   - (a) 若 $\theta_0$ 的所有属性仅涉及连接表达式中的一个（如 $E_1$），则
     $$
     \sigma_{\theta_0}(E_1 \bowtie_{\theta}E_2) = \sigma_{\theta_0}(E_1) \bowtie_{\theta} E_2
     $$

   - (b) 若 $\theta_1$ 仅涉及 $E_1$ 的属性，$\theta_2$ 仅涉及 $E_2$的属性，则：
     $$
     \sigma_{\theta_1 \and \theta_2}(E_1 \bowtie_{\theta} E_2) = (\sigma_{\theta1}(E_1)) \bowtie (\sigma_{\theta_2}(E_2))
     $$

8. **投影操作对 $\theta$ 连接的分配律：**==对应下推投影操作，尽早执行 投影操作==

   - 设 $L_1$ 和 $L_2$ 分别为 $E_1$ 和 $E_2$ 的属性集（==注意不是整个集合，只是一部分，即子集==），这两个是最终要投影的属性。

   - (a) 若 $\theta$ 仅涉及 $L1 \cup L_2$ 中的属性，则：
     $$
     \prod_{L_1 \cup L_2}(E_1 \bowtie_{\theta} E_2)= \prod_{L_1}(E_1) \bowtie_{\theta}\prod_{L_2}(E_2)
     $$

   - (b) **更加一般化，**设 $L_3 $是  $E_1$ 中参与连接条件 $\theta$ 但不在 $L_1 \cup L_2$ 中的属性，$L_4$ 是 $E_2$ 中参与连接条件 $\theta$ 但不在 $L_1 \cup L_2$ 中的属性），则：
     $$
     \prod_{L_1 \cup L_2} (E_1 \bowtie_{\theta}E_2)=\prod_{L_1 \cup L_2} ((\prod_{L_1 \cup L_3}(E_1)) \bowtie_{\theta}(\prod_{L_2 \cup L_4}(E_2)))
     $$

9. 集合操作的交换性（并、交）：

   - $$
     E_1 \cup E_2 = E_2 \cup E_1
     $$

   - $$
     E_1 \cap E_2 = E_2 \cap E_1
     $$

   - （差操作不具有交换性）

10. 集合操作的结合性（并、交）：
    - $$
      (E_1 \cup E_2) \cup E_3 = E_1 \cup (E_2 \cup E_3) \\
      (E_1 \cap E_2) \cap E_3 = E_1 \cap (E_2 \cap E_3)
      $$

11. 选择操作对集合操作（并、交、差）的分配律：
    - $$
      \sigma_{\theta}(E_1 - E_2) = \sigma_{\theta}(E_1) - \sigma(E_2)
      $$

      （并、交操作同理）

    - $$
      \sigma_{\theta}(E_1-E_2)= \sigma_{\theta}(E_1) -E_2
      $$

      （交操作同理，但并操作不适用）

12. 投影操作对并操作的分配律：
    $$
    \prod_{L}(E_1 \cup E_2)=(\prod_L(E_1)) \cup (\prod_L(E_2))
    $$

### 2.3 转换示例
#### 示例1：下推选择操作
- 优势：**尽早执行选择操作**，减少参与连接的关系大小

#### 示例2：多重转换
#### 示例3：下推投影操作
- 优势：**尽早执行投影操作**，减少参与后续连接的关系大小

#### 示例4：连接顺序选择
- 连接结合性：对于任意关系 $R_1, R_2, R_3$，
  $$
  (R_1 \bowtie R_2)\bowtie R_3 = R_1 \bowtie (R_2 \bowtie R_3)
  $$

- 选择依据：若 $R_2 \bowtie R_3$ 结果较大，而 $R_1 \bowtie R_2$ 结果较小，则选择 $(R_1 \bowtie R_2)\bowtie R_3$，以减少临时关系的存储和处理成本



### 2.4 等价表达式的枚举
- 基本方法：查询优化器利用**等价规则**，系统地生成与给定表达式等价的所有表达式
  - 重复：对已找到的**每个等价表达式**的所有**子表达式**应用**所有适用的等价规则**，将新生成的表达式加入等价表达式集合
  - 终止：无新的等价表达式生成
- 问题：上述方法时空开销极大
- 优化方案：
  1. 基于**转换规则**的优化计划生成
  2. 针对**仅含选择、投影和连接**的查询的特殊处理方法
  3. 共享公共子表达式（通过指针共享相同子树，减少空间占用）
  4. 动态规划（避免生成所有表达式，降低时间开销）



## 3. 成本估算的统计信息
### 3.1 基本统计信息
- $n_r$：关系 $r$ 中的元组数量
- $b_r$：关系 $r$ 占用的块数
- $l_r$：关系 $r$ 中每个元组的大小
- $f_r$：关系 $r$ 的块因子（一个块中可容纳的元组数量）
- 若关系 $r$ 的元组物理上连续存储在一个文件中，则 $b_r ≈ \lceil n_r / f_r \rceil$（向上取整）
- $V(A, r)$：属性 $A$ 在关系 $r$ 中出现的不同值的数量（即 $\prod_A r$ 的大小）



### 3.2 直方图
- 用途：更精确地**估算属性值的分布**
- 类型：
  - 等宽直方图：将**属性值范围划分为等宽**的区间
  - 等深直方图：**每个区间包含相同数量**的元组
- 示例：关系person中属性age的直方图



### 3.3 选择操作的大小估算
#### 3.3.1 简单选择
- 等值选择（$\sigma_{A=v}(r)$）：
  - 假设均匀分布：估算结果元组数量 = $n_r / V(A, r)$ ，即**符合选择目标的元组数量**
  - 若 $A$ 是关键字（Key，不可重复）属性：估算结果元组数量 = 1
- 范围选择（$\sigma_{A \leq v}(r)$ 或 $\sigma_{A \geq v}(r)$，对称）：
  - 定义 $c$ 为**预测的符合条件的元组数量**。
  - 已知属性 $A$ 的最小值 $\min(A, r)$和最大值 $\max(A, r)$：
    - 若 $v < \min(A, r)$：$c$ = $0$
    - 若 $v > \max(A, r)$：$c$ = $n_r$
    - 否则：估算结果元组数量 = $n_r \cdot \frac{v- \min(A,r)}{\max(A,r)-\min(A,r)}$
  - 有直方图时：可细化上述估算
  - 无统计信息时（即 $v$ 未知）：默认估算结果元组数量 = $n_r / 2$



#### 3.3.2 复杂选择
- 选择性：条件 $\theta_i$ 的选择性是关系 $r$ 中满足 $\theta_i$ 的元组的概率，即 $s_i /n_r$（ $s_i$ 为满足条件的元组数量）

- 合取条件 $\sigma_{\theta_1 \and \theta_2 \and ... \theta_n}(r)$：假设条件独立，估算结果元组数量为：
  $$
  n_r \cdot \frac{s_1 \cdot s_2 \cdot ... \cdot s_n}{n^n_r}
  $$

- 析取条件 $\sigma_{\theta_1 \or \theta_2 \or ... \or \theta_n}(r)$：估算结果元组数量为：
  $$
  n_r \cdot (1-(1- \frac{s_1}{n_r})\cdot (1-\frac{s_2}{n_r})\cdot...(1-\frac{s_n}{n_r}))
  $$

- 否定条件$\sigma_{\urcorner \theta}(r)$：估算结果元组数量：$n_r-size(\sigma_{\theta}(r))$ 



### 3.4 连接操作的大小估算

#### 3.4.1 基本情况
- 笛卡尔积 $r \times s$：元组数量 $ n_r \times n_s$，每个元组大小为 $ l_r + l_s$。

- 若$R \cap S=\empty$（$R,S$为$r,s$的属性集），则自然连接 $r \bowtie s$ 等价于笛卡尔积 $r \times s$

- 若 $R \cap S$ 是 $R$ 的 **Key**，则 $s$ 的每个元组**最多与 $r$ 的一个元组连接**，此时：
  $$
  |r \bowtie s|\leq |s|
  $$
  
- 若 $R \cap S$是 $s$ 中引用 $r$ 的**外键**，则：
  $$
  |r \bowtie s| =|s|
  $$
  类似的，可以对称得到 $r$ 中引用 $s$ 的外键的结论。

#### 3.4.2 一般情况（$R\cap S={A}$，且 $A$ 非 $r$ 或 $s$ 的关键字）

- 估算公式1（假设 $r$ 的每个元组与 $s$ 中 $V(A, s)$个值之一匹配）：
  $$
  |r \bowtie s| ≈ n_r \times n_s / V(A, s)
  $$

- 估算公式2（假设 $s$ 的每个元组与 $r$ 中 $V(A, r)$个值之一匹配）：
  $$
  |r \bowtie s| ≈ n_s \times n_r / V(A, r)
  $$

- 最终估算：取上述两个结果的较小值

- 有直方图时：可按直方图的每个区间应用上述公式，细化估算

#### 3.4.3 示例计算






### 3.5 不同值数量的估算（理解为是关于 $V(A,r)$ 的相关估算）

#### 3.5.1 选择操作（$\sigma_\theta{(r)}$）
- 若 $\theta$ 强制 A 取特定值：$V(A, \sigma_\theta(r)) = 1$
- 若 $\theta$ 强制 A 取指定集合中的值：$V(A, \sigma_{\theta}(r))$ = 指定值的数量
- 若 $\theta$为 A op v：$V(A, \sigma_{\text{A op v}}(r)) ≈ V(A, r) × s$（s为选择条件的选择率）
- 其他情况：$\min(V(A, r), size(\sigma_{\theta}(r))$

#### 3.5.2 连接操作（$r \bowtie s$）
- 若 A 的所有属性来自 $r$ ：
  
  - $$
    V(A, r\bowtie s) = \min(V(A, r), n_{r \bowtie s})
    $$
  
- 若 $A=(A_1, A_2)$，其中 $A_1$ 来自 $r$，$A_2$ 来自 $s$：
  $$
  V(A, r \bowtie s) = \min(V(A_1, r) \times V(A_2 - A_1, s), V(A_1 - A_2, r) \times V(A_2, s), n_{r \bowtie s})
  $$



## 4. 评估计划的选择
### 4.1 评估技术的相互影响
- 独立选择**每个操作的最优算法未必能得到整体最优算法**
  - 示例1：归并连接可能比哈希连接成本高，但能提供排序后的输出，降低外层聚合操作的成本
  - 示例2：嵌套循环连接可支持流水线执行，减少磁盘I/O
- 实际查询优化器的两种核心方法：
  1. **搜索所有可能的计划**，**基于成本选择最优计划**
  2. 利用**启发式规则**选择计划



### 4.2 基于成本的优化
#### 4.2.1 连接顺序优化的复杂度
- $n$ 个关系的连接顺序数量：$(2(n-1))!/(n-1)!$
  - $n=7$ 时，数量为665280
  - $n=10$ 时，数量超过1760亿
- 优化方法：动态规划，仅计算并存储$\{r_1, r_2, ..., r_n\}$ 的每个子集的最优连接顺序，避免重复计算



#### 4.2.2 连接顺序优化算法
- 数据结构：
  ```
  structure bestplan {
      cost;  
      plan;  
  };
  
  bestplan[S].plan	// 连接集合S中所有关系的最优计划
  bestplan[S].cost    // 最优计划的成本
  ```
  
- 算法步骤：
  1. 过程 `findbestplan(S)`：
     - 若`bestplan[S].cost`已计算（非无穷大），返回`bestplan[S]`
     - 若S仅包含一个关系：基于该关系的选择条件和索引，设置 `bestplan[S].plan` 和`bestplan[S].cost`
     - 否则，对 S 的每个非空真子集 S ：
       - `P1 = findbestplan(S1)`
       - `P2 = findbestplan(S - S1)`
       - `A = 连接 P1 和 P2 结果的最优算法`
       - 计算总成本 = `P1.cost + P2.cost + A的成本`
       - 若总成本小于当前 `bestplan[S].cost`，更新`bestplan[S].cost`和`bestplan[S].plan`
     - 返回`bestplan[S]`



#### 4.2.3 优化的成本

- 动态规划的时间复杂度：$O(3^n)$
  - $n=10$时，计算量约为59000（远低于1760亿）
- 空间复杂度：$O(2^n)$



### 4.3 左深连接树
- 定义：每个连接的右输入是一个关系，而非中间连接的结果

  ![image-20251218194217528](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251218194217528.png)

- 优化算法修改：
  - 将"遍历 $S$ 的所有非空真子集 $S_i$"改为"遍历 $S$ 中的每个关系 $r$，令$S_i = S - r$"
  
- 复杂度：
  - 时间复杂度：$O(n\times 2^ⁿ)$
  - 空间复杂度：$O(2^n)$
  
- 适用场景：典型查询的关系数量 $n$ 较小（通常<10），基于成本的优化虽有开销但值得



### 4.4 启发式优化
- 适用场景：降低**基于成本优化的开销**
- 核心规则（通常能提升执行性能，但非绝对）：
  1. **尽早执行选择操作**（减少元组数量）
  2. **尽早执行投影操作**（减少属性数量）
  3. 先执行**限制性最强的选择和连接**操作（即**结果集最小的操作**）
- 实际应用：部分系统仅使用启发式优化，部分系统结合启发式优化与部分基于成本的优化