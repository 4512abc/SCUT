# Ch7

![image-20251127122058105](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251127122058105.png)

![image-20251127132652947](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251127132652947.png)

![image-20251127132705012](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251127132705012.png)



![image-20251127132718394](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251127132718394.png)





# 第7章：实体-关系模型
## 建模
数据库可建模为：
- 实体的集合
- 实体间的关系

**实体**是客观存在且可与其他对象区分的事物。例如：特定的人、公司、事件、植物。

实体具有**属性**。例如：人具有姓名和地址。

**实体集**是**同一类型、拥有相同属性的实体**的集合。例如：所有人的集合、所有公司的集合、所有树木的集合、所有节假日的集合。



## 关系集
### 关系
关系是**多个实体间的关联**，可表示为元组 $ t=(e_1, e_2, …, e_n) $，其中 $ e_1 \in E_1, e_2 \in E_2, …, e_n \in E_n $（$ e_i $ 为实体）。

### 关系集
关系集是 $ n \geq 2 $ 个实体集上的数学关系，可表示为 $ L \subseteq E_1 \times E_2 \times … \times E_n $，包含所有满足 $ e_1 \in E_1, e_2 \in E_2, …, e_n \in E_n $ 的元组 $ t=(e_1, e_2, …, e_n) $。

### 含属性的关系集
**属性**也可作为关系集的特性。例如，教师与学生之间的“指导”（advisor）关系集可包含“日期”（date）属性，用于记录学生开始接受该教师指导的时间。

### 关系集的度
- **二元关系**：涉及两个实体集（度为2），数据库系统中大多数关系集为二元关系。
- 多于两个实体集的关系较少见。例如：学生在教师的指导下参与研究项目，“项目指导”（proj_guide）是教师、学生、项目三个实体集间的三元关系。



## 属性
实体由一组属性描述，这些属性是**该实体集中所有成员共有的描述性特征**。

示例：
- 教师（instructor）=（ID、姓名、街道、城市、薪水）
- 课程（course）=（课程ID、课程名称、学分）

### 域
每个属性的允许值集合。

### 属性类型
1. 简单属性与复合属性
    - 复合属性示例：地址（address）包含街道编号（street_number）、街道名称（street_name）、公寓号（apartment_number）、城市（city）、州（state）、邮政编码（postal_code）；姓名（name）包含名（first_name）、中名首字母（middle_initial）、姓（last_name）。
2. 单值属性与多值属性
    - 多值属性示例：电话号码（phone_numbers）。
3. 派生属性
    - 可通过其他属性计算得出，示例：年龄（age）可由出生日期（date_of_birth）推导。



## 映射基数约束
映射基数约束表示一个实体通过关系集可关联的其他实体的数量，在二元关系集中最常用，主要包括以下类型：
- 一对一
- 一对多
- 多对一
- 多对多

### 映射基数详解
1. 一对一：示例：学生与学生证。注：实体集A和B中可能存在未与另一实体集关联的元素。
2. 一对多：示例：父亲与子女。注：实体集A和B中可能存在未与另一实体集关联的元素。
3. 多对一：示例：多个学生对应一个班级。注：实体集A和B中可能存在未与另一实体集关联的元素。
4. 多对多：示例：学生与课程（一名学生可选多门课程，一门课程可被多名学生选择）。注：实体集A和B中可能存在未与另一实体集关联的元素。

## 键
### 超键
实体集的超键是一个或多个属性的集合，其值**可唯一标识每个实体**。

### 候选键
实体集的**候选键是最小的超键**（即移除任何一个属性后不再是超键）。

示例：
- 教师实体集的候选键为ID。
- 课程实体集的候选键为课程ID（course_id）。

### 主键
若存在多个候选键，需**选择其中一个作为主键**（用于唯一标识实体集中的实体）。

### 关系集的键
**关系集的属性**由**参与关系的各实体集的主键**及**关系自身的描述性属性**组成。

示例：关系 $ r=(s\_ID, I\_ID, date) $（学生ID、教师ID、日期）的**主键规则**：
- 多对多关系：主键为（$ p1, p2 $）（参与关系的两个实体集的主键组合）。
- 一对多关系：主键为“多”侧实体集的主键（$ p2 $）。
- 一对一关系：主键可为任意一侧实体集的主键（$ p1 $ 或 $ p2 $）。

## 冗余属性
假设存在以下实体集和关系：
- 教师（instructor）：属性包括ID、姓名、部门名称（dept_name）、薪水。
- 部门（Department）：属性包括部门名称（dept_name）、办公楼（building）、预算（budget）。
- 关系“教师-部门”（inst_dept）：关联教师与部门。

教师实体集中的“部门名称”（dept_name）属性是冗余的，因为该信息已通过“教师-部门”（inst_dept）关系明确关联，应从教师实体集中移除。但需注意：**在将E-R模型转换为表结构时，某些情况下该冗余属性可能会被重新引入**。



## E-R图
### 基本符号
- 矩形：表示实体集。
- 菱形：表示关系集。
- 实体矩形内列出属性，**下划线标识主键属性**。

### 含复合、多值、派生属性的实体E-R图
| 实体集 | 属性 |
| ---- | ---- |
| 教师（instructor） | ID（主键）、姓名（name，复合属性：名、中名首字母、姓）、地址（address，复合属性：街道编号、街道名称、公寓号、城市、州、邮编）、{电话号码（phone_number，多值属性）}、出生日期（date_of_birth，派生属性年龄的依据） |

### 含属性的关系集E-R图
| 实体集 | 属性 |
| ---- | ---- |
| 教师（instructor） | ID（主键）、姓名（name）、薪水（salary） |
| 学生（student） | ID（主键）、姓名（name）、总学分（tot_cred） |
| 关系集 | 指导（advisor），属性：日期（date） |

### 角色
关系中的实体集可以是相同的，**每个实体集在关系中扮演特定“角色”**（==表示实体集在关系中的定位==）。

示例：课程（course）实体集间的“先修”（prereq）关系，角色标签为“课程ID”（course_id）和“先修课程ID”（prereq_id）。

| 实体集 | 属性 |
| ---- | ---- |
| 课程（course） | 课程ID（course_id，主键）、课程名称（title）、学分（credits） |
| 关系集 | 先修（prereq），角色：课程ID（course_id）、先修课程ID（prereq_id） |

### 基数约束表示
- 有向线（→）：表示“一个”。
- 无向线（—）：表示“多个”。

1. 一对一关系：示例：学生与学生证；教师与学生间的一对一“指导”关系（一名教师最多指导一名学生，一名学生最多被一名教师指导）。
2. 一对多关系：示例：教师与学生间的一对多“指导”关系（一名教师可指导多名学生，一名学生最多被一名教师指导）。
3. 多对一关系：示例：教师与学生间的多对一“指导”关系（一名教师最多指导一名学生，一名学生可被多名教师指导）。
4. 多对多关系：示例：教师与学生间的多对多“指导”关系（一名教师可指导多名学生，一名学生可被多名教师指导）。



### 实体集在关系集中的参与
- 完全参与（双直线标识）：**实体集中的每个实体都至少参与关系集中的一个关系**。示例：“班级（section）”在“班级-课程（sec_course）”关系中为完全参与（每个班级必须关联一门课程）。
- 部分参与：**实体集中的部分实体可能不参与关系集中的任何关系**。示例：“教师”在“指导（advisor）”关系中为部分参与（部分教师可能不指导学生）。



### 基数限制的替代表示
通过数值范围表示基数约束，示例：教师与学生的“指导”关系中，教师侧标注“0..*”（可指导0名或多名学生），学生侧标注“1..1”（必须被1名教师指导）。



### 三元关系E-R图
示例：项目（project）、教师（instructor）、学生（student）间的“项目指导（proj_guide）”三元关系。（看PPT）

### 三元关系的基数约束
- 三元（或更高阶）关系中，**最多允许从关系指向一个实体集的箭头表示基数约束**。示例：从“项目指导（proj_guide）”指向“教师（instructor）”的箭头表示一名学生在一个项目中最多有一名指导教师。
- 禁止多个箭头（避免歧义）：若三元关系R在A、B、C间有指向B和C的箭头，可能存在两种解释：1. 每个A实体关联唯一的B和C实体；2. 每个（A,B）对关联唯一的C实体，且每个（A,C）对关联唯一的B实体。



## ==弱实体集==
### 定义
**无主键的实体集**称为弱实体集，**其存在依赖于标识实体集（强实体集）**。

### 标识关系
- 弱实体集与标识实体集间的关系为“标识关系”，**通常为多对一关系，且弱实体集完全参与该关系**。
- 标识关系在E-R图中用**双菱形表示**。

### 鉴别符（部分键）
弱实体集中用于**区分自身实体的属性集合**，在E-R图中用**虚线下划线标识**。

### 弱实体集的主键
由**标识实体集的主键与弱实体集的鉴别符组合**构成。

示例：“班级（section）”是弱实体集，“课程（course）”是其标识实体集：
- 课程的主键：课程ID（course_id）。
- 班级的鉴别符：班级ID（sec_id）、学期（semester）、年份（year）。
- 班级的主键：（course_id, sec_id, semester, year）。

### 注意事项
弱实体集**无需显式存储标识实体集的主键**（因该信息隐含在标识关系中）。例如，班级实体集不应包含课程ID（course_id），否则“班级-课程（sec_course）”关系会冗余；若显式存储course_id，班级可变为强实体集，但会导致班级与课程的关系被重复存储。



## 关系模式转换

### 核心原则
符合E-R图的数据库可通过一组关系模式表示，**实体集和关系集均需转换为唯一命名的关系模式**，模式包含**若干具有唯一名称的列**（对应属性）（即数据库中的表）。

### 转换步骤
1. 实体集→关系模式
2. 关系集→关系模式
3. 优化：移除冗余模式

### 1. 实体集转换为关系模式
#### 强实体集
- 格式：强实体集名称=（属性1，属性2，…）
- 示例：教师（instructor）=（ID，姓名，街道，城市，薪水）；课程（course）=（课程ID，课程名称，学分）。

#### 弱实体集
- 格式：弱实体集名称=（属性1，属性2，…，p），其中属性1、属性2…为弱实体集自身属性，p为标识强实体集的主键。
- 示例：班级（section）=（course_id，sec_id，semester，year）（course_id为课程实体集的主键）。



### 2. 关系集转换为关系模式
#### 基本规则
**关系模式的属性**包含**参与关系的各实体集的主键及关系自身的描述性属性**。

#### 示例
“指导（advisor）”关系集转换为模式：advisor =（s_id，i_id）（s_id为学生主键，i_id为教师主键）。

#### 关系集的主键规则
- 多对多关系：主键为参与关系的各实体集主键的组合（p1, p2）。
- 一对多关系：主键为“多”侧实体集的主键（p2）。
- 一对一关系：主键可为任意一侧实体集的主键（p1或p2）。

#### 大学数据库关系集转换示例
（看PPT）



### 3. 优化：移除冗余模式
#### 规则1：一对多/多对一关系集
- 若“多”侧**实体集为完全参与**，则必须将**关系集属性**合并至“多”侧**实体集模式**。
- **若“多”侧为部分参与，可合并或不合并**；合并后**未参与关系的实体对应属性值为NULL**。

#### 示例
“教师-部门（inst_dept）”为多对一关系（多名教师对应一个部门），优化后教师模式合并部门名称属性：instructor = {ID，name，dept_name，salary}，移除冗余模式inst_dept。

#### 规则2：一对一关系集
**可选择任意一侧实体集合并关系属性，可优化（合并）或不优化**。

#### 示例
若“教师-办公室”为一对一关系，可将办公室属性合并至教师模式或办公室模式。

#### 规则3：弱实体集的标识关系
弱实体集与标识实体集的**标识关系无需转换（弱实体集已包含标识实体集主键），避免冗余**。

#### 大学数据库优化示例
（看PPT）

### 优化后的大学数据库模式
（看PPT）

### 复合属性与多值属性的处理
#### 复合属性
将复合属性拆分为各组件属性，示例：教师的“姓名（name）”拆分为first_name、middle_initial、last_name；“地址（address）”拆分为street_number、street_name、apt_number、city、state、zip，优化后教师模式为：instructor（ID，first_name，middle_initial，last_name，street_number，street_name，apt_number，city，state，zip，date_of_birth）。

#### 多值属性
- 规则：实体E的多值属性A需单独创建模式EA，格式为EA=（K，A）（K为E的主键）。
- 示例：教师的多值属性“电话号码（phone_number）”创建模式inst_phone=（ID，phone_number），一名教师的多个电话号码对应多条记录（如ID=22222的教师有两个电话号码，对应记录（22222，456-7890）和（22222，123-4567））。
- 特殊优化：若实体仅含主键和一个多值属性（如time_slot实体：time_slot_id为primary key，day、start_time、end_time为多值属性组合），可直接创建模式time_slot（time_slot_id，day，start_time，end_time），**无需单独为多值属性创建模式（注：此时section 模式中的time_slot_id无法作为外键关联）**。



## 设计问题
### 实体集与属性的选择
- 需判断现实世界中的对象**应表示为实体集还是属性**。例如，“电话号码”若需存储额外信息（如号码类型、开通时间）或为多值，则应作为实体集；否则可作为属性。

### 实体集与关系集的选择
- 原则：**用关系集描述实体间发生的“动作”**。例如，学生注册课程的“注册”行为应表示为关系集，而非实体集。

### 二元关系与n元关系的选择
- 虽可将非二元关系转换为多个二元关系，但n元关系更能清晰体现多个实体参与同一关系的特性。例如，“项目指导（proj_guide）”作为三元关系（教师、学生、项目）比拆分多个二元关系更直观。
- 部分看似非二元的关系更适合用二元关系表示，例如“父母（parents）”三元关系（孩子、父亲、母亲），拆分为“父亲（father）”和“母亲（mother）”两个二元关系更灵活（可存储部分信息，如仅知道母亲）。

### 非二元关系转换为二元关系的方法
- 步骤：
  1. 为非二元关系R创建人工实体集E；
  2. 创建三个二元关系集RA（关联E与A）、RB（关联E与B）、RC（关联E与C）；
  3. 为E添加标识属性；
  4. 将R的属性添加至E；
  5. 每个R中的关系元组（ai, bi, ci）转换为：E中新增实体ei，RA中添加（ei, ai），RB中添加（ei, bi），RC中添加（ei, ci）。
- 注意：转换后可能无法完全保留原关系的约束，可能存在与原关系不对应的实例。

### 关系属性的放置
需合理选择关系属性的所属对象，例如“日期”属性可作为“指导（advisor）”关系的属性，也可作为学生实体的属性，需根据业务场景判断。



## 扩展E-R特性
### 特化（Specialization）
- 定义：自上而下的设计过程，在实体集中划分出具有独特属性或关系参与特性的子组，形成低层实体集（子类），低层实体集继承高层实体集（超类）的所有属性和关系参与权。
- E-R图表示：用标注“ISA”（如“教师ISA人”）的三角形连接超类与子类。
- 示例：超类“人（person）”分为子类“学生（student）”和“员工（employee）”，“员工”再分为“教师（instructor）”和“秘书（secretary）”；学生继承“人”的ID、姓名、地址，新增总学分（tot_credits）属性；教师继承“员工”的薪水（salary），新增职级（rank）属性；秘书继承“员工”的薪水，新增每周工时（hours_per_week）属性。

### 泛化（Generalization）
- 定义：自下而上的设计过程，将**多个具有相同属性和关系特性**的实体集合并为高层实体集（超类）。
- 与特化的关系：特化与泛化是互逆过程，E-R图表示方式相同，术语常互换使用。
- 示例：将“学生”“员工”合并为超类“人”；将“教师”“秘书”合并为超类“员工”。

### 特化/泛化的设计约束
#### 1. 成员资格约束（实体能否成为低层实体集成员）
- **条件定义**：基于属性条件确定成员资格，示例：年龄超过65岁的“人”成为“老年人（senior-citizen）”子类。
- **用户定义**：由用户指定成员资格，无明确属性条件。



#### 2. 不相交约束（实体能否属于多个低层实体集）
- **不相交（Disjoint）**：一个实体**只能属于一个低层实体集**，E-R图中多个低层实体集连接至同一三角形，示例：“人”不能同时是“学生”和“员工”。
- **重叠（Overlapping）**：一个实体**可属于多个低层实体集**，示例：“员工”可同时是“教师”和“秘书”。



#### 3. 完整性约束（实体是否必须属于某个低层实体集）
- **完全（Total）**：高层实体集中的每个实体**必须属于至少一个低层实体集**，示例：每个“员工”要么是“教师”，要么是“秘书”。
- **部分（Partial）**：高层实体集中的实体**可不属于任何低层实体集**，示例：“人”可既不是“学生”也不是“员工”。



### 特化的模式转换方法
#### 方法1：超类与子类分别创建模式
- **超类**模式：包含**超类的所有属性**，示例：person（ID，name，street，city）。
- **子类**模式：包含**超类的主键和子类特有属性**，示例：student（ID，tot_cred）、employee（ID，salary）。
- 缺点：查询子类实体信息**需关联超类和子类模式**（如查询教师信息需关联person和employee、instructor模式）。

#### 方法2：每个实体集（超类+子类）创建完整模式
- 模式包含**超类继承属性和子类特有属性**，示例：person（ID，name，street，city）、student（ID，name，street，city，tot_cred）、employee（ID，name，street，city，salary）。
- 若为**完全特化**，超类模式可作为**视图（子类模式的并集）**，但为**满足外键约束可能仍需显式创建**。
- 缺点：属性冗余（如同时是学生和员工的人，姓名、地址等属性会重复存储）。



## 聚合（Aggregation）

### 定义

将关系集视为抽象实体（聚合实体），**允许关系与关系之间建立关联**，避免信息冗余。

### 示例

- 问题：“项目指导（proj_guide）”是教师、学生、项目的三元关系，若需记录教师对学生在项目中的“评价（evaluation）”，直接建立“评价-项目指导”关系会导致冗余（每个评价对应一个项目指导关系，但部分项目指导可能无评价）。
- 解决方案：将“项目指导（proj_guide）”聚合为抽象实体，建立**“评价（evaluation）”与聚合实体的“评价对应（eval_for）”关系**，既保留项目指导关系，又避免冗余，清晰表示“教师-学生-项目”组合与评价的关联。



## E-R设计决策要点
1. 用属性还是实体集表示对象。
2. 现实世界概念用实体集还是关系集表示。
3. 用三元关系还是多个二元关系表示关联。
4. 用强实体集还是弱实体集。
5. 是否使用特化/泛化（提升设计模块化）。
6. 是否使用聚合（将关系视为抽象实体，简化复杂关联）。



## E-R符号总结
![image-20251223102316439](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223102316439.png)

![image-20251223102322660](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/image-20251223102322660.png)
