
### 一、视图（View）、物化视图（Materialized View）与关系（Relation）的区别
#### 1. 视图 VS 关系
- 数据存储：视图无实际数据，关系有实际数据。
- 数据源：视图的数据源是其他关系。
- 访问方式：访问视图等价于访问其依赖的关系；若依赖多个关系，会触发连接操作，成本较高。
- 读写操作：读取时用法一致；写入时视图仅支持部分简单场景，并非所有情况都适用。

#### 2. 物化视图 VS 关系
- 本质：物化视图是关系部分数据的物理副本。
- 时效性：物化视图可能过期，需定期维护。


### 二、参照完整性（Referential Integrity）的外键约束方式（MySQL）
外键约束定义了主表数据变更时，从表的联动规则：
#### 1. 级联（cascade）方式
- 定义：`foreign key (groupid) references t_group(id) on delete cascade on update cascade`
- 效果：主表删除/更新数据时，从表关联记录会**同步删除/更新**。

#### 2. 置空（set null）方式
- 定义：`foreign key (groupid) references t_group(id) on delete set null on update set null`
- 效果：主表删除/更新数据时，从表关联记录的外键字段会被设为`NULL`。

#### 3. 禁止（no action / restrict）方式
- 定义：`foreign key (groupid) references t_group(id) on delete no action on update no action`
- 效果：若从表存在关联记录，主表**无法删除/更新**对应数据（直接报错）。


### 三、外连接（Outer Join）的基本操作表达
外连接可通过基本关系操作表示（以`r ⟕ s`为例）：
`(r ⨯ s) ∪ (r - Π_R(r ⨯ s) × {(null, ..., null)})`


### 四、函数依赖（Functional Dependencies）
#### 1. 平凡函数依赖（Trivial FD）
- 定义：所有关系实例都满足的函数依赖。
- 判定：若`α ⊇ β`，则`α → β`是平凡函数依赖。
- 示例：`ID, name → ID`、`name → name`。
- 数量：关系模式`R`的平凡函数依赖数量为`∑_{i=1}^{|R|} 2^i`。


### 五、属性集闭包（Closure of Attribute Sets）
#### 1. 计算算法（求`α^+`，即`α`在函数依赖集`F`下的闭包）
```
result := α;
while (result有变化) do
  for each β → γ in F do
    begin
      if result ⊇ β then result := result ∪ γ
    end
```
- 时间复杂度：`O(n³)`。


### 六、函数依赖集闭包（`F^+`）
- 思路：`F^+`是所有属性集闭包的集合。
- 计算步骤：
  1. `F^+ ← F`；
  2. 对每个`γ ⊆ R`：
     - 计算`γ^+`；
     - 对每个`S ⊆ γ^+`，将`γ → S`加入`F^+`；
  3. 输出`F^+`。


### 七、B树中重复键（Duplicate Search Keys）的处理
#### 1. 节点特性
- 叶节点/内部节点中，键的顺序为`K₁ ≤ K₂ ≤ ... ≤ Kₙ₋₁`（无法保证严格小于）。
- 指针`Pᵢ`指向的子树中，键`≤ Kᵢ`（而非严格小于）；若同一键`V`出现在相邻叶节点，父节点中对应的`Kᵢ = V`。

#### 2. 查找（find）过程的修改
- 即使`V = Kᵢ`，仍需遍历指针`Pᵢ`；
- 到达叶节点`C`后，若`C`中所有键都小于`V`，则跳转到`C`的右兄弟节点，再检查是否包含`V`。

#### 3. `printAll`过程
- 用修改后的`find`找到`V`的第一个出现位置；
- 遍历连续叶节点，找到`V`的所有出现。

需要我帮你把这些内容整理成**分类清晰的表格版总结**吗？










### 一、查询评估计划的选择
#### 1. 核心原则
选择评估计划时需考虑**评估技术的交互性**：单独为每个操作选最便宜的算法，未必能得到整体最优的方案。
- 示例1：归并连接（merge-join）比哈希连接（hash-join）成本高，但能输出有序结果，可降低外层聚合操作的成本。
- 示例2：嵌套循环连接（nested-loop join）支持流水线操作。

#### 2. 实际查询优化器的两种思路
1. **基于成本的全量搜索**：遍历所有可能的计划，选择成本最低的方案。
2. **启发式选择**：通过经验规则快速选定计划。


### 二、两段锁协议（Two-Phase Locking Protocol）
#### 1. 缺点
存在**冲突可串行化的调度**无法通过两段锁协议实现（即协议不完整）。

#### 2. 必要性
若缺乏额外信息（如数据访问顺序），两段锁是保证冲突可串行化的必要条件：
- 若事务`T_i`不遵循两段锁，可找到遵循两段锁的事务`T_j`，使得`T_i`与`T_j`的调度不满足冲突可串行化。


### 三、插入/删除操作的锁机制与幻影现象
#### 1. 两段锁下的插入/删除规则
- 删除操作：事务需对目标元组持有**排他锁（X锁）**。
- 插入操作：事务会获得新元组的**X锁**。

#### 2. 幻影现象（Phantom Phenomenon）
- 定义：扫描关系的事务（如统计物理系老师数）与插入/删除元组的事务（如新增物理系老师），虽未访问共同元组，但逻辑上存在冲突。
- 问题：仅用元组锁会导致非可串行化调度（如统计结果是10人，但打印名单是11人）。


#### 3. 解决思路
需对“关系包含哪些元组”的信息加锁：
- 较差方案：为关系关联一个数据项，扫描事务加**共享锁（S锁）**，插入/删除事务加**X锁**；缺点是并发度极低。
- 更优方案：**索引锁协议**，通过锁定索引桶提升并发度，同时避免幻影现象。


### 四、索引锁协议（Index Locking Protocol）
#### 1. 前提
每个关系至少有一个索引，访问关系必须通过索引。

#### 2. 锁规则
- **查询事务**：对访问的所有索引桶加**S锁**。
- **插入/删除/更新事务**：
  1. 先更新所有相关索引；
  2. 对修改影响的索引叶节点加**X锁**。

#### 3. 效果
遵循两段锁规则，可**避免幻影现象**。


### 五、弱一致性级别
#### 1. 二级一致性（Degree-two Consistency）
- 与两段锁的区别：S锁可随时释放，锁可随时获取；但X锁需持有至事务结束。
- 缺点：不保证可串行化，需由程序员确保数据库状态无错误。

#### 2. 游标稳定性（Cursor Stability）
- 规则：读操作时，元组被锁定→读取→立即释放锁；X锁需持有至事务结束。
- 定位：是二级一致性的特例。
