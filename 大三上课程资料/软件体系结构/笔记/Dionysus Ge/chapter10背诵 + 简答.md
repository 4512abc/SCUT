# Chapter 10（Testability，可测试性）

“测试性是软件在执行测试时快速暴露故障的能力，本质依赖于对组件输入/内部状态的可控性与对输出/状态的可观测性。架构层面提高测试性主要通过两类战术：一类增强控制与观察（如抽象数据源、沙盒隔离、可执行断言）；另一类限制复杂度（降低结构依赖与非确定性）。设计检查表要求在职责分配、通信机制、数据模型、映射关系、资源管理、绑定时间与技术选型等方面保证测试可执行、可捕获、可复现。”

------

## 一、Chapter 10 必背定义（20个）

1. **Testability（可测试性）**：软件通过（通常基于执行的）测试来展示其缺陷（faults）的容易程度。
2. **Testability as probability（可测试性概率定义）**：在系统至少存在一个 fault 的前提下，它在“下一次测试执行”中发生 failure 的概率。
3. **Fault（缺陷）**：软件内部存在的错误/缺陷（不一定每次都表现为外部失败）。
4. **Failure（失败）**：一次执行中对外可观察到的不正确行为；高可测试性希望“若有fault，应尽快fail”。
5. **Fail quickly（快速失败）**：若缺陷存在，希望它在测试中尽快表现为失败，以便定位与修复。
6. **Controllability（可控性）**：能够控制组件输入，必要时能操纵内部状态，使测试能把系统驱动到目标状态。
7. **Observability（可观测性）**：能够观察组件输出，必要时能观察内部状态，使失败更容易被发现与定位。
8. **Testability General Scenario（可测试性通用场景）**：用质量属性场景方式刻画测试性需求，并用度量（如覆盖率、时间）进行验收。
9. **Concrete Testability Scenario（具体可测试性场景示例）**：单元测试人员在开发期间执行测试序列、捕获结果，并在3小时内达到85%路径覆盖率（path coverage）。
10. **Path coverage（路径覆盖率）**：对代码执行路径的覆盖程度，是可测试性场景中常用的响应度量。
11. **Testability tactics（可测试性战术）**：架构层用来降低测试成本、提高缺陷暴露概率的一组设计决策。
12. **Two categories of tactics（两大类战术）**：①增加可控性与可观测性；②限制复杂度。
13. **Specialized Interfaces（专用接口）**：通过测试驱动（test harness）或正常执行路径控制/捕获组件变量值。
14. **Record/Playback（录制/回放）**：捕获跨接口信息，并将其作为后续测试输入以支持重复回归。
15. **Localize State Storage（状态集中存储）**：将系统/子系统/模块状态集中在一个地方，使测试能从任意指定状态开始并便于重置。
16. **Abstract Data Sources（抽象数据源）**：对数据来源进行抽象，使测试时可替换/注入可控数据源。
17. **Sandbox（沙盒）**：隔离系统与真实世界副作用，使实验与测试可重复且不破坏真实环境。
18. **Executable Assertions（可执行断言）**：在运行点检查不变量/条件，帮助快速检测并暴露错误状态。
19. **Limit Structural Complexity（限制结构复杂度）**：通过消除循环依赖、隔离外部环境依赖、减少组件依赖来降低测试搭建与推理成本。
20. **Limit Non-determinism（限制非确定性）**：识别并尽可能清除非确定性来源（如不受约束的并行），避免测试不可重复/偶现。

------

## 二、10个对比题标准答案（含你点名的4组）

### 1) **Structure vs View**

- **Structure**：系统元素及其关系的真实结构集合；
- **View**：对一个或多个结构的表示/文档化呈现，面向干系人使用；
- 结论：设计的是结构，表达的是视图。

### 2) **Module vs Component**

- **Module**：偏代码/实现单元与职责分配（静态组织）；
- **Component**：偏运行时执行实体（动态交互）；
- 二者通常非一一映射。

### 3) **Layer vs Tier**

- **Layer**：模块分层（抽象服务与受控依赖）；
- **Tier**：执行/部署分组（把组件按部署逻辑分组）；
- 结论：Layer=代码职责分层；Tier=部署执行分组。

### 4) **Pattern vs Tactic**

- **Pattern**：一揽子架构决策包，描述反复出现的整体方案；
- **Tactic**：更细粒度、直接影响质量属性响应的设计决策；
- 关系：模式由战术组合而成。

### 5) **Fault vs Failure**

- **Fault**：系统内部缺陷（可能潜伏）；
- **Failure**：一次执行中对外可观察的不正确行为；
- 可测试性目标：若存在 fault，应尽快在测试中触发 failure。

### 6) **Controllability vs Observability**

- **可控性**：能控制输入/必要时操纵内部状态，使测试能构造目标状态；
- **可观测性**：能观察输出/必要时观察内部状态，使失败更易被发现与定位；
- 二者缺一不可：可控但不可观测→看不出错；可观测但不可控→触发不到错。

### 7) **Adding controllability/observability vs Limiting complexity**

- 前者：通过接口、回放、断言等让状态更可控/更可见；
- 后者：通过降低结构复杂度与非确定性减少状态空间与偶现；
- 结论：一类解决“能不能测/能不能看见”，另一类解决“测起来是否可重复且成本可控”。

### 8) **Specialized Interfaces vs Record/Playback**

- 专用接口：提供直接控制/读取关键变量的入口，便于设置/断言内部状态；
- 录制回放：捕获跨接口信息作为后续输入，强调可重复回归与复现；
- 前者偏“操控与观察点”，后者偏“可重复输入序列”。

### 9) **Abstract Data Sources vs Sandbox**

- 抽象数据源：把“数据从哪来”接口化，测试可替换输入源；
- 沙盒：把“副作用到哪去”隔离化，测试不破坏真实世界；
- 一个控输入，一个控副作用环境。

### 10) **Limit Structural Complexity vs Limit Non-determinism**

- 结构复杂度：循环依赖/耦合多导致测试搭建成本高；
- 非确定性：并发等导致同样测试不稳定、难复现；
- 结论：前者降低“搭环境与推理成本”，后者保障“可重复与可定位”。

------

## 三、6道简答题标准答案（完全应试写法）

### 1）简答：什么是可测试性（Testability）？为什么说它可视为概率？

**答：**可测试性是软件通过执行测试更容易展示其缺陷的程度；更严格地说，在系统至少存在一个缺陷（fault）时，它在下一次测试执行中发生失败（failure）的概率。高可测试性意味着若缺陷存在，应尽可能在测试中快速失败以便定位修复。

### 2）简答：提升可测试性的两个核心条件是什么？（架构层）

**答：**系统要可测试，必须能够控制组件输入（必要时操纵内部状态），并能够观察组件输出（必要时观察内部状态）。可控性保证能触发目标路径与状态，可观测性保证失败可被发现并可定位。

### 3）简答：可测试性战术分哪两大类？各自解决什么问题？

**答：**可测试性战术分两类：①增加可控性与可观测性，使测试能驱动系统进入目标状态并观测关键结果；②限制复杂度，降低结构依赖与非确定性导致的巨大状态空间与不可重复，从而降低测试成本并提升复现能力。

### 4）简答：列举并解释3个“控制与观察系统状态”的战术。

**答：**(1) 专用接口：通过测试驱动或正常路径控制/捕获关键变量值；(2) 录制/回放：捕获跨接口信息并作为后续测试输入以支持重复回归；(3) 状态集中存储：将系统/模块状态集中化，使测试可从任意指定状态启动并便于重置与对比。（也可写抽象数据源/沙盒/可执行断言作为同类战术。）

### 5）简答：为什么复杂系统难以测试？“限制复杂度”战术如何应对？

**答：**复杂系统难测主要因：结构上依赖多、循环依赖与外部环境耦合使测试搭建成本高；行为上存在非确定性（如不受约束并行）导致测试不可重复、难复现。应对战术为限制结构复杂度（消除循环依赖、隔离外部依赖、减少组件依赖）与限制非确定性（识别并尽可能清除其来源），从而缩小状态空间并提升测试稳定性。

### 6）简答：简述“可测试性设计检查表（Design Checklist）”的核心检查点（写3–5条即可）。

**答：**可测试性检查应覆盖：

- 职责分配：是否提供执行测试并捕获结果、捕获故障活动、控制/观察系统状态的职责；
- 协作模型：通信机制是否支持结果捕获、状态注入/监测且不引入不必要非确定性；
- 数据模型：关键数据是否可捕获、可设置，生命周期（创建到销毁）是否可覆盖；
- 映射/资源/绑定时间/技术选型：映射关系是否可测并能暴露竞态；测试资源是否充足且环境具代表性；晚绑定是否可测试且可重建绑定结果；技术是否支持回归测试、故障注入等并能进行状态注入。

