# chapter7 modifiability

“可修改性关注系统发生变化时的成本与风险：不仅是时间/金钱成本，也包括修改对其他功能或质量属性的影响范围。表达可修改性需求应使用质量属性场景（谁触发、改什么、影响对象、在何环境、系统如何响应、以何度量）。降低修改成本的核心战术包括：缩小模块规模、提高内聚、降低耦合，以及通过延迟绑定将关键选择推迟到更晚阶段；同时可用设计检查表从职责分配、协调模型、数据模型、元素映射、资源管理、绑定时刻与技术选型等决策类别逐项审查，使最可能的变化尽量局部化、可预测且低副作用地完成。”



## A. 必背定义（20个，背到能默写）

1. **Modifiability（可修改性）**——关于“改变”，我们关心的是**做出改变的成本与风险**。
2. **Change（变更）**——对系统/构件/模块/接口/职责/配置等进行调整，以满足新需求或修正问题；属于可修改性的“对象”。
3. **Cost（变更成本）**——完成一次变更所需的**时间或金钱**（常用度量）。
4. **Risk（变更风险）**——变更带来的失败概率或不可控后果（如引入缺陷、延期、返工）。
5. **Side effects（副作用）**——变更不应影响无关部分；可修改性场景里常用“**无副作用**”作为响应要求。
6. **Modifiability Planning Questions（可修改性规划三问）**——架构师规划可修改性时必须回答：**什么会变？变更概率多大？何时变&谁来变？**
7. **Modifiability Scenario（可修改性场景）**——用场景描述一次变更：谁在何时改什么，系统如何响应，响应如何度量。
8. **Quality Attribute Scenario（质量属性场景）**——表达质量需求的标准模板：**Source, Stimulus, Environment, Artifact, Response, Response measure** 六要素。
9. **Source of Stimulus（刺激源）**——触发事件/变更请求来自谁（开发者/用户/外部系统等）。
10. **Stimulus（刺激）**——发生了什么（这里通常是“提出/实施某种修改”）。
11. **Environment（环境）**——刺激发生时的条件（设计时/运行时/正常/异常等）。
12. **Artifact（制品/受影响对象）**——被修改或被影响的对象（模块/组件/接口/数据/配置等）。
13. **Response（响应）**——系统/团队需要做什么来完成修改（修改、重构、替换、重新配置等）。
14. **Response Measure（响应度量）**——用可量化指标衡量响应（如**3小时内完成**、无副作用等）。
15. **Modifiability Tactics（可修改性战术）**——目标是控制“做变更的复杂度”，并控制**时间与成本**。
16. **Split Module（拆分模块/减小模块规模）**——模块能力过多会导致修改成本高；拆成更小模块可降低未来修改的平均成本。
17. **Increase Semantic Coherence（提高语义内聚/一致性）**——若同一模块内职责A与B不服务同一目的，应分离到不同模块（新建或迁移职责）。
18. **Encapsulate（封装）**——给模块引入**显式接口**；接口包含API及其相关职责（例如把输入参数做语法转换为内部表示）。
19. **Use an Intermediary（使用中介/中间层）**——当职责A依赖职责B时，可通过中介打断直接依赖关系。
20. **Restrict Dependencies（限制依赖）**——限制某模块可交互/依赖的模块集合，从而降低变更传播。
21. **Refactor（重构）**——当两个模块因“部分重复”而总被同一变更影响时，通过重构消除重复。
22. **Abstract Common Services（抽象公共服务）**——两个模块提供“相似但不完全相同”的服务时，可将服务实现为更一般的抽象形式以复用。
23. **Defer Binding（延迟绑定）**——生命周期中越晚绑定值越好；内建灵活性后“行使灵活性”通常比手工硬改更便宜，但实现晚绑定机制本身更贵。
24. **Binding Time Decision（绑定时间决策）**——其他设计决策都伴随“何时绑定”：可在构建时选模块、运行时协商协议、运行时接入外设等。

> 额外提醒（高频扣分点）：中介/层次通常提升可修改性，但会带来性能开销；性能章也明确提到“中介会增加资源消耗，移除可改善延迟”。

------

## B. 10个对比题标准答案（按考场可直接抄）

### 1）Structure vs View（结构 vs 视图）

- **Structure**：系统中元素及其关系“本体”（元素集合本身）。
- **View**：对某个结构的**表示/文档化表达**；“view is a representation of a structure”。

### 2）为什么“View ≠ Structure”？

- 结构是客观存在的元素与关系；视图是为干系人服务、按模板/记法写出来的表达。
- 结论句：**架构师设计结构，文档化结构的视图。**

### 3）Module Structure vs C&C Structure（模块结构 vs 组件-连接器结构）

- **模块结构**：实现单元（代码/数据单元）的组织与职责分配；更少关注运行时。
- **C&C结构**：运行时元素（components）及其交互（connectors），用于推理性能/可用性/安全等运行时属性。

### 4）Module vs Component（模块 vs 组件）

- **Module**：实现单元/工作分解单元（代码组织与责任分配）。
- **Component**：**运行时实体**（服务/客户端/服务器/过滤器等）。

### 5）模块与组件的对应关系？

- 不要写“一一对应”。原文要点：**模块到组件映射通常 many-to-many**（一个模块可对应多个组件，反之亦然）。

### 6）Layer vs Tier（层 vs 部署层级）

- **Layer（层）**：一种模块结构；层是提供一组**内聚服务**的“抽象虚拟机”，通过受控接口提供服务，并以受控方式使用其他层。
- **Tier（tier/分层部署组）**：一种执行结构的逻辑分组；“每个分组称为一个tier”，是**组件的逻辑分组**。

### 7）Layered pattern vs Multi-tier pattern（分层模式 vs 多tier部署模式）

- Layered：强调**模块 uses 关系的受控/单向**，关注职责与依赖管理（偏设计/实现结构）。
- Multi-tier：强调部署/执行结构的分组与通信（偏运行/部署结构）。

### 8）Pattern vs Tactic（模式 vs 战术）

- **Tactic**：影响某个质量属性响应的设计决策，焦点更小、更“原子”。
- **Pattern**：可复用的一包设计决策；可视作由多个tactics组合而成。

### 9）“Patterns are built from tactics”怎么写成标准句？

- 标准句：**模式由战术构成；若模式是分子，战术是原子（pattern=molecule, tactic=atom）。**

### 10）为什么“模式还要用战术增强”？

- 模式常对某些质量属性中性甚至有弱点，需要用战术补强；增强过程直到满足系统具体需求为止。

------

## C. 6道简答题标准答案（完全应试写法）

### 1）简答：什么是可修改性？如何度量？

**标准答案：**
可修改性（Modifiability）是关于系统发生改变时，我们关注其**变更的成本与风险**。可修改性度量通常使用完成一次变更所需的**时间或金钱**，并关注该修改对其他功能或质量属性的影响范围。

------

### 2）简答：可修改性规划时架构师要考虑哪三问？

**标准答案：**
为规划可修改性，架构师需要考虑：（1）**什么会改变**；（2）改变发生的**可能性/概率**；（3）改变在生命周期的**何时发生以及由谁实施**。

------

### 3）简答：写出质量属性场景六要素，并给出一个可修改性具体场景

**标准答案：**
质量属性场景由六部分组成：**Source of stimulus、Stimulus、Environment、Artifact、Response、Response measure**。
示例可修改性场景：开发者在设计时修改用户界面代码；修改在**无副作用**的情况下于**三小时内完成**。

------

### 4）简答：可修改性战术的目标是什么？主要手段有哪些？

**标准答案：**
可修改性战术的目标是控制“做变更的复杂度”，并控制变更的**时间与成本**。降低变更成本的典型战术包括：**减小模块规模、提高内聚、降低耦合**；此外还可通过**延迟绑定**降低变更代价。

------

### ==5）简答：列举并解释“降低耦合（Reduce Coupling）”的战术（写4–5条）==

**标准答案：**
降低耦合的战术包括：

1. **Encapsulate（封装）**：为模块引入显式接口（API及其职责），隐藏内部变化点。
2. **Use an Intermediary（使用中介）**：用中介打断职责A对职责B的直接依赖。
3. **Restrict Dependencies（限制依赖）**：限制模块可交互/依赖的模块集合，减少变更传播路径。
4. **Refactor（重构）**：消除模块间重复导致的“同改同痛”，降低联动修改概率。
5. **Abstract Common Services（抽象公共服务）**：将相似服务做成更一般的抽象实现，减少修改点数量。

------

### ==6）简答：解释“延迟绑定（Defer Binding）”的含义、收益与代价==

**标准答案：**
延迟绑定是指：在生命周期中**尽可能晚地**绑定决策/取值。若设计制品具备内建灵活性，则行使该灵活性通常比手工硬改更便宜，从而降低变更成本；但为支持晚绑定而引入机制（如插件、协商、参数化等）会带来**额外实现成本**。

