# 第17章（Designing an Architecture / ADD）本章PPT。

------

## 一、必背定义（22个，>15）

1. **Design Strategy（设计策略）**：架构设计遵循三件套：**Decomposition + Designing to ASRs + Generate and Test**。
2. **Decomposition（分解）**：从**整体系统**开始，把系统分解为部分，并把整体的质量属性需求**继承/分配**到各部分。
3. **ASR (Architecturally Significant Requirement)**：必须用架构设计满足、数量少但最重要的需求（by definition）。
4. **Designing to ASRs（以ASR驱动设计）**：设计优先围绕少数ASRs做关键结构决策，而不是平均满足所有需求。
5. **Generate and Test（生成-检验）**：把当前设计视为**假设（hypothesis）**，检验是否满足需求；不满足则生成新假设继续迭代。
6. **Hypothesis（设计假设）**：某一轮的候选架构/候选设计方案，用来接受“是否满足需求”的检验。
7. **Initial Hypothesis（初始假设）**：设计迭代的第一版候选方案，优先来自已有系统/框架。
8. **Desirable Sources（更理想来源）**：**Existing systems、Frameworks**，覆盖需求更全面、风险更可控。
9. **Less Desirable Sources（较不理想来源）**：**Patterns & tactics、Domain decomposition、Design checklists**，往往**覆盖不全**，易遗漏质量属性需求。
10. **Test Output（检验输出）**：一份“当前设计未满足的需求清单”，包括未满足的**responsibilities 或 quality requirements**。
11. **Next Hypothesis Generation（生成下一假设）**：补齐缺失职责 + 用战术调整质量属性行为 + 注意战术副作用。
12. **Side Effects of a tactic（战术副作用）**：战术改善某质量属性的同时会引入对其他属性/成本的负面影响，需要权衡。
13. **Done Condition（结束条件）**：当**ASRs全部满足**和/或**设计预算耗尽**；预算耗尽则采用当前最优假设开始实现，后续设计会受实现选择约束。
14. **ADD (Attribute-Driven Design)**：将已讨论技术“打包”的**迭代式架构设计方法**：每轮选一部分→汇集该部分ASRs→生成并检验设计。
15. **ADD Output（ADD的输出）**：一组**containers及其responsibilities**，以及容器间的**interactions / information flow**；**不产出**容器API或签名，也不保证完整设计。
16. **Container（容器）**：ADD产出的设计单元，用来承载职责并形成交互/信息流（粒度可对应子系统/组件/服务）。
17. **Responsibilities（职责）**：分配给容器/元素要完成的功能性责任（满足功能需求的主要载体）。
18. **Interactions（交互）**：容器之间“如何协作”的关系与通信方式（谁和谁交互）。
19. **Information Flow（信息流）**：交互过程中“信息如何流动/传递”的描述（信息从哪到哪、流向与路径）。
20. **ADD Inputs（ADD输入）**：三类需求：**Functional / Quality / Constraints**。
21. **Utility Tree（效用树）**：当选择元素是“整体系统”时，用效用树组织/汇集ASRs；若是更下层元素，则为该元素的需求重新生成效用树。
22. **Breadth-first vs Depth-first（广度/深度细化策略）**：两种元素细化顺序；遇到新技术或某团队需要开工→优先深度，否则优先广度。

------

## 二、10个对比题（标准答案）

### 1）Decomposition vs Designing to ASRs

- **分解**：从整体到部分，建立结构骨架并分配系统级质量属性需求。
- **以ASR驱动设计**：抓少数关键驱动需求，决定关键结构/交互/职责。

### 2）Generate vs Test（生成 vs 检验）

- **Generate**：提出/修改候选架构假设（补职责、用战术调质量）。
- **Test**：用分析技术+检查清单+ASRs验证，输出未满足需求清单。

### 3）ASR vs Non-ASR Quality Requirement

- **ASR**：必须通过架构设计满足；数量少但最重要。
- **非ASR质量需求**：若不满足，可：调整设计/弱化需求/提升为ASR/宣布与ASR组合下不可满足。

### 4）Green field vs Legacy（Step 1选元素）

- **绿地**：通常第一轮选择 **whole system**。
- **遗留/增量**：第一轮选择 **要新增/修改的那部分**。

### 5）Breadth-first vs Depth-first（细化策略）

- **广度优先**：同一层多个元素先粗设计一遍（先建立整体结构）。
- **深度优先**：沿某关键元素深入细化；新技术/团队要开工→选深度，否则选广度。

### 6）Functional vs Quality vs Constraints（ADD输入三类）

- **功能需求**：通过“加职责并分配到容器”来满足；必要时建新容器/拆分容器。
- **质量需求**：满足则退出考虑；不满足则委派/拆分，必要时弱化，否则判定不可满足。
- **约束**：按质量需求同样方式处理（Satisfied/Delegated/Split/Unsatisfiable）。

### 7）Delegate vs Split（质量/约束不满足时）

- **Delegate（委派）**：把未满足的质量需求交给某个子元素承担。
- **Split（拆分）**：把质量需求分摊给多个子元素共同承担。

### 8）Weaken vs Unsatisfiable（弱化 vs 不可满足）

- **Weaken**：降低/放宽该质量需求，使其在当前或小改设计下可满足。
- **Unsatisfiable / cannot be met**：在与既定ASRs组合下无法满足（且无法弱化）。

### 9）Responsibilities vs Interactions vs Information Flow（ADD输出三件套）

- **职责**：容器要做什么。
- **交互**：容器之间如何协作/通信。
- **信息流**：交互中信息如何流动与传递路径。

### 10）Existing systems/frameworks vs patterns&tactics/checklists（初始假设来源）

- **已有系统/框架**：更理想，覆盖需求更全。
- **模式/战术/领域分解/清单**：较不理想，常遗漏质量属性需求。

------

## 三、6道简答题（标准答案：可直接抄）

### 1）简答：本章给出的架构设计总体策略是什么？

**标准答案：**
架构设计遵循三项策略：**（1）分解（Decomposition）**：从整体系统开始分解为部分，并将整体质量属性需求继承/分配到各部分；**（2）以ASRs驱动设计**：围绕少数最重要ASRs做关键结构决策；**（3）生成-检验（Generate and Test）**：将候选设计视为假设，检验是否满足需求，不满足则生成新假设迭代优化。

### 2）简答：为什么设计要从整体开始做分解？“继承质量属性需求”是什么意思？

**标准答案：**
因为**架构决定质量属性**，而重要质量属性通常是**系统整体特性**，因此设计应从整体系统出发并逐步分解为各部分；分解后，每个部分会**继承整体的全部或部分质量属性要求**，即将系统级质量目标按职责分摊到子部分以便落实与验证。

### 3）简答：如果某个“非ASR的质量需求”没有被当前设计满足，怎么办？

**标准答案：**
若设计未满足某个非ASR质量需求，可采取四种方式之一：

1. 调整设计，使其在**不破坏ASRs**前提下也满足该需求；或
2. **弱化**该需求，使其能被当前设计或小改动满足；或
3. 调整优先级，使该需求上升为**ASR**；或
4. 声明该需求在与ASRs组合下**不可满足（non-satisfiable）**。

### 4）简答：解释“Generate and Test”在架构设计中的含义；测试输出是什么？如何生成下一假设？何时结束？

**标准答案：**
Generate and Test 将当前设计视为**假设**并检验其是否满足需求；检验时使用既有分析技术、质量属性检查清单与ASRs。测试输出为“当前设计未满足的需求清单”，包括未满足的职责或质量需求。生成下一假设的方法是：补齐缺失职责，并使用战术调整未达标质量属性行为，同时注意战术副作用。结束条件是：ASRs全部满足和/或设计预算耗尽；预算耗尽则采用当前最优假设开始实现，继续设计将受到实现选择约束。

### 5）简答：什么是ADD？ADD的输入输出分别是什么？ADD“不产出什么”？

**标准答案：**
ADD（Attribute-Driven Design）是一种将相关技术“打包”的**迭代式架构设计方法**：每轮选择系统的一部分，汇集该部分ASRs，并对该部分进行生成-检验得到设计方案。ADD 的输入是三类需求：功能需求、质量需求、约束；输出是容器及其职责，以及容器间交互与信息流。ADD **不保证产生完整设计**，也**不产出容器的API或签名**。

### 6）简答：写出ADD步骤，并说明第4步如何处理功能/质量/约束；以及“下一轮选哪个元素”的策略

**标准答案：**
ADD步骤：①选择待设计元素；②识别该元素ASRs；③为该元素生成设计方案（应用生成-检验）；④盘点剩余需求并选择下一轮输入；重复①–④直至ASRs满足。
第4步处理规则：

- 功能需求：检查是否满足；不满足则增加职责并放入需求相似的容器；无合适容器则创建新容器或放入不相似容器（注意内聚/一致性）；若容器对团队而言需求过多则拆分，并尽量实现低耦合。
- 质量需求：满足则不再考虑；不满足则委派给子元素或在子元素间拆分；若仍无法满足则尝试弱化，否则判定不可满足。
- 约束：与质量需求同样处理（Satisfied/Delegated/Split/Unsatisfiable）。
  下一轮选元素策略：广度优先或深度优先；若使用新技术或某团队需要开工则优先深度，否则优先广度。

