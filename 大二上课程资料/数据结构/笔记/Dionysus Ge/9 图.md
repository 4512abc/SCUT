图相比于前述的数据结构，优势在于可以处理更多元的输入输出



图的两种物理存储结构

均要包含几个元素：顶点个数、边的条数、是否标记（也即是否遍历过）

- 邻接矩阵

  

- 邻接链表

  构造：

  - 处理稀疏图、有向图会更高效

    无向图的话要重复两次

  - 当处理密集图时，使用邻接矩阵会更方便，虽然看起来邻接矩阵的复杂度是$O(E + V)$，但是E最多可以有n的平方级别，所以和矩阵是同级的

图的一些操作

- find(v)，根据顶点序号找该结点的第一条边
- next(v, m)，找该结点第m列之后出现的第一条边

图的遍历

- 为了避免图的遍历陷入无限循环，引入了标签位，已被访问设为True

- 深度优先算法DFS

  - 应用：网络图，碎片收集（java系统，应该是内存回收？）

  - 又称为递归标志方法

    从顶点 i 开始，访问其邻接顶点，如果该节点没有被访问，把该顶点标记为访问过并继续往下访问

  - 利用栈来实现（递归），递归算法的简洁性在于栈已经被隐藏着实现了

  - 图的生成树

    利用DFS，将其回溯的路径标记出来便形成了生成树

    生成树的顶点是不变的，边取其中的子集，该图连通并且没有圈
    
  - 一个生成树其实就是图的一个连通分量

    根据DFS算法，每个连通分量的起始结点都是可选的

  - 算法用邻接链表实现的话，空间复杂度和时间复杂度都是线性的

- 广度优先算法BFS

  - 逐层访问
  - 利用队列实现
  - **基本步骤**：
    - 初始化一个空队列，并将起始顶点入队。
    - 标记起始顶点为已访问（通常使用一个布尔数组或集合）。
    - 当队列不为空时，重复以下步骤：
      1. 从队列中取出一个顶点（称为当前顶点）。
      2. 访问当前顶点（例如，输出顶点值）。
      3. 遍历当前顶点的所有邻接顶点：
         - 如果某个邻接顶点未被访问，则将其标记为已访问，并将其入队。
  - 可以用来寻找二分图，讲道理应该也可以用来解决着色问题，通过chatgpt可知猜想正确

- DFS BFS都需要使用一个标记位mark去查看该结点是否已经访问

  实现的话应该都是先访问该结点的first边连接的结点，然后再查看next边连接的结点，如果没有被标记就往下排序

  初步看下来，虽然两者都要访问所有边，但是当图相对稠密的时候，用BFS的话，递归产生的函数栈会相对小一些

- 拓扑排序

  对象为有向图

  方法简单来说就是：

  每次找到入度为0的点加入数组，并在图中删除该点及其关联的边，再继续往下找入度为0的点，同理进行操作

  如果存在多个入度为0的点，随便删掉一个就可以，拓扑排序是可以有多个结果的

  其对应的实际问题就是做事的顺序

  - 如果不存在拓扑排序结果，那么必然存在回路，那么相当于每件事情环环依赖，事情永远做不了

  - 如果拓扑排序只有一种结果，那么有一个结点出度为0，一个结点入度为0

    顶点入度为0说明子事件都必须从这个事件出发，出度为0表示没有任何事件再依赖于它

  是不是和离散数学中的拓扑排序一样呢，那是不是要有一个偏序关系

  引例：排班时需要考虑优先级，也即存在前序约束（prerquisite constrain）

  - 条件：
    - 必须为有向图
    - 不能有环

  - 步骤（Kahn算法，基于入度）

    从图中找到入度为0的点（说明没有其它点在其之前），如果有多个可以随机选择一个

    如果没有入度为0的顶点，那么说明存在圈

    将入度为0的点从图中删掉后入队，重复如上步骤，直至全部的点都被删完

  - 实际代码步骤分析：

    1. 利用一个入度的数组D去存储每个结点的入度
    2. 用入度为0的结点初始化队列Q
    3. 当队列中还有结点时：
       1. 将该结点出队，进入拓扑排序的数组
       2. 将其邻接的结点入度减1
       3. 将当前入度为0的结点入队
    4. 如果所有的结点都被输出到了拓扑排序的数组，那么排序成功，否则存在环

  - 另外也可以采用DFS算法

    步骤：

    对每个未访问的节点进行DFS递归访问，确保所有依赖的节点都访问过后，才将当前节点加入排序序列。将最终序列从栈中取出即为拓扑排序结果

- 最短路径

  注意区分path cost和path length

  前者是加权和，后者是边数

  两种问题：

  - 单源最短路径
  - 多源最短路径

  一些变式：是否有权、权是否有负值、是否有圈、结点是否有圈

  解决的问题：计网中包沿着哪条路径传输、货运、带预算的旅游

  

  - 无权图的最短路径

    我的猜想：利用BFS算法，层数对应了路径长，但是有个bug，这个不一定是最短的，因为结点只会访问一遍，那么解决方法会不会是不使用mark位呢

    但其实不用考虑这个，如果问题只是要找到最短路径的话

    当然如果要找到多条最短路径，那么就需要考虑修改算法了，有可能是加入必须经过的点

    跑了一遍BFS后便可以得到各个顶点相对于原点的路径长

    

    算法分析：

    包含的几个关键数据结构

    distance：存放该结点到原点的路径长

    prevetex：存放该结点的前驱结点

    Q：一个队列

    步骤：

    1. 将起始结点x入队，同时将distance[x] 设为0
    2. 访问邻接结点y，记录其前驱结点，也即prevertex[y] = x

- Dijkstra算法

  处理带权的单源最短路径，不能带有负的权

  - Dijkstra，迪杰斯特ra（老师读的）

    其人：

    - 最初对法学感兴趣，由于理工科成绩优秀，在家人的推荐下选择了理论物理
    - 在偶然的机会下接触到了编程，在当时计算机尚未出来时，用纸和笔编程
    - 当时被物理学家和数学家所鄙夷，且不存在程序员这个行业
    - 为了科普计算机的作用，在咖啡馆用20分钟想出了dijkstra最短路径算法

    “资源的匮乏往往最能激发创造性”

  算法介绍：

  ① 初始化起点的路径长为0，一个记录顶点的数组S初始化为空，其余顶点的路径为无穷大

  ② 起点加入到S，更新与起点邻接的顶点的路径长并记录父节点

  ③ 从没有加入到S的结点中，选择一个路径长最小的加入，然后更新与该顶点邻接的顶点的路径长

  

  重复以上步骤，直至所有结点加入S

  - 该算法不能用于含负值的边，可以用Floyd算法求解，但Floyd算法中，不能有权值和为负值的环路

  





- 贪心算法

  做当前最优的决策，不考虑未来的结果，但每步的最优不一定能得到结果的最优






选择（20） + 填空（20，补代码） + 简答（4 * 10，按照算法思路一步步写） + 应用（20，实际问题映射到所学知识去解决）



# 学习指导

## 8.1 概念回顾

- 对于非连通图，有几个连通分量就要调用几次DFS或者BFS来遍历完所有结点
- 图的DFS与二叉树的先序遍历类似
- 图的BFS与树的层次遍历类似
- 给定一个图，采用DFS可以找到v到u的所有路径，采用BFS可以找到最短路径
- 简单路径，其实就是不重复访问，无环
- 有向图若无完整的拓扑序列，则一定存在回路
- Floyd算法可以求含负值边的最短路径，但图中不能有权和为负数的环路

这里要注意一下，Dijkstra算法和哈夫曼编码的不同，似乎在此脑海中想到这两个总是出现那个树形，但dijkstra不是

## 8.2 对应某本书的题目

### 2

找图的强连通分量，可以先找一个环路，再将其它顶点加入（可能不只是加入单个，此时不连通，加多一些又连通了）

### 3

如果要对存储结构进行选择，遵循以下规则

邻接链表，占用的空间与边数有关

邻接矩阵，占用的空间与边数无关

### 4

略

### 5

对于图的DFS, BFS，是可以有多种遍历结果的，在结点没有遍历优先级的情况下，走到某点时，后续点其实只需要邻接就可以往下

### 6

略，两个算法都敝教教简单

### 7

可以简单考虑一下，两条边权最小的，肯定可以加入，三条就未必了，可能构成回路

### 8

这里要重新学习一下dijkstra算法，有三个结构

用于存放目标结点到当前结点路径长度的数组dist

用于存放前驱结点的数组path

用于加入顶点的栈S，每次加入当前dist数组中最短路径且没有入栈的结点



初始化时将dist都设为∞，path都设为-1

然后将起始结点入栈S，对于可达结点，更新dist数组为路径长，更新path数组为起始结点

第二步，在dist数组中找一个最小值对应的结点入栈S，对于可达结点，更新dist数组，如果连接前驱顶点、该点、该点可达点的路径长小于原来dist数组中存放的路径长，更新dist数组，并更新path数组，修改前驱结点

如此重复第二步，直到所有结点都入栈S

最后dist数组记录的就是起始点到该点的最短路径，而path数组记录的前驱结点，不断前驱一直到起始点，便是路径信息

### 10-11

若用dijkstra算法求顶点对之间的最短路径，比如i，j结点，将i结点入栈后，用同样的方法，只是当j结点入栈时便可以停止，然后用path数组的信息找到该条路径

那么如果对每个顶点对都找最短路径，时间复杂度为O（n^3），Floyd算法也是O（n^3），但由于其信息是共享的，所以更快一些，dijkstra每次都是独立执行

### 12

当每次删除入度为0的结点后，剩余结点只存在一个入度为0的，此时拓扑排序结果唯一

所有边集中到邻接矩阵上三角部分，可以先队顶点进行拓扑排序，然后重新编号，使每条有向边的起点编号小于终点编号

### 13

注意是带权的，那么数字代表的是权重，无穷是不存在边

然后关键路径的概念，其实就是路径长度和最大的一条路

之后的都是算法设计，略了

## 8.3.1 选择

### 1

相对于边不重复出现，点不重复的要求更高，因为点之间可能有多条路径，如果出现多条，便不再是简单路径

### 2

对于带权有向图的邻接矩阵来说，权值是直接反应在邻接矩阵中。如果为0，那么表示两点间距离为0，一般是自己到自己的距离为0，出现在对角线上，而两点间不可达是用 ∞ 表示的

### 3

易知

### 4

握手定理

### 5

注意乘完之后要除以2，每条边都出现了两次

### 6

n - 1呗，树

### 7

这个分析思路还蛮新颖的，n-1个顶点构成无向图，然后对于第n个顶点只需要任意加一条边就连通了，由此可以得到当边数大于多少时无论怎样都连通

### 8

和上题思路一样，让这些边数小于$\frac{n(n-1)}{2}$，解出n后向上取整加1，便是至少有的顶点数

### 9

C呀，简单路径就生成树呗

### 10

第三个选项，无向连通图情况很多嘛

### 11

我说实话，没理由D不对

### 12

易知

### 13

完全图，到其它任意顶点都直接相连

### 14

深度优先，每次往下前都是从当前结点寻找可达结点

### 15

易知

### 16

还是注意，只要是当前结点可达，都是可以遍历的，无特殊说明不管序号

### 17

连通图

### 18

提到过，即先序遍历算法

### 19

一样的，层次遍历

### 20

进队一次，进了后会设置标记位

### 21

有多少个连通分量就要调用多少次才可以遍历完结点

D注意，非强连通，不一定是不连通，可能是单侧连通，从单侧的起始结点开始也可以遍历完的

### 22

当权值有一样的时候，会有多棵最小生成树

### 23

也即含有全部顶点，边恰好就n-1的情况

### 24

我说实话，这题圈是对的

### 25

最小生成树首先要满足是生成树，也即连通，然后再满足是极小连通，最后满足权值和最小

### 26

Ⅰ、of course，只能说最小生成树权值唯一，但是可能的树形不唯一

Ⅱ、不一定，不可以出现环

Ⅲ、no，因为每次都是从当前添加进来的顶点去找最小边嘛，显然不太科学

Ⅳ、no，假如只有一棵呢，也就是各个边的权值是唯一的情况，那必然相同

### 27

从已有的顶点去找其可达顶点中边权值最小的

### 28

同上

### 29

不重、不构成环

### 30

prim的寻找是遍历当前点所有可达边中最小的，然后检验不成环，那么对于边较多的，起始不太会构成影响，但kruskal的寻找每次都要找所有边，当图较稠密，边较多的时候，效率低

### 31

记一下dijkstra算法的时间复杂度吧，O（n^2）

### 32

首先，dijkstra和BFS、DFS都是不一样的。然后是按长度递增，逐渐向外扩展嘛

### 33

显然要选不在S中的点，不能重复出现

### 34

逻辑是先选中点，再更新长度？

### 35

Floyd算法

初始化一个邻接矩阵，然后遍历所有顶点，当前遍历的结点记为k，比较距离进行更新

$d[i][j] = min(d[i][j], d[i][k] + d[k][j])$

那么算法的时间复杂度会到一个O（n^3）级别，矩阵中的点是n^2，每个有序对都要遍历一次所有点，再乘以n

### 36

画个图解呗，还是用dist数组、path数组和栈S去讨论

### 37

判断图是否存在回路

拓扑排序、DFS

### 38

也就是有环呗

### 39

关键路径，由定义，就是最长的这条

### 40

管求不了，咱就选D呗

## 8.3.2 填空

### 2

再注意一下强连通的含义吧，任意两点间双向可达

### 3

不严谨，要简单图我说实话，然后这个答案意思是算出入度之和

### 4

应该主要从顶点存储的顺序来谈，那么每个顶点内的链表不唯一

### 5

有向图算之后不用除以2

### 6

略

### 7

无向图的邻接链表，边结点数是边数的两倍，存在一条边就要在两个链表中分别添加

### 13

最大递归深度，其实也就是连通但无环的状态，一直往下进行搜索而不返回

### 14

可能该点与所有点都存在边

### 15

点入栈后遍历该行，一直到所有点入栈，所以是n^2

### 16

略

### 17

删除任意一条边就构成生成树

### 18

再区分一下，连通分量是极大连通子图，极大的意义是，各个连通分量间不存在边，也即某个连通分量确定后，其它结点不可能再加入了

然后生成树是极小连通子图，因为图要连通才有生成树，然后极小的含义是连通但边最少

### 19

略

### 20

可能修改的就是该结点的可达结点

### 21-22

写出来解

### 23

略

### 24

Floyd算法也有一个path数组吗

和dijkstra一样，也是记录i 到 j 路径的前驱结点，

### 25

考虑编号不大于k的所有顶点后，i  和  j之间不存在可达路径

### 26

可以拓扑排序的一定是无环图

### 27

应该就考虑最坏情况吧，删除该点后要删除掉该点所关联的边

### 28

唯一入度为0的顶点

### 29

关键路径上的活动就叫关键活动

### 30

## 8.3.3 判断

2.3

只要权值相同的边不构成环，那么生成树仍旧是唯一的

2.6

dijkstra允许图存在回路，不影响其排序，因为结点不会重复入栈

## 8.3.4 简答题

### 3

可以再回顾一下邻接表的表示的意思，方框右侧是指针，指向邻接的结点，然后该邻接结点方框的指针，是指向头节点的邻接结点而非该结点的邻接结点，也就是说表示是这样表示，但链表元素始终是头节点的邻接元素

如果有权值的话，在结点后再用一个方框表示权重即可

### 4

逆邻接表？

### 5

深度优先正好访问完所有顶点的同时经过了n-1条边，这些边将顶点全部连通，那么就形成了一棵树

### 7

7.2 

由邻接链表去进行一个DFS，每次寻找都是以当前结点往下搜，选择链表中没有选过的点，然后出现所有结点未入栈完全时某结点链表中已经找不到未访问的情况时，说明该图非连通

### 9

如果是考试要求写dijkstra步骤的话，参考一下这个格式，dist和path数组是一个数组，然后每行是添加结点后更新的距离

### 12

利用这道题看看Floyd算法的步骤吧

先初始化A(0)，图的邻接矩阵，和path(0)，全为-1

然后对n - 1个结点进行遍历，每次看对于加入该点后，先前结点到某点的最小距离是否发生变化，如果变化，则记录到A(i)矩阵中，并且更新path(i)矩阵，换成前驱结点

### 13

Floyd算法的实际运用，计算某个结点到其它各个结点的最短路径之和，用于决定总体代价最小的情况

### 14

## 8.3.5 算法设计

略
