# Ch5
## I/O软件的基本原则和目标
- **操作系统与I/O设备**：操作系统的主要功能之一是控制所有I/O设备，包括：
    - **向设备发送命令**
    - **捕获中断**
    - **处理错误**
    - **提供**设备与操作系统其他部分之间的**接口**（使得设备独立）。

- **I/O软件的目标**：
    - **设备独立性**：程序可以访问任何I/O设备，而无需提前指定设备（例如USB设备、硬盘或CD-ROM）。
    - **统一命名**：文件或设备的**名称是一个字符串或整数，不依赖于具体机器**。
    - **错误处理**：**尽可能靠近硬件处理错误**。
    - **同步与异步传输**：==同步传输会阻塞，而异步传输（如中断驱动）不会==。
    - **缓冲**：设备输出的数据**可能无法直接存储到最终目标位置**。
    - **共享与专用设备**：例如，磁盘是可共享设备，而磁带驱动器则不是。

## I/O操作方式
### 程序化I/O（Programmed I/O）
- **特点**：CPU在I/O完成之前一直忙于I/O操作。

  - 适合**单进程系统**（如MS-DOS、嵌入式系统）
  - 不适合多编程和分时系统。

- **示例**：假设一个程序要向打印机打印一个字符串“ABCDEFGH”，打印机有一个字节的数据缓冲区。**程序需要不断检查打印机的状态寄存器，以确定其是否准备好**，这种忙等待（busy-wait）的方式会浪费CPU时间。

  ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271041413.webp)

  **参考代码**：

  ```c
  /*
  buffer is user buffer
  p is kernel buffer
  count is number of bytes to be copyed
  */
  copy_from_user(buffer, p, count);				/* p is the kernel buffer */
  for(i = 0; i < count; i++){						/* loop on evey character */
  	while(*printer_status_reg !=READY);			/* loop until ready */
  	*printer_data_register=p[i];				/* output one character */
  }
  return_to_user();
  ```

- **轮询**：CPU 忙碌忙于检查打印机的状态寄存器以确定其状态。

  - Ready
  - Busy
  - Error

  忙等待周期等待**来自设备的 I/O，浪费 CPU**

### 中断驱动I/O（Interrupt-Driven I/O）
- **特点**：CPU在将**应用缓冲区的内容复制到内核缓冲区并发送一个字符到打印机后**，**不会等待**打印机再次准备好，而是**调用调度程序运行其他进程**，**当前进程进入阻塞状态**。当打印机准备好时，打印机控制器会**生成硬件中断，中断处理程序会处理后续操作**。

- **代码示例**：
  
    - 打印系统调用时执行的代码：
    
      ```c
      copy_from_user(buffer, p, count); 
      enable_interrupts(); 
      while(*printer_status_reg != READY); 
      *printer_data_register = p[0]; 
      scheduler();
      ```
    
      
    
    - 中断服务程序：
    
      ```c
      if (count == 0){
          unblock_user();
      }	
      else {
          *printer_data_register = p[i];
          count = count - 1;
          i = i + 1;
      }
      acknowledge_interrupt(); 
      return_from_interrupt();
      ```

- **缺点**：==每个字符都会发生中断==

### 使用DMA的I/O（I/O using DMA）

- **特点**：DMA控制器会在**内核缓冲区和打印机控制器之间传输字符**，CPU在此过程中不会被干扰，直到整个缓冲区（字符串）传输完成才会中断CPU。

- **代码示例**：
    - 打印系统调用时执行的代码：
    
      ```c
      copy_from_user(buffer, p, count); 
      set_up_DMA_controller(); 
      scheduler();
      ```
    
    - 中断服务程序：
    
      ```c
      acknowledge_interrupt(); 
      unblock_user(); 
      return_from_interrupt();
      ```

## I/O软件的分层
- **用户空间与内核空间**：I/O软件系统分为用户空间和内核空间，内核空间负责**处理与设备相关的操作**。

    ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271121950.webp)

- **中断处理程序（Interrupt Handlers）**：
    - 最好隐藏起来，让操作系统尽量少地了解它们。
    
      - 隐藏的最佳方式是==让驱动程序启动 I/O 操作，直到中断通知完成（A down on a semaphore，A wait on a condition variable，A receive on a message）==
    
    - 通常==通过阻塞（如使用信号量、条件变量或消息传递）来等待中断完成。==
    
    - 中断处理程序**完成任务后会解除阻塞**。
    
    - 中断处理流程包括==保存部分进程状态信息、跳转到中断处理例程、发送中断确认信号、恢复进程状态信息等==。
    
      ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271224575.webp)
    
      
    
      - 中断完成后必须在软件中执行某些步骤
      - 保存中断硬件尚未保存的寄存器
      - 为中断服务程序设置上下文：TLB、MMU 和页表等
      - 设置中断服务程序的栈
      - 确认中断控制器，重新启用中断
      - 将寄存器从保存位置复制到进程表
      - 运行服务程序
      - 选择下一个要运行的过程。
      - 为下一个要运行的过程设置 MMU 上下文
      - 加载新进程的寄存器
      - 开始运行新进程
    
- **设备驱动程序（Device Drivers）**：
    - 是管理**设备控制器与操作系统之间**交互的特定模块。
    - 设备独立请求通过**设备驱动程序转换为设备依赖请求**。
    - 通常由设备制造商编写，而不是操作系统编写者。
    - 一个驱动程序**可以编写用于多个操作系统**
    - 一个驱动程序**可以处理一种类型的设备**。
    
    ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271229677.webp)
    
    - 设备驱动程序的功能包括：
      - 接受来自操作系统其余部分的**抽象读写请求**
      - 将抽象术语转换为具体术语（例如磁盘驱动程序将线性块地址转换为物理头、磁道、扇区和柱面号）
      - **初始化设备（如果需要）**
      - **检查设备是否正在被其他请求使用、排队请求**
      - **向设备发出一系列命令**
      - 检查错误等。
    - 操作系统通常**为设备驱动程序定义标准接口，以便操作系统实现者和驱动程序实现者能够明确各自的职责**。
    - 操作系统通常将驱动程序分为两类：**块设备驱动程序和字符设备驱动程序**。

## 设备独立的I/O软件

设备驱动程序和设备独立软件之间的边界因系统和设备而异。

- **功能**：
  
    - ==为设备驱动程序提供统一接口==。
    - 缓冲。
    - 错误报告。
    - **分配和释放专用设备**。
    - **提供设备独立的块大小**。
    
- **统一接口（Uniform Interfacing）**：

    - 优点：
        - 驱动程序实现者**知道他们需要实现什么**
        - 操作系统实现者可以在一个定义良好的底层驱动程序接口之上**开发与设备无关的 I/O 功能**。
        - 知道每个驱动程序**实现哪些功能以及这些功能的原型**。

    - 在Unix系统中，设备被建模为特殊文件，通过系统调用（如open()、read()、write()、close()、ioctl()等）进行访问。
    - 每个设备都有一个文件名与之关联。
    - **主设备号用于定位适当的驱动程序，次设备号（存储在i-node中）作为参数传递给驱动程序，以指定要读写的具体单元**。
    - 对设备的访问同样遵循文件的保护规则。

    ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271231792.webp)

    ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271237377.webp)

- **缓冲（Buffering）**：
    - 缓冲方式包括：无缓冲输入、用户空间缓冲、内核空间缓冲后复制到用户空间、内核空间双缓冲等。

      ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271238081.webp)

    - 网络通信可能涉及多次数据拷贝。

      ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271238377.webp)

- **错误报告（Error Reporting）**：

    - 一些错误由**设备控制器处理**（例如校验和错误，通过冗余位纠正）。
    - 一些由**设备驱动程序处理**（例如磁盘块无法读取，重新发出读取该块的请求）。
    - 一些由操作系统**设备独立软件层处理**（例如编程错误，如尝试写入只读设备；实际I/O错误，如摄像机关闭导致无法读取，返回错误指示给调用应用程序）。

- **分配专用设备（Allocating Dedicated Devices）**：==不允许对专用设备（如CD-RW）进行并发访问==。

- **设备独立的块大小（Device-independent Block Size）**：
    - 不同的磁盘驱动器可能有不同的物理扇区大小。
    - 文件系统在**将文件映射到逻辑磁盘块时使用块大小**。
    - 这一层可以隐藏不同磁盘的物理扇区大小，并为更高层（如文件系统）提供固定且统一的磁盘块大小。
    - **可以将多个扇区视为一个逻辑块**。

## 用户空间I/O软件
- 包括提供I/O函数实现的I/O库，这些函数会调用相应的I/O系统调用。
- 这些库还实现了格式化I/O函数，如printf()和scanf()。
- 有些程序不是直接写入I/O设备，而是写入一个后台打印程序（spooler）。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271243122.webp)

## 磁盘
### 磁盘类型
- **磁盘种类**：包括磁盘（如硬盘、软盘）和光盘（如CD-ROM、可写CD、可记录CD、DVD等）。
### 磁盘参数
- **组织结构**：磁盘被组织成柱面，每个柱面包含磁道，每个磁道被划分为多个扇区，扇区大小通常为512字节。

    ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271244151.webp)

- **参数示例**：
  
    - IBM 360-KB软盘：40个柱面，每个柱面2个磁道，每个磁道9个扇区，磁盘容量为360KB，相邻柱面寻道时间为6毫秒，平均寻道时间为77毫秒，旋转时间为200毫秒，传输一个扇区的时间为22毫秒。
    - Western Digital WD 30000 HLFS硬盘：36481个柱面，每个柱面255个磁道，平均每个磁道63个扇区，磁盘容量为300GB，相邻柱面寻道时间为0.7毫秒，平均寻道时间为4.2毫秒，旋转时间为6毫秒，传输一个扇区的时间为1.4微秒。
### 磁盘格式化

制造完成后，磁盘上没有信息，只有空数据。每块盘片都需要进行低级格式化，高级格式化。此后磁盘才能被使用。

- **低级格式化**：将磁盘划分为**磁盘控制器可以读写的扇区**，通常由制造商完成。
- **高级格式化**：在低级格式化的基础上，**进一步对磁盘进行格式化，使其能够被操作系统识别和使用**。
- **扇区格式**：每个磁道的扇区应按照以下方式格式化：前导码（preamble）- 数据（512字节）- **校验和（checksum）**。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271246054.webp)

### 柱面偏移（Cylinder Skew）
- 为了优化磁盘性能，磁盘的柱面可能会有一定的斜度。例如，对于一个7200-RPM的磁盘，如果其磁道到磁道的寻道时间为1毫秒，且每个磁道有200个512 字节的扇区，磁道偏移为多少？

  **解答**：7200rpm（即7200转每分钟），得到120转每秒，即 $\frac{1000}{120}=8.3 \mathrm{ms}$一转。每旋转 200 个扇区，扇区时间就是这个数值的 1/200，即 $\frac{1000}{120} \times \frac{1}{200} = \frac{1}{24}$ 毫秒。即在1ms的时间内，偏移了 24 个扇区。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271254156.webp)

### 扇区交错（Interleaving）
- 如果磁盘控制器**只有一个扇区缓冲区，在从硬盘传输一个扇区的数据到控制器缓冲区后，需要将控制器缓冲区的数据复制到内存。**此时，磁头会经过下一个扇区的起始位置（刚好滑过去了），因此**下一个逻辑扇区不应是硬盘上的下一个物理扇区，需要进行扇区交错**。
- 现代磁盘驱动器通过将整个磁道（或部分）读入磁盘控制器的缓存中来克服扇区交错问题。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271304967.webp)

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271305344.webp)

- **讨论**：
  - 如果一个磁盘具有双重交错，它是否也需要圆柱体偏斜，以避免在执行磁道间寻道时丢失数据？
  - 也许需要，也许不需要。双重交错实际上相当于两个扇区的圆柱体偏斜。**如果磁头能在少于两个扇区时间内完成磁道间寻道，那么就不需要额外的圆柱体偏斜。如果不能，那么就需要额外的圆柱体偏斜，以避免寻道后丢失一个扇区**。

### 磁盘调度算法（Disk Arm Scheduling Algorithms）
- **影响磁盘块读写时间的因素**：**寻道时间（移动磁臂到正确的柱面）、旋转延迟（等待正确的扇区到达磁头下方）、实际数据传输时间。在大多数系统中，寻道时间是主要因素。**

- 假设磁盘负载重，大量磁盘块请求正到达硬盘驱动器。驱动器队列管理这些请求，且驱动器知道每个块请求应该存储在硬盘的哪个位置（柱面号），由于在柱面之间移动（寻道时间）成本很高，我们**应该尽量减少这些寻道时间**。

- **调度算法**：
  
    - **先来先服务（FCFS）**：按照请求到达的顺序处理请求，不考虑柱面号。例如，当前磁头位置在柱面11，请求序列依次为1、36、16、34、9、12，磁头将按照这个顺序移动，
    
      - 首先磁头将移动到磁道 1 （10个柱面移动）
      - 柱面 36 下一个（35个柱面移动）
      - 柱面 16 下一个（20个柱面移动）
      - 柱面 34 下一个（18个柱面移动）
      - 柱面 9 下一个 （25个柱面移动）
      - 柱面 12 下一个（3个柱面移动） 
      - 总共移动111个柱面，成本为111。
    
    - **最短寻道优先（SSF）**：优先满足与当前位置寻道距离最短的请求。例如，对于相同的请求序列 11、1、36、16、34、9、12，最短寻道优先的顺序为11、12、9、16、1、34、36，移动磁头所需的柱面数分别为1、3、7、15、33、2，总成本为61。
    
      ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271317015.webp)
    
    - **电梯算法（Elevator Algorithm，也称SCAN算法）**：磁盘臂在一个方向上移动（从外向内或从内向外），处理该方向上的下一个请求，直到该方向上没有更多请求，然后改变方向并重复。例如，初始位置为11且初始方向向上（向更高编号的柱面移动），请求序列与前面相同，即 11、1、36、16、34、9、12，电梯算法的寻道顺序为11、12、16、34、36、9、1，移动磁头所需的柱面数分别为1、4、18、2、27、8，总成本为60。
    
      ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271318231.webp)
### 错误处理（Error Handling）
- **磁盘缺陷导致的坏块**：
    - 如果缺陷较小，让ECC（错误纠正码）进行纠正。
    - 否则，**让整个扇区变坏，并在控制器或操作系统中处理坏扇区**。
- **处理坏扇区的方法**：
    - 在控制器中处理：磁盘在发货前进行测试，**标记坏扇区并用备用扇区替换。**
    - 在操作系统中处理：**操作系统检查坏扇区并记录**。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505271319746.webp)