# 操作系统2013B

## I. 单选题（30分，每题2分）
1. (    ) 哪一项不是操作系统的作用或功能？
   - A. Extended machine  
   - C. Providing abstractions to application programs  
   - B. Resource manager  
   - D. Executing application programs  

   > ### **问题重述**
   > 题目问：**哪一项不是操作系统的作用或功能？**  
   > 选项：  
   > A. Extended machine（扩展机器）  
   > B. Resource manager（资源管理器）  
   > C. Providing abstractions to application programs（为应用程序提供抽象）  
   > D. Executing application programs（执行应用程序）  
   >
   > ---
   >
   > ### **操作系统的主要功能**
   > 1. **扩展机器（Extended Machine）**  
   >    - 操作系统通过抽象硬件（如文件系统、虚拟内存）为用户和应用程序提供更易用的接口。  
   >    - **属于核心功能**。  
   >
   > 2. **资源管理器（Resource Manager）**  
   >    - 管理CPU、内存、磁盘、I/O设备等资源，确保公平和高效分配。  
   >    - **属于核心功能**。  
   >
   > 3. **为应用程序提供抽象（Providing Abstractions）**  
   >    - 例如，将磁盘块抽象为文件，将物理内存抽象为虚拟地址空间。  
   >    - **属于核心功能**。  
   >
   > 4. **执行应用程序（Executing Application Programs）**  
   >    - ❌ **不是操作系统的直接功能**！  
   >      - 操作系统负责**加载和调度程序**，但程序的**实际执行**是由CPU完成的。  
   >      - 更准确的说法是：“操作系统管理程序的执行（如进程调度）”，而非“执行程序”。  
   >
   > ---
   >
   > ### **排除法**
   > - A、B、C 均为操作系统的经典功能。  
   > - D 的表述不严谨，**“执行”程序是CPU的职责**，操作系统仅管理执行过程。  
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：D. Executing application programs（执行应用程序）**  
   > 操作系统不直接“执行”程序，而是管理程序的加载、调度和资源分配。其他选项（扩展机器、资源管理、提供抽象）均为操作系统的核心功能。
   
2. ==(    ) 下列哪种解决临界区问题的方法会导致一个进程在临界区外运行时阻塞另一个进程？==
   
   - A. Disabling interrupts  
   - C. Strict Alternation  
   - B. Peterson’s Algorithm  
   - D. Test and Set Lock  
   
   > ### **问题重述**
   > 题目问：**下列哪种解决临界区问题的方法会导致一个进程在临界区外运行时阻塞另一个进程？**  
   > 选项：  
   > A. 禁用中断（Disabling interrupts）  
   > B. Peterson算法（Peterson’s Algorithm）  
   > C. 严格轮换（Strict Alternation）  
   > D. 测试并加锁（Test and Set Lock）  
   >
   > ---
   >
   > ### **关键概念**
   > #### **临界区问题（Critical Section Problem）**
   > - 需要确保多个进程/线程互斥访问共享资源。  
   > - 解决方案需满足：  
   >   1. **互斥（Mutual Exclusion）**：同一时间只有一个进程能进入临界区。  
   >   2. **进步（Progress）**：若无进程在临界区，应允许其他进程进入。  
   >   3. **有限等待（Bounded Waiting）**：进程不应无限期等待。  
   >
   > #### **题目要求**
   > - 方法需满足：**一个进程在临界区外运行时，会阻塞另一个进程**（即违反“进步”条件）。  
   >
   > ---
   >
   > ### **选项分析**
   > #### **A. 禁用中断（Disabling interrupts）**
   > - **方法**：在进入临界区前关闭中断，退出后开启。  
   > - **是否阻塞其他进程？**  
   >   - ❌ 不会。禁用中断仅阻止进程切换，但**不直接阻塞其他进程**。  
   >
   > #### **B. Peterson算法（Peterson’s Algorithm）**
   > - **方法**：基于共享变量（`turn` 和 `flag`）实现互斥。  
   > - **是否阻塞其他进程？**  
   >   - ❌ 不会。Peterson算法满足“进步”条件，不会无故阻塞。  
   >
   > #### **C. 严格轮换（Strict Alternation）**
   > - **方法**：强制进程按固定顺序交替进入临界区（如进程0→进程1→进程0→…）。  
   > - **是否阻塞其他进程？**  
   >   - ✅ **会**！  
   >     - 若进程0不在临界区但`turn=0`，进程1即使想进入也必须等待，**违反“进步”条件**。  
   >     - 这是题目描述的典型场景。  
   >
   > #### **D. 测试并加锁（Test and Set Lock）**
   > - **方法**：硬件指令（如`TSL`）实现自旋锁。  
   > - **是否阻塞其他进程？**  
   >   - ❌ 不会。自旋锁虽忙等待，但**不违反“进步”条件**。  
   >
   > ---
   >
   > ### **为什么是严格轮换？**
   > - **严格轮换的伪代码**：  
   >   ```c
   >   // 进程0
   >   while (TRUE) {
   >       while (turn != 0);  // 如果turn=1，进程0被阻塞
   >       critical_section();
   >       turn = 1;           // 强制交给进程1
   >   }
   >             
   >   // 进程1
   >   while (TRUE) {
   >       while (turn != 1);  // 如果turn=0，进程1被阻塞
   >       critical_section();
   >       turn = 0;           // 强制交给进程0
   >   }
   >   ```
   > - **问题**：  
   >   - 若进程0在非临界区长时间运行（如计算任务），进程1即使想进入临界区也会因`turn=0`被阻塞。  
   >   - 这种**强制轮换机制导致不必要的阻塞**。  
   >
   > ---
   >
   > ### **其他选项为何不满足？**
   > - **Peterson算法**和**TSL**通过竞争机制进入临界区，不会强制轮换。  
   > - **禁用中断**仅影响进程切换，不涉及进程间的阻塞逻辑。  
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：C. 严格轮换（Strict Alternation）**  
   > 严格轮换通过固定顺序强制交替进入临界区，**即使一个进程不在临界区，也会阻塞另一个进程**，违反了“进步”条件。其他方法（如Peterson算法、TSL）不会导致这种问题。
   
3. ==(    ) 定义一个信号量，初始值为2（表示某种资源的数量为2）。现在其值变为-1。假设M表示可用资源的数量，N表示等待该资源的进程数量，则M和N的值分别为_______。==
   
   - A. 1, 0  
   - B. 0, 1  
   - C. 2, 0  
   - D. 0, 2  
   
   **答案**：B
   
   > ### **问题重述**
   > 题目描述：  
   > - 定义一个**信号量（Semaphore）**，初始值为 **2**（表示某种资源的数量为2）。  
   > - 当前信号量的值变为 **-1**。  
   > - 设：  
   >   - **M**：可用资源的数量。  
   >   - **N**：等待该资源的进程数量。  
   >   问：**M 和 N 的值分别是多少？**  
   >   选项：  
   >   A. 1, 0  
   >   B. 0, 1  
   >   C. 2, 0  
   >   D. 0, 2  
   >
   > ---
   >
   > ### **信号量的核心规则**
   > 1. **信号量值的含义**：  
   >    - **正值（S > 0）**：表示剩余可用资源的数量（M = S）。  
   >    - **零（S = 0）**：资源已被全部分配，无进程等待（M = 0, N = 0）。  
   >    - **负值（S < 0）**：  
   >      - **|S|** 表示等待资源的进程数（N = |S|）。  
   >      - 此时可用资源数 **M = 0**（已被全部分配完）。  
   >
   > 2. **题目分析**：  
   >    - 初始值 = 2（资源数 = 2）。  
   >    - 当前值 = -1：  
   >      - **M = 0**（资源已全部分配完）。  
   >      - **N = |-1| = 1**（1个进程在等待）。  
   >
   > ---
   >
   > ### **验证选项**
   > - **A. 1, 0**：错误（信号量为负时，M 必须为 0）。  
   > - **B. 0, 1**：✅ 正确（M = 0, N = 1）。  
   > - **C. 2, 0**：错误（信号量不为 2）。  
   > - **D. 0, 2**：错误（N 应为 1，非 2）。  
   >
   > ---
   >
   > ### **为什么是 B？**
   > - 信号量从 2 变为 -1，说明：  
   >   1. 2 个资源被分配完（M = 0）。  
   >   2. 1 个进程因请求资源被阻塞（N = 1）。  
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：B. 0, 1**  
   > 信号量值为 -1 时：  
   > - **可用资源数 M = 0**（资源已全部分配）。  
   > - **等待进程数 N = 1**（1 个进程因无法获取资源被阻塞）。
   
5. (    ) 128MB内存以n字节为单位分配。使用链表跟踪空闲内存。假设内存由64KB的段和空洞交替组成。假设链表中的每个节点需要一个32位内存地址、一个16位长度和一个16位的下一个节点字段。在位图方法中需要多少字节的存储空间？
   - A. $2^{27}$/n  
   - B. $2^{24}$/n  
   - C. $2^{11}$  
   - D. $2^{14}$

   **答案**：B
   
   > ### **问题重述**
   > 题目描述：  
   > - **内存大小**：128 MB（$ 2^{27} $ 字节）。  
   > - **分配单位**：以 **n 字节** 为单位分配内存。  
   > - **内存布局**：由 **64 KB 的段和空洞交替组成**（即有效内存区域和空闲区域交替）。  
   > - **链表节点结构**：  
   >   - 32 位（4 字节）内存地址。  
   >   - 16 位（2 字节）长度。  
   >   - 16 位（2 字节）下一节点指针。  
   >   - **每个节点总大小**：4 + 2 + 2 = 8 字节。  
   > - **问题**：**若改用位图（bitmap）方法跟踪空闲内存，需要多少字节的存储空间？**  
   > 选项：  
   > A. $ 2^{27}/n $  
   > B. $ 2^{24}/n $  
   > C. $ 2^{11} $  
   > D. $ 2^{14} $  
   >
   > ---
   >
   > ### **关键概念**
   > #### **1. 位图（Bitmap）方法**
   > - 用 **1 bit** 表示 **1 个分配单位（n 字节）** 的状态：  
   >   - `1`：已分配。  
   >   - `0`：空闲。  
   > - **位图大小计算公式**：  
   >   $$
   >   \text{位图大小（字节）} = \frac{\text{内存总大小}}{\text{分配单位} \times 8} = \frac{2^{27}}{n \times 8} = \frac{2^{24}}{n}
   >   $$
   >
   > #### **2. 题目中的干扰信息**
   > - **链表节点结构**：与位图无关，仅用于对比。  
   > - **64 KB 段和空洞交替**：不影响位图大小计算（位图需覆盖全部内存）。  
   >
   > ---
   >
   > ### **计算过程**
   > 1. **内存总大小**：128 MB = $ 2^{27} $ 字节。  
   > 2. **分配单位**：n 字节。  
   > 3. **位图位数**：  
   >    - 需要 $ \frac{2^{27}}{n} $ 个 bit 来表示每个分配单位。  
   > 4. **位图字节数**：  
   >    $$
   >    \frac{2^{27}}{n \times 8} = \frac{2^{24}}{n}
   >    $$
   >
   > ---
   >
   > ### **验证选项**
   > - **A. $ 2^{27}/n $**：错误（未除以 8，单位是 bit 而非字节）。  
   > - **B. $ 2^{24}/n $**：✅ 正确（$ \frac{2^{27}}{n \times 8} = \frac{2^{24}}{n} $）。  
   > - **C. $ 2^{11} $**：无关（常数，与 n 无关）。  
   > - **D. $ 2^{14} $**：无关（常数，与 n 无关）。  
   >
   > ---
   >
   > ### **为什么是 B？**
   > 位图方法的核心是 **用 1 bit 表示 1 个分配单位**，因此总字节数为：  
   > $$
   > \frac{\text{内存大小}}{\text{分配单位} \times 8} = \frac{2^{27}}{n \times 8} = \frac{2^{24}}{n}
   > $$
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：B. $ 2^{24}/n $**  
   > 位图方法需要 $ \frac{2^{24}}{n} $ 字节的存储空间来跟踪 128 MB 内存的空闲状态（按 n 字节为单位分配）。
   
7. (    ) 下列哪个陈述是正确的？
   - A. 使用TLB的分页内存系统消除了在内存中保留页表的需要。  
   - B. 频繁使用紧凑化可以防止外部碎片，但成本对大多数系统来说过高。  
   - C. 首次适应分配算法通常会创建无法使用的较小空洞。  
   - D. 更多的页面框总是有更少的页面错误。  

   > ### **问题重述**
   > 题目问：**下列哪个陈述是正确的？**  
   > 选项：  
   > A. 使用TLB的分页内存系统消除了在内存中保留页表的需要。  
   > B. 频繁使用紧凑化可以防止外部碎片，但成本对大多数系统来说过高。  
   > C. 首次适应分配算法通常会创建无法使用的较小空洞。  
   > D. 更多的页面框总是有更少的页面错误。  
   >
   > ---
   >
   > ### **逐项分析**
   > #### **A. 使用TLB的分页内存系统消除了在内存中保留页表的需要**
   > - **TLB（Translation Lookaside Buffer）** 是页表的缓存，用于加速地址转换。  
   > - **错误原因**：  
   >   - TLB **无法完全取代页表**，因为TLB容量有限，未命中的仍需查页表。  
   >   - 页表必须保留在内存中，以支持TLB未命中时的查找。  
   >
   > #### **B. 频繁使用紧凑化可以防止外部碎片，但成本对大多数系统来说过高**
   > - **紧凑化（Compaction）**：通过移动进程内存位置合并空闲碎片。  
   > - **正确性**：  
   >   - ✅ **正确**。紧凑化确实能消除外部碎片，但需**重定位所有进程**，导致高CPU开销，实践中很少频繁使用。  
   >
   > #### **C. 首次适应分配算法通常会创建无法使用的较小空洞**
   > - **首次适应（First-Fit）**：从内存起始处搜索第一个足够大的空闲块。  
   > - **错误原因**：  
   >   - 首次适应可能产生**外部碎片**，但“无法使用的较小空洞”更符合**最坏适应（Worst-Fit）**的特点。  
   >   - 首次适应实际表现较好，碎片问题不如最佳适应（Best-Fit）严重。  
   >
   > #### **D. 更多的页面框总是有更少的页面错误**
   > - **页面框（Page Frames）与缺页（Page Faults）的关系**：  
   >   - **Belady现象**：在某些情况下（如FIFO算法），增加页面框反而可能导致更多缺页。  
   >   - **错误原因**：  
   >     - “总是”过于绝对，实际取决于页面置换算法和访问模式。  
   >
   > ---
   >
   > ### **关键结论**
   > - **B** 是唯一完全正确的陈述。  
   > - 其他选项（A、C、D）均存在理论或实践上的错误。  
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：B. 频繁使用紧凑化可以防止外部碎片，但成本对大多数系统来说过高。**  
   > 紧凑化能解决外部碎片，但因其高开销（需移动进程内存），实际系统（如Linux、Windows）通常避免频繁使用。其他选项的表述不严谨或错误。
   
8. ==(    ) 下列哪种实现文件存储的方法可以轻松支持随机访问？==
   
   - A. Contiguous allocation  
   - C. Linked list allocation using FAT  
   - B. Linked list allocation  
   - D. none of the above  
   
   > ### **问题重述**
   > 题目问：**下列哪种实现文件存储的方法可以轻松支持随机访问？**  
   > 选项：  
   > A. 连续分配（Contiguous allocation）  
   > B. 链表分配（Linked list allocation）  
   > C. 使用FAT的链表分配（Linked list allocation using FAT）  
   > D. 以上都不是  
   >
   > ---
   >
   > ### **关键概念**
   > #### **随机访问（Random Access）**
   > - **定义**：直接访问文件的任意位置（如`fseek()`），无需顺序读取。  
   > - **核心要求**：快速定位目标数据块在磁盘上的物理位置。  
   >
   > ---
   >
   > ### **选项分析**
   > #### **A. 连续分配（Contiguous allocation）**
   > - **方法**：文件占用连续的磁盘块。  
   > - **随机访问支持**：  
   >   - ✅ **优秀**。  
   >   - 通过 `起始地址 + 偏移量` 可直接计算目标块位置，时间复杂度 **O(1)**。  
   >
   > #### **B. 链表分配（Linked list allocation）**
   > - **方法**：每个块包含指向下一块的指针。  
   > - **随机访问支持**：  
   >   - ❌ **差**。  
   >   - 必须从头遍历链表，时间复杂度 **O(n)**。  
   >
   > #### **C. 使用FAT的链表分配（Linked list allocation using FAT）**
   > - **方法**：文件分配表（FAT）集中存储块间的链接关系。  
   > - **随机访问支持**：  
   >   - ✅ **较好**。  
   >   - 通过FAT表可直接跳转，但需多次查表（FAT可能较大），时间复杂度 **O(k)**（k为跳转次数）。  
   >
   > #### **D. 以上都不是**
   > - ❌ 错误，A和C均支持随机访问。  
   >
   > ---
   >
   > ### **对比A与C**
   > - **连续分配**：  
   >   - 随机访问最快（直接计算），但易产生**外部碎片**。  
   > - **FAT链表分配**：  
   >   - 随机访问需查表，速度稍慢，但无碎片问题。  
   >
   > 题目问“**轻松支持**”，**连续分配（A）**是最直接高效的方案。  
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：A. 连续分配（Contiguous allocation）**  
   > 连续分配通过简单的地址计算即可实现随机访问，是**最轻松高效**的方法。FAT链表分配（C）虽支持随机访问，但需额外查表步骤。
   
9. (    ) 文件引用计数用于______。
   - A. 计算从文件中读取的字节数。  
   - B. 计算打开文件的数量。  
   - C. 计算指向文件的链接数量。  
   - D. 计算访问文件的进程数量。  

   > ### **问题重述**
   > 题目问：**文件引用计数用于______。**  
   > 选项：  
   > A. 计算从文件中读取的字节数。  
   > B. 计算打开文件的数量。  
   > C. 计算指向文件的链接数量。  
   > D. 计算访问文件的进程数量。  
   >
   > ---
   >
   > ### **关键概念**
   > #### **文件引用计数（Reference Count）**
   > - **定义**：记录**指向文件的硬链接（Hard Links）数量**的计数器。  
   > - **作用**：  
   >   - 当引用计数降为0时，文件系统可安全删除该文件的磁盘空间（无任何链接指向它）。  
   > - **场景**：  
   >   - 每创建一个硬链接，引用计数 +1。  
   >   - 每删除一个硬链接（或原文件），引用计数 -1。  
   >
   > ---
   >
   > ### **选项分析**
   > #### **A. 计算从文件中读取的字节数**
   > - ❌ 错误。  
   >   - 读取字节数由文件偏移量（Offset）或统计工具（如`wc`）记录，与引用计数无关。  
   >
   > #### **B. 计算打开文件的数量**
   > - ❌ 错误。  
   >   - 打开文件的数量由内核文件描述符表管理，引用计数不跟踪此信息。  
   >
   > #### **C. 计算指向文件的链接数量**
   > - ✅ **正确**。  
   >   - 引用计数直接记录硬链接数（包括原文件本身和所有硬链接）。  
   >
   > #### **D. 计算访问文件的进程数量**
   > - ❌ 错误。  
   >   - 进程访问数可能通过其他机制（如`lsof`）统计，但引用计数不涉及此功能。  
   >
   > ---
   >
   > ### **技术验证**
   > - **Unix/Linux示例**：  
   >   ```bash
   >   # 创建文件
   >   touch file.txt
   >   # 查看引用计数（初始为1）
   >   ls -l file.txt
   >   # 输出：... 1 user group ... file.txt
   >   # 创建硬链接
   >   ln file.txt link1
   >   # 引用计数变为2
   >   ls -l file.txt
   >   # 输出：... 2 user group ... file.txt
   >   ```
   >   - 引用计数的变化仅与硬链接相关。  
   >
   > ---
   >
   > ### **中文答案**
   > **正确答案：C. 计算指向文件的链接数量**  
   > 文件引用计数用于跟踪**硬链接的数量**（包括原文件），确保文件在无引用时被正确回收。其他选项（读取字节数、打开文件数、进程访问数）与引用计数无关。
   
10. (    ) 读取文件`/home/courses/os/test/A.doc`的第三个块需要多少次磁盘操作？假设根目录的i-node在内存中，但路径上的其他内容不在内存中。
    - A. 9  
    - B. 10  
    - C. 11  
    - D. 12  

    > ### **问题重述**
    > 题目描述：  
    > - 读取文件 `/home/courses/os/test/A.doc` 的**第三个块**。  
    > - **假设条件**：  
    >   - 根目录的 i-node 已在内存中。  
    >   - 路径上的其他内容（如 `/home`、`/courses` 等）**不在内存中**。  
    > - 问：**需要多少次磁盘操作？**  
    > 选项：  
    > A. 9  
    > B. 10  
    > C. 11  
    > D. 12  
    >
    > ---
    >
    > ### **关键概念**
    > #### **1. Unix文件系统路径解析**
    > 每次解析路径的一个组件（如 `/home`、`/courses` 等）需要：  
    > 1. **读取目录的i-node**（若不在内存中，需从磁盘加载）。  
    > 2. **读取目录的数据块**（查找下一级目录的i-node号）。  
    >
    > #### **2. 读取文件块的操作**
    > - 找到文件的i-node后，读取其第3个块需：  
    >   1. 从i-node的**直接/间接指针**中找到目标块的磁盘地址。  
    >   2. **读取该磁盘块**（若块指针或数据块不在内存中，需磁盘操作）。  
    >
    > ---
    >
    > ### **路径解析的磁盘操作**
    > 路径 `/home/courses/os/test/A.doc` 的组件：  
    > 1. `/`（根目录，i-node已在内存，无需磁盘操作）。  
    > 2. `home`：  
    >    - 读取 `/` 的数据块（磁盘操作1）。  
    >    - 加载 `home` 的i-node（磁盘操作2）。  
    > 3. `courses`：  
    >    - 读取 `home` 的数据块（磁盘操作3）。  
    >    - 加载 `courses` 的i-node（磁盘操作4）。  
    > 4. `os`：  
    >    - 读取 `courses` 的数据块（磁盘操作5）。  
    >    - 加载 `os` 的i-node（磁盘操作6）。  
    > 5. `test`：  
    >    - 读取 `os` 的数据块（磁盘操作7）。  
    >    - 加载 `test` 的i-node（磁盘操作8）。  
    > 6. `A.doc`：  
    >    - 读取 `test` 的数据块（磁盘操作9）。  
    >    - 加载 `A.doc` 的i-node（磁盘操作10）。  
    >
    > #### **读取文件第3块**
    > - 从 `A.doc` 的i-node中读取第3块的指针（通常i-node已在内存，但若块指针未缓存，可能需要**1次磁盘操作**）。  
    > - 读取第3块的数据（磁盘操作11）。  
    >
    > ---
    >
    > ### **总计**
    > - **路径解析**：10次磁盘操作（加载每个目录的i-node和数据块）。  
    > - **读取文件块**：1次磁盘操作（假设i-node已在内存，仅需读数据块）。  
    > - **总操作数**：11次。  
    >
    > ---
    >
    > ### **排除法**
    > - **A. 9**：未计入所有目录的i-node加载。  
    > - **B. 10**：可能漏计文件数据块的读取。  
    > - **C. 11**：✅ 正确。  
    > - **D. 12**：多算1次。  
    >
    > ---
    >
    > ### **中文答案**
    > **正确答案：C. 11**  
    > 解析路径需要 **10次磁盘操作**（加载各目录的i-node和数据块），读取文件第3块需 **1次磁盘操作**，总计 **11次**。
    
13. (    ) “设备独立性”意味着______。
    - A. 设备的访问依赖于其型号和物理设备类型。  
    - B. 系统有一组用于在文件和控制台（终端）上写入的调用，表现出设备独立性。  
    - C. 文件和设备被以同样的方法访问，独立于其物理性质。  
    - D. none of the above  

    > ### **问题重述**
    > 题目问：**“设备独立性”意味着______。**  
    > 选项：  
    > A. 设备的访问依赖于其型号和物理设备类型。  
    > B. 系统有一组用于在文件和控制台（终端）上写入的调用，表现出设备独立性。  
    > C. 文件和设备被以同样的方法访问，独立于其物理性质。  
    > D. 以上都不是。  
    >
    > ---
    >
    > ### **关键概念**
    > #### **设备独立性（Device Independence）**
    > - **定义**：应用程序无需关心具体硬件设备的细节（如型号、物理特性），只需通过**统一接口**访问设备。  
    > - **核心思想**：  
    >   - **抽象化**：将设备抽象为文件（如Unix的“一切皆文件”）。  
    >   - **统一访问**：通过相同的系统调用（如`read()`、`write()`）操作文件和设备。  
    >
    > ---
    >
    > ### **选项分析**
    > #### **A. 设备的访问依赖于其型号和物理设备类型**
    > - ❌ **错误**。  
    >   - 设备独立性的核心是**隐藏物理细节**，而非依赖它们。  
    >
    > #### **B. 系统有一组用于在文件和控制台（终端）上写入的调用，表现出设备独立性**
    > - ✅ **部分正确**，但表述不完整。  
    >   - 虽然Unix通过`write()`统一访问文件和设备，但选项未明确“独立于物理性质”这一关键点。  
    >
    > #### **C. 文件和设备被以同样的方法访问，独立于其物理性质**
    > - ✅ **最佳答案**。  
    >   - 直接体现了设备独立性的核心：**统一接口 + 物理透明性**。  
    >   - 例如：`write(fd, buf, size)` 可向文件、打印机、终端等写入，无需关心底层硬件差异。  
    >
    > #### **D. 以上都不是**
    > - ❌ 错误，C正确。  
    >
    > ---
    >
    > ### **为什么不是B？**
    > - B仅描述现象（统一调用），未揭示本质（独立于物理性质）。  
    > - C更全面，明确点出“独立于物理性质”这一关键。  
    >
    > ---
    >
    > ### **中文答案**
    > **正确答案：C. 文件和设备被以同样的方法访问，独立于其物理性质。**  
    > 设备独立性的核心是**通过统一接口屏蔽硬件差异**，使应用程序无需关心设备的具体实现（如磁盘型号、打印机协议）。选项C准确概括了这一理念。
    
15. (    ) 磁盘请求按顺序到达磁盘驱动器，请求的柱面为9, 35, 22, 16, 40, 11和2。假设磁臂最初位于柱面12。对于电梯算法（假设磁臂最初向柱面0移动），磁臂移动的总距离（以柱面为单位）是多少？
    - A. 48  
    - B. 66  
    - C. 72  
    - D. 75  
    
    **答案**：A
    
    12，11，9，2，16，22，35，40
    
    1+2+7+14+6+13+5=48。

## II. 简答题（20分，每题5分）
1. **进程与线程的区别是什么？使用线程有哪些好处？**

   - **进程**
     - 资源所有权的单位，与程序的执行相关。
     - 可以包含多个执行线程。
     - 进程之间相对独立。
     - 创建成本高。
     - 上下文切换成本高。
   - **线程**
     - 执行的单位。
     - 属于某个进程。
     - 线程是同一“作业”的一部分，紧密合作。
     - 创建成本低。
     - 同一进程内的上下文切换成本低。
   - **优点**
     - 创建线程比创建进程便宜（约10-20倍）。
     - 在同一进程中切换到不同线程的成本低（5-50倍）。
     - 同一进程内的线程可以更方便、高效地共享数据和其他资源（无需复制或消息传递）。
     - 同一进程内的线程之间没有保护。

2. **如果磁盘采用双倍交错，是否还需要柱面偏移以避免在进行磁道到磁道寻道时丢失数据？简要解释你的答案。**

3. **在分页系统中，页表可能非常大，需要大量内存空间。给出两种可能的解决方案，并简要解释。**

   > #### （1）**多级页表（Hierarchical Page Table）**
   >
   > - **原理**：将页表分层（如二级、三级页表），每级页表仅存储下一级页表的地址。例如，二级页表中，一级页表的每个条目指向一个二级页表，仅当需要访问某部分地址空间时，才加载对应的下级页表到内存。
   > - **优势**：避免一次性加载完整页表，减少内存占用。例如，64 位系统若采用单级页表可能需数 GB 内存，而多级页表可将内存占用降至 MB 级。
   >
   > #### （2）**哈希页表（Hash Page Table）**
   >
   > - **原理**：通过哈希函数将虚拟页号映射到页表项，页表存储哈希表条目（含虚拟页号、物理页帧号及冲突链表指针）。访问时，先计算虚拟页号的哈希值，再查找哈希表获取物理地址。
   > - **优势**：适用于稀疏地址空间（如大地址空间中仅部分地址被使用），无需为未使用的地址分配页表项，节省内存。

4. **硬链接和符号链接的区别是什么？**

   > ### 3. **硬链接与符号链接的区别**
   >
   > | **维度**       | **硬链接（Hard Link）**                                      | **符号链接（Symbolic Link）**                              |
   > | -------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
   > | **本质**       | 同一文件的多个目录项，共享同一个 inode（文件索引节点）。     | 独立文件，存储目标文件的路径字符串（类似快捷方式）。       |
   > | **存储内容**   | 不存储文件数据，仅指向 inode 编号。                          | 存储目标文件的绝对或相对路径。                             |
   > | **跨文件系统** | 不能跨文件系统（因 inode 编号仅在本文件系统内唯一）。        | 可以跨文件系统（路径指向不受文件系统限制）。               |
   > | **删除影响**   | 删除硬链接不影响文件，仅当所有硬链接和原文件均被删除时，文件才被删除。 | 删除目标文件后，符号链接失效（变为 “broken link”）。       |
   > | **权限**       | 与原文件共享权限，无法独立设置。                             | 作为独立文件，可单独设置权限，但访问时受目标文件权限限制。 |
   > | **示例**       | `ln source_file link_file`（创建硬链接）。                   | `ln -s target_file symlink_file`（创建符号                 |

## III. 综合题（50分，每题10分）
1. **考虑以下使用信号量S1、S2和S3的3进程并发程序。信号量操作有时被称为“等待”和“信号”，这里用经典的“P”和“V”表示。**

   | Process 1   | Process 2   | Process 3   |
   | ----------- | ----------- | ----------- |
   | L1: P(S3);  | L2: P(S1);  | L3: P(S2);  |
   | print(“T”); | print(“U”); | print(“B”); |
   | V(S2);      | V(S3);      | V(S1);      |
   | goto L1;    | goto L2;    | goto L3;    |

   1) 假设初始值为S1=0, S2=0, S3=0。进程是否可以合作生成以BBTTUTT开头的字符串？解释你的答案。（5分）
   2) 是否可以为信号量分配初始值，以便进程合作打印字符串BUTBUTBUTBU？如果可以，请给出信号量的初始值（说明哪个信号量使用哪个值），并解释如何打印该字符串。（5分）
