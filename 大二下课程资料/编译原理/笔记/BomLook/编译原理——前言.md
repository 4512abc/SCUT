# 编译原理——前言

## 前言

> What is Compiler?
>
> Compilers are computer programs that translate programs from one language to another

源程序输入到Compiler中，得到目标程序，我们利用目标程序，将数据输入其中，得到运算结果

- 源程序通常使用高级语言进行编写，目标程序通常由机器语言或者汇编语言构成，服务于目标机器



### 现代编译器

现代编译器的结构与传统的编译器结构有所不同：

传统编译器：

- 词法分析，语法分析，语义分析，代码生成，优化

现代编译器：

- 词法分析，语法分析，语义分析，IR生成，IR优化，代码生成，优化
- 这里的IR是一层中间语言，详情可以了解LLVM
- 在现代编译器中，前四部分归为前端，后三部分归为后端

一个编译器的工作流程如下：

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202504081125725.webp)

现代编译器的工作流程是一个多阶段的自动化过程，将高级编程语言（Source code）转换为可执行的目标代码（Target code），其核心流程和辅助组件可概括如下：



---

#### **1. 词法分析（Scanner）**

- **输入**：源代码字符流  
- **处理**：扫描器将代码拆解为有意义的词法单元（**Tokens**），如关键字、标识符、运算符等。  
- **输出**：Token序列（例如：`int x = 5;` → `[int, x, =, 5, ;]`）。  
- **辅助组件**：字面量表（Literal table）记录常量值（如数字、字符串）。

---

#### **2. 语法分析（Parser）**

- **输入**：Token序列  
- **处理**：解析器根据语言语法规则构建**语法树（Syntax Tree）**，检查结构合法性（如括号匹配、语句格式）。  
- **输出**：树状结构表示代码的层次关系（例如：`x = 5` → 赋值节点包含变量`x`和常量`5`）。  
- **错误处理**：若语法错误（如缺少分号），错误处理器（Error Handler）会报告位置和类型。

---

#### **3. 语义分析（Semantic Analyzer）**

- **输入**：语法树  
- **处理**：分析变量类型、作用域、函数调用等语义规则，生成带类型标注的**注释树（Annotated Tree）**。  
- **辅助组件**：符号表（Symbol Table）记录变量类型、内存地址等上下文信息。  
- **示例**：检查`int x = "text";`会触发类型不匹配错误。

---

#### **4. 中间代码生成与优化**

- **生成（Intermediate Code Generator）**：将注释树转换为平台无关的**中间代码**（如三地址码、LLVM IR）。  
- **优化（Intermediate Code Optimizer）**：删除冗余计算、常量传播等，提升效率但不改变逻辑。  
- **示例**：`y = x * 1` → 优化为`y = x`

---

#### **5. 目标代码生成与优化**

- **生成（Code Generator）**：将中间代码映射到目标机器的指令集（如x86汇编）。  
- **优化（Target Code Optimizer）**：针对硬件特性优化（如寄存器分配、指令调度）。  
- **示例**：用移位指令替代乘法以提高速度。

---

#### **辅助组件贯穿全程**

- **符号表**：管理变量生命周期，确保作用域和类型一致。  
- **错误处理器**：在各阶段捕获错误（如未声明变量、类型冲突）。  
- **字面量表**：集中存储常量以减少重复内存分配。

---

#### **流程特点**

- **分阶段设计**：各阶段职责明确，便于维护和扩展（如替换优化算法）。  
- **多轮优化**：中间代码和目标代码均优化，平衡通用性与硬件性能。  
- **错误恢复**：部分编译器会尝试修复错误（如插入缺失符号）以继续后续分析。

通过这一流程，编译器实现了从高级语言到高效机器代码的可靠转换。



### 语言处理

编译器和解释器都是我们所熟悉的语言编写系统，两者的区别主要在：

- 解释器是同时将**源程序和数据输入到解释器中，得到输出。解释器在翻译程序指令的过程中，执行源程序；编译器是在翻译完成后，生成可执行的目标代码**

- **解释器基本没有预处理或者优化，而编译器存在预处理和优化**



除了上述两者外，还有一种混合的方法，常见的例子有Java

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202504081139499.webp)

Java的工作流程是一个典型的「一次编写，到处运行」的跨平台执行模型，其核心流程可分为以下五个阶段：

---

#### **1. Java源代码（.java文件）**

- **输入**：开发者编写的文本格式源代码（如`HelloWorld.java`），符合Java语法规范。  
- **特点**：可能以单个文件或压缩包（zip）形式存在，包含类、方法、变量等结构。

---

#### **2. Java编译器（javac）**

- **处理**：  
  - 编译器（`javac`命令）对源代码进行**词法分析、语法分析、语义检查**，生成与平台无关的中间代码。  
- **不生成机器码**，而是转换为**字节码（Bytecode）**，存储为`.class`文件（如`HelloWorld.class`）。  
- **关键特性**：  
  - 字节码是JVM的指令集，类似汇编但更抽象，确保跨平台性。  
  - 编译阶段会检查语法错误（如缺少分号）和基础语义错误（如类型不匹配）。

---

#### **3. 字节码加载（Bytecode Loader）**

- **加载时机**：当程序运行时（如执行`java HelloWorld`），JVM的**类加载器（ClassLoader）**动态加载所需的`.class`文件。  
- **分层加载**：  
  - **Bootstrap ClassLoader**：加载核心JRE库（如`java.lang`）。  
  - **用户类加载器**：加载开发者编写的类。  
  - **验证机制**：确保字节码符合JVM规范（如无非法内存访问）。

---

#### **4. 字节码解释与执行（Bytecode Interpreter）**

- **解释方式**：  
  - JVM内置的解释器逐条读取字节码指令，将其转换为当前操作系统的**本地机器码**执行。  
  - **即时编译（JIT）优化**：热点代码（频繁执行的代码）会被JIT编译器编译为本地机器码缓存，加速后续执行。  
- **跨平台关键**：同一份字节码在不同平台的JVM上通过解释/编译适配本地环境。

---

#### **5. 执行环境（Execution Environment）**

- **运行时支持**：  
  - **内存管理**：自动垃圾回收（GC）处理对象内存分配与释放。  
  - **安全检查**：字节码验证器（Verifier）防止恶意代码（如栈溢出攻击）。  
  - **系统调用**：通过JVM与操作系统交互（如文件读写、网络通信）。 
- **输出结果**：程序逻辑在JVM管理的沙箱环境中运行，最终输出预期结果或错误信息。

---

#### **流程特点总结**

1. **跨平台性**：字节码作为中间层，屏蔽操作系统差异。  
2. **动态性**：类加载机制支持运行时动态扩展（如反射、热部署）。  
3. **安全沙箱**：字节码验证和JVM隔离机制增强安全性。  
4. **性能平衡**：解释执行 + JIT编译兼顾启动速度和长时运行效率。

---

#### **图示流程补充说明**

- **箭头方向**：清晰展示从源代码到最终执行的线性流程。  
- **黑白设计**：突出流程的简洁性，符合Java「避免复杂性」的设计哲学。  
- **关键组件标注**：强调各阶段的核心模块（如编译器、解释器）及其协作关系。

这一流程是Java「Write Once, Run Anywhere」的核心实现机制。



更一般的流程如下

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202504081146610.webp)

