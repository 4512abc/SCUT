# 编译原理——语法分析
- ## 语法分析
- ### 什么是语法分析？
  
  在经过词法分析之后，我们得到了一系列的tokens。我们将恢复这些 token 所描述的关系，并且判断这些 token 编码是否正确。
  
  通俗地讲：我们是在理解了每一个token的含义的基础上，理解他们所构成的语句。
- 输入：解析器通过调用扫描程序，不断获取下一个标记
- 输出：构建显式或者隐式抽象语法树
  
  在正式介绍语法分析的算法之前，我们需要先解决一个问题
- ### 正则表达式的局限性
  
  假设我们现在有一个字符表 $\Sigma = \{a,b\}$，想要构造一个只含有一个 $b$ 且前后缀都是长度相同的由 $a$ 构成的字符串，表示为：
  $$
  S=\{a^nba^n | n \geq 0, n \in \mathbb{Z}\}
  $$
  然而正则表达式无法描述该结构。此外正则表达式还有如下缺陷：
- 无法使用正则表达式匹配**所有括号完全平衡**的表达式
- 无法匹配**所有具有正确嵌套块结构**的函数：如 `if {} else {}`
  
  基于此，我们介绍一种新的工具——上下文无关文法（Context-Free Grammar,CFG），其将用于解决语法分析的问题。
- ### CFG
  
  
  
  ---
- #### 简短速览
  
  CFG 与正则表达式，但是其**支持递归规则**。CFG 是正则语言的严格超集，即所有的正则语言都可以使用 CFG 描述，但是反之不成立。
  
  CFG 通过 **产生式** 递归定义语言的语法，是语法分析的理论基础。 
  
  其优势主要在于**支持递归规则**：允许非终结符引用自身，从而描述无限嵌套。
  
  示例：
  
  ```CFG
  <expr> → <expr> + <term> | <term>      # 表达式递归  
  <block> → { <statements> }             # 代码块嵌套  
  ```
- ##### 核心组成
  
  **终结符（Terminals, VT）**
- **不可再分解**的基本符号，对应词法分析后的**Token**（如 `+`, `if`, `123`, `"hello"`）。
- **使用小写字母表示（按照PPT定义）**
- 示例：在算术表达式中，数字和运算符是终结符。  
  
  **非终结符（Non-terminals, VN）**
- **语法结构的占位符**，需要通过产生式进一步展开（如 `<expr>`, `<statement>`）。
- 使用大写字母或者尖括号包裹的名称（如 `<expr>` `<stmt>`）（按照PPT定义）
- 示例：`<if-statement> → if (<condition>) <statement>` 中的 `<if-statement>`。  
  
  **产生式（Productions）**
- 定义非终结符如何分解为终结符或其他非终结符，形式为：  
  
  $$
  A \rarr \alpha   （A: 非终结符，\alpha: 终结符/非终结符组成的序列）
  $$
- 若同一非终止符 $A$ 由多条产生式子（如 $A \rarr \alpha_1,A\rarr \alpha_2...$），可合并为一条，用竖线分隔开来（即 $A \rarr \alpha_1 | \alpha_2 | \alpha_3|...$）
- 示例：  
  
  ```  
  <expr> → <expr> + <term> | <term>  
  <term> → <term> * <factor> | <factor>  
  ```
  
  **开始符号（Start Symbol, S）**
- 文法的顶层非终结符，所有推导从此开始。
- 示例：`<program>` 可能是整个程序的开始符号。  
  
  ---
- ##### 关键特性  
  
  1. **上下文无关性**
	- 非终结符的展开**不依赖其上下文**（即无论 `A` 出现在哪里，规则 $A \rarr \alpha$ 都适用）。
	- 区别于**上下文有关文法**（如自然语言中，单词变形可能依赖相邻词）。  
	  2. **递归定义**
	- 非终结符可以**直接或间接引用自身**，支持无限结构的描述。
	- 示例：`<list> → <item> | <item>, <list>` 定义了逗号分隔的列表。  
	  3. **生成的语言**
	- 所有能从开始符号 `S` 通过产生式推导出的**终结符串的集合**，称为**上下文无关语言（CFL）**。  
	  
	  ---
- ##### 示例：简单算术表达式  
  
  **文法规则**：  
  
  ```  
  <expr> → <expr> + <term> | <term>  
  <term> → <term> * <factor> | <factor>  
  <factor> → (<expr>) | number  
  ```
  
  **推导过程**（生成 `3 + 5 * 2`）：  
  
  1. `<expr>` → `<expr> + <term>`  
  2. `<expr> + <term>` → `<term> + <term>` → `<factor> + <term>` → `number + <term>`  
  3. `number + <term>` → `3 + <term> * <factor>` → `3 + <factor> * <factor>` → `3 + number * number`  
  4. 最终：`3 + 5 * 2`  
  
  ---
- ##### 局限性  
  
  1. **无法描述所有语言**
	- 例如，`{aⁿbⁿcⁿ | n ≥ 1}`（要求 `a, b, c` 数量相等）需要**上下文有关文法**。  
	  
	  2. **二义性（Ambiguity）**
	- 某些文法允许同一字符串有**多棵语法树**，需通过改写规则或优先级声明解决。
	- 经典二义性案例：  
	  
	  ```  
	  <expr> → <expr> + <expr> | <expr> * <expr> | number  
	  ```
	  
	  字符串 `1 + 2 * 3` 可被解析为 `(1 + 2) * 3` 或 `1 + (2 * 3)`。
- #### 详细解释
- ##### 推导
  
  推导是由一系列推导步骤构成的。例如，从初始符号 $S$ 开始，经过多次推导步骤，如 $S \Rightarrow aS \Rightarrow aaS \Rightarrow aab$，这整个过程就是一个推导。通过推导，可以从文法的初始符号出发，生成该文法所定义语言中的字符串。 （可能看了有些懵逼，可以看看下面的详细解释）
- **推导的作用**
	- 上下文无关文法规则确定了在语法上合法的词法单元（标记）字符串的集合。
	- 例如：对应于如下文法
		- 表达式（exp）的规则：`exp → exp op exp | (exp) | number` （意思是一个表达式可以是 一个表达式加上一个运算符再加上一个表达式，或者是一个用括号括起来的表达式，或者是一个数字）
		- 运算符（op）的规则：`op → + | - | *` （即运算符可以是加号、减号或者乘号）
	- `(34 - 3) * 42` 是一个合法的字符串。因为它可以**根据上述文法规则推导**出来，比如先把 34 和 3 看作是“exp”，“-”看作是“op”，得到“exp op exp”形式，然后整体加上括号又符合“(exp)”，再和 42 以及“*”组成更大的“exp op exp”形式。
	- `(34 - 3 * 42` 不是一个合法的字符串。因为这个字符串的括号不匹配，根据给定的文法规则无法推导出来一个合法的表达式结构。
	- 文法规则通过推导或归约的方式来确定合法的词法单元字符串。推导是**从起始符号（这里是“exp”）开始，根据文法规则不断替换符号，逐步生成一个具体的字符串**；而归约则是**其逆过程，从一个给定的字符串出发，尝试根据文法规则将其归约为起始符号**，如果能够**成功归约**，那么这个字符串就是**合法**的，反之则不合法。
- **推导步骤**
	- 在形式语言和编译原理里，文法是由产生式规则构成的集合，这些规则用于描述语言的语法结构。产生式规则的**一般形式为“左部 → 右部”**，左部是一个**非终结符，右部则是由终结符和非终结符组成的字符串**。
	- 推导步骤的核心在于把一个非终结符替换成其产生式的右部。比如，假设有一个产生式 $A → aB$，在一个字符串 $xAy$ 里，就可以把非终结符 $A$ 替换成 $aB$，从而得到新的字符串 $x aB y$，这就是一个推导步骤，可记作 $xAy \Rightarrow x aB y$。
- **形式化定义**
	- 若 $A → β$ 是文法 $G$ 的一个产生式，并且有字符串 $v = αAγ$ 和 $w = αβγ$（其中 $α$、$γ$ 是由终结符和非终结符组成的任意字符串），那么从 $v$ 到 $w$ 就存在一个推导步骤。这里的 $(V_N∪V_T)^*$ 表示由非终结符集 $V_N$ 和终结符集 $V_T$ 中的元素组成的所有可能的字符串（包含空串）的集合。
	- 例如，在文法 $G$ 里有产生式 $S → aS$，设 $α = b$，$γ = c$，$A = S$，$β = aS$，那么 $v = bSc$，$w = baSc$，就有 $bSc \Rightarrow baSc$。
- **更一般的表示**
	- 对于一个字符串 $X_1 … X_{i - 1} X_i X_{i + 1}… X_n$，要是存在产生式 $X_i → Y_1 … Y_m$，就能够把其中的 $X_i$ 替换成 $Y_1 … Y_m$，从而得到新的字符串 $X_1 … X_{i - 1} Y_1 … Y_m X_{i + 1} … X_n$，这同样表示一个推导步骤。
- **示例**：这其实是一个有趣的例子，可以仔细观察下是如何解析的
  $$
  \begin{align}
  \exp &\rarr \exp \mathrm{op} \exp | (\exp) | \mathrm{num} \\
  \mathrm{op} &\rarr  + | - |*
  \end{align}
  $$
  推导：
  $$
  \begin{align}
  \exp &\rarr \exp \mathrm{op} \exp \\
  &\rarr \exp \mathrm{op} \ \mathrm{num} \\
  &\rarr \exp * \ \mathrm{num} \\
  &\rarr (\exp) * \ \mathrm{num} \\
  &\rarr (\exp \mathrm{op} \exp) * \mathrm{num} \\
  &\rarr (\exp \mathrm{op} \ \mathrm{num}) * \mathrm{num} \\
  &\rarr (\exp - \ \mathrm{num}) * \mathrm{num} \\
  &\rarr (\mathrm{num} - \mathrm{num}) * \mathrm{num} \\
  \end{align}
  $$
- ##### 传递闭包
  
  在数学中，对于一个二元关系 $R$，其传递闭包是包含 $R$ 的最小传递关系。在推导的语境里，推导步骤关系 “$\Rightarrow$” 描述了**从一个字符串通过一次替换操作得到另一个字符串的关系**。而 “$\Rightarrow^*$” 是 “$\Rightarrow$” 的传递闭包，它描述了**从一个字符串经过零次或多次推导步骤能够得到另一个字符串的关**系。
- 推导序列的意义
	- **$n \geq 0$ 的情况**：当存在一个推导步骤的序列 $\alpha_0 \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow \alpha_{n - 1} \Rightarrow \alpha_n$ 时，如果起始字符串 $\alpha_0$ 等于 $\alpha$，结束字符串 $\alpha_n$ 等于 $\beta$，那么就可以说 $\alpha$ 经过零次或多次推导得到了 $\beta$，记作 $\alpha \Rightarrow^* \beta$。这里的 $n$ 表示推导步骤的数量，$n$ 可以是 0 或者正整数。
	- **$n = 0$ 的特殊情况**：当 $n = 0$ 时，意味着没有进行任何推导步骤，此时起始字符串和结束字符串是同一个，即 $\alpha = \beta$。这种情况下，$\alpha \Rightarrow^* \alpha$ 依然成立，因为 “$\Rightarrow^*$” 包含了自身等同的情况。
- **示例**：假设我们有一个简单的文法，其产生式为 $S \rightarrow aS$ 和 $S \rightarrow b$。
	- 若要从 $S$ 推导出 $aab$，可以有如下推导序列：
		- $S \Rightarrow aS \Rightarrow aaS \Rightarrow aab$，这里 $n = 3$，$\alpha_0 = S$，$\alpha_1 = aS$，$\alpha_2 = aaS$，$\alpha_3 = aab$，所以 $S \Rightarrow^* aab$。
	- 若考虑 $n = 0$ 的情况，对于任意字符串 $\alpha$，都有 $\alpha \Rightarrow^* \alpha$，例如 $S \Rightarrow^* S$，因为没有进行任何推导步骤，起始和结束字符串相同。
	  
	  
	  “$\Rightarrow^*$” 这个关系在形式语言和编译原理中非常重要，它帮助我们描述了从一个文法的起始符号出发，经过任意次数的推导可以得到的所有字符串的集合，也就是该文法所定义的语言。
- ##### CFG语言
  
  设 $G$ 是一个以 $S$ 为起始符号的上下文无关文法。那么 $G$ 的语言定义为：
  $$
  L(G) = \{ s \in V_T^* \mid \text{存在 } S \Rightarrow^* s \text{ 的推导过程}\}
  $$
  其中，$S$ 是文法 $G$ 的起始符号，$s$ 表示任意由终结符组成的字符串（有时也称为句子）。
  
  上下文无关文法（CFG）是一种用于**描述形式语言的**工具，由一组**产生式规则**构成。语言 $L(G)$ 表示由文法 $G$ 所生成的**所有合法字符串**的集合。具体来说，这些字符串必须是由终结符组成（即 $s \in V_T^*$），并且能够从起始符号 $S$ 经过零次或多次推导得到（即 $S \Rightarrow^* s$）。
- ##### 句子
- **文法 $G$ 的句型**
  若 $S$ 是文法 $G$ 的起始符号，且 $S \Rightarrow^* \alpha$，其中 $\alpha \in (V_N \cup V_T)^*$，则称 $\alpha$ 是文法 $G$ 的一个句型。
  
  通俗地讲：从起始符号 $S$ 出发，经过零次或多次推导得到的字符串 $\alpha$ 称为句型。由于推导过程中可能包含非终结符，所以**句型可以是由终结符和非终结符混合组成的字符串**（$\alpha \in (V_N \cup V_T)^*$）。
- **文法 $G$ 的句子**
  若 $w$ 是文法 $G$ 的一个句型，并且 $w$ 仅由终结符组成，那么 $w$ 就是文法 $G$ 的一个句子。通俗讲：句子是一种特殊的句型，它**只包含终结符**。也就是说，当一个句型经过推导后不再包含非终结符时，它就成为了一个句子。
- ##### 示例分析
- **给定文法 $G$，通过推导得出其语言 $L(G)$**
  已知文法 $G$ 的产生式为：
  $$
  S \to 0S1,S \to 01
  $$
  推导过程如下：
  $$
  S \Rightarrow 0S1 \Rightarrow 00S11 \Rightarrow 0^3S1^3 \Rightarrow \cdots \Rightarrow 0^{n - 1}S1^{n - 1} \Rightarrow 0^n1^n
  $$
  所以可以得到：
  $$
  L(G) = \{ 0^n1^n \mid n \geq 1 \}
  $$
  
  
  其中，$S$、$0S1$、$00S11$、$000S111$、$00001111$ 都是文法 $G$ 的句型，$00001111$ 是文法 $G$ 的一个句子。
  
  **分析**：对于给定的文法 $G$，通过不断应用产生式规则进行推导。从起始符号 $S$ 开始，每次使用 $S \to 0S1$ 规则可以在字符串的左右两侧分别添加一个 $0$ 和一个 $1$，直到使用 $S \to 01$ 规则结束推导。这样就可以得到所有形如 $0^n1^n$（$n \geq 1$）的字符串，这些字符串构成了文法 $G$ 的语言 $L(G)$。同时，推导过程中出现的中间结果，如 $S$、$0S1$ 等，都是句型，而最终的 $0^n1^n$ 形式且不包含非终结符的字符串就是句子。
- **给定语言 $L$ 的描述，为其设计文法**
  语言 $L$：由 $0$ 和 $1$ 组成的语言，该语言中的每个字符串所含的 $0$ 和 $1$ 的数量相同。
  为 $L$ 设计的文法如下：
  $$
  \begin{align}
  A &\to 0B \mid 1C \\
  B &\to 1 \mid 1A \mid 0BB \\
  C &\to 0 \mid 0A \mid 1CC
  \end{align}
  $$
	- 对于给定的语言 $L$，需要设计一组产生式规则来生成该语言中的所有字符串。在这个例子中，设计的文法通过 $A$ 作为起始符号，根据不同的选择（$0B$ 或 $1C$）开始推导。$B$ 和 $C$ 规则的设计保证了在生成字符串的过程中，$0$ 和 $1$ 的数量能够保持相等。例如，当选择 $A \to 0B$ 时，后续 $B$ 规则的选择会根据需要添	加相应数量的 $1$ 来平衡 $0$ 的数量。
	- **为什么是这样构造的？**
		- 首先，很容易得到 $B \rarr 1,C \rarr0$。且容易分析出$A$的最简式为$A \rarr 01|10$
		- 由此可以从基础的式子进一步构建 $B \rarr 1 | 1A, C \rarr 0 | 0A$，这样出现了无穷的迭代。
		- > $B \rarr 0BB$，这一步引入了一个 0。为了保证 0 和 1 数量最终相同，后续需要通过 $B$ 进一步推导出两个 1 或者能平衡这个 0 的组合。
		  
		  这是 AI 给出的解释，我觉得可以这样思考，$A \rarr 0B | 1C$ 使用原来的规则，得到的前缀都是 $01 | 10$，缺少了更多的情况，所以我们可以引入 $B \rarr 0BB$，当然这只是一种粗略的解释，很多细节，如为什么 0 接上的是 $BB$，为什么 $B \rarr 0BB$，而不是 $C \rarr 0BB$等，还没有一个比较自然的思考过程。
- ### 解析树
  
  解析树是一种用于形象化表示 token 串的结构，可以**采用可视化**的方法展示推导过程。
- #### 定义
  
  解析树是一种用于表示上下文无关文法推导过程的树形结构。具体定义如下：
  
  1. **根节点**：由文法的起始符号 $ S $ 标记。
  2. **叶节点**：由终结符（如 `a`, `b`）或空串 $ \varepsilon $ 标记。
  3. **非叶节点**：由非终结符（如 $ A, B, S $）标记。
  4. **产生式约束**：若某个非叶节点标记为 $ A $（非终结符），且有 $ n $ 个子节点标记为 $ X_1, X_2, \ldots, X_n $，则文法中必定存在产生式 $ A \to X_1 X_2 \ldots X_n $。
- #### 推导与解析树的关系
  
  1. **推导**：是通过连续应用产生式生成句子形式的过程，记为 $ S \Rightarrow \cdots \Rightarrow \cdots $。
  2. **解析树表示**：每个推导步骤可对应为解析树的构造：
	- 起始符号 $ S $ 作为树根。
	- 每次应用产生式 $ X \to Y_1 Y_2 \ldots Y_n $ 时，将节点 $ X $ 展开为子节点 $ Y_1, Y_2, \ldots, Y_n $。
	  
	  分析树是推导过程的图形化表示，它直观地展示了从起始符号到终结符串的推导路径，同时满足文法的所有产生式规则。推导序列与分析树是**同一语法分析过程**的两种表现形式：推导是**动态的步骤序列**，而分析树是**静态的结构呈现**。（简单说，就是工具而已）
- #### 示例
  
  $$
  \begin{align}
  \mathrm{E} &\rarr \mathrm{E} + \mathrm{T} | \mathrm{T} \\
  \mathrm{T} &\rarr \mathrm{T} * \mathrm{F} | \mathrm{F} \\
  \mathrm{F} &\rarr (\mathrm{E}) | \mathrm{i}
  \end{align}
  $$
  
  假设现在存在：
  $$
  \mathrm{i} + \mathrm{i} * \mathrm{i}
  $$
  不断使用产生式进行推导，可以得到解析树如下：
  ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505111611749.webp)
- #### 重点
- ##### 解析树的结构特性
  
  1. **节点类型分布**：
	- **叶节点**：均由终结符（如 `a`, `b`, `+` 等）或空串 $ \varepsilon $ 标记。
	- **内部节点**：均由非终结符（如 $ S $, $ A $, $ E $ 等）标记。
	  2. **叶节点遍历结果**：按从左到右的顺序遍历所有叶节点，得到的序列即为原始输入串（即待分析的句子）。
- ##### 分析树与推导的关系
  
  1. **多对多对应**：
	- 同一个输入串可能存在**多个不同的推导过程**（如最左推导、最右推导等），但它们都对应**同一棵分析树**。
	- 例如，对于文法 $ E \to E + E \mid \text{id} $，输入串 `id + id + id` 的推导顺序不唯一，但分析树的结构是唯一的。
	  2. **结构表示的唯一性**：
	- **推导**：关注产生式的应用顺序，可能因顺序不同而有多种形式，无法直接反映句子的语法结构。
	- **分析树**：忽略推导顺序的细节，仅保留与文法规则对应的层次结构，因此能**唯一表示句子的语法结构**。
- ##### 分析树的本质作用
  
  分析树通过以下方式抽象推导过程：
- **保留核心信息**：仅关注产生式的应用结果（即节点与子节点的关系），而非应用顺序。
- **消除表面差异**：将不同顺序的推导（如最左/最右推导）统一为相同的树结构，凸显语法结构的本质。
- ##### 总结
  
  分析树是语法结构的**规范表示**，它：
- 从推导过程中**提取不变的结构信息**；
- **屏蔽了推导顺序的多样性**，使句子的语法结构一目了然；
- 在编译原理中，分析树是语法分析的核心输出，后续的语义分析和代码生成均基于此结构进行。
- #### 最左推导（Leftmost Derivation）
  
  **定义**：在每一步推导中，**总是选择当前句型中最左侧的非终结符**进行替换。
- #### 最右推导（Rightmost Derivation）
  
  **定义**：在每一步推导中，**总是选择当前句型中最右侧的非终结符**进行替换。
- #### 关键特性
  
  1. **与分析树的关系**：
	- 同一输入串的**最左推导和最右推导可能不同**，但它们对应的**分析树唯一**（前提是文法无二义性）。
	- 分析树的**先序遍历**对应最左推导，**后序遍历**对应最右推导。
	  2. **在编译中的应用**：
	- **最左推导**：对应自顶向下分析器（如递归下降分析）的工作方式。
	- **最右推导**：对应自底向上分析器（如算符优先分析、LR分析）的归约过程（逆过程）。
	  3. **二义性检测**：
	- 若一个句子存在**多个不同的最左推导或最右推导**，则该文法是**二义性**的（如表达式文法 $ E \to E + E $）。
- #### 总结
  
  | **对比项**     | **最左推导**             | **最右推导**             |
  | -------------- | ------------------------ | ------------------------ |
  | **替换策略**   | 每次替换最左侧非终结符   | 每次替换最右侧非终结符   |
  | **分析树遍历** | 对应先序遍历（根→左→右） | 对应后序遍历（左→右→根） |
  | **编译应用**   | 自顶向下分析（预测分析） | 自底向上分析（LR分析）   |
  | **二义性标志** | 存在多个最左推导         | 存在多个最右推导         |
- ### 抽象语法树
- #### 必要性
  
  1. **编译效率考量**：
	- **解析树**包含大量对编译无实质帮助的细节（如括号、标点符号、语法结构标记等），会显著增加后续处理的复杂度。
	- **AST**通过剔除冗余信息，仅保留与程序语义直接相关的核心元素（如操作符、操作数、控制结构等），大幅提升编译效率。
	  2. **结构对比示例**：
	- **解析树**：表达式 `(a + b) * c` 的分析树需显式表示括号、终结符和非终结符的层级关系。
	- **AST**：同一表达式的AST简化为以 `*` 为根节点，左右子树分别为 `+` 和 `c` 的二叉树，省略括号等语法细节。
- #### 抽象语法树的定义与特性
  
  1. **核心定义**：
	- AST是源代码语法结构的**抽象表示**，它忽略具体语法形式，聚焦于表达程序的逻辑结构和语义关系。
	  2. **结构特点**：
	- **操作符内移**：运算符（如 `+`, `*`, `if`）作为内部节点，操作数作为子节点，更直观体现运算优先级。
	- **列表扁平化**：例如，函数参数列表 `(a, b, c)` 在AST中表示为包含三个元素的单一节点，而非嵌套 的树形结构。
	- **语法细节省略**：省略括号、逗号、分号等辅助符号，仅保留必要的语义节点。
	  3. **对比优势**：
	- **信息密度更高**：相同程序的AST节点数远少于分析树，减少后续处理的计算量。
	- **语义表达更清晰**：直接反映程序的逻辑结构（如控制流、数据依赖），便于语义分析和代码生成。
- #### AST在编译流程中的作用
  
  1. **作为中间表示**：
	- 编译器前端（词法分析、语法分析）生成AST后，后端（语义分析、代码优化、目标代码生成）基于AST进行处理，无需关注原始语法形式。
	  2. **实现示例**：
	- 语法分析器在构建解析树的过程中，通常会同步生成AST，或在分析完成后将分析树转换为AST，最终丢弃分析树以节省内存。
- #### 总结
  
  | **对比项**       | **解析树（Parse Tree）**                 | **抽象语法树（AST）**                    |
  | ---------------- | ---------------------------------------- | ---------------------------------------- |
  | **核心目标**     | 精确表示语法推导过程                     | 抽象表示程序语义结构                     |
  | **节点内容**     | 包含终结符、非终结符、括号等全部语法元素 | 仅保留运算符、操作数、控制结构等语义元素 |
  | **结构复杂度**   | 高度嵌套，节点数量多                     | 扁平化，节点数量少                       |
  | **后续处理效率** | 低（需处理大量冗余信息）                 | 高（聚焦核心语义）                       |
  | **应用阶段**     | 语法分析阶段                             | 语义分析、代码生成阶段                   |
- ### 挑战
- #### 二义性（Ambiguity）
  
  1. **定义**：  
  
   若一个文法允许某个句子存在**多个不同的分析树（或最左/最右推导）**，则称该文法是**二义性的**。  
  
   **示例**：整数算术表达式文法：  
   $$
   E \to E - E \mid E * E \mid (E) \mid i
   $$
	- 句子 **`i - i * i`** 存在两种推导：  
	  
	  1. **先乘后减**：$ E \Rightarrow E*E \Rightarrow E-E*E \Rightarrow i-E*E \Rightarrow i-i*E \Rightarrow i-i*i $  
	  
	  2. **先减后乘**：$ E \Rightarrow E-E \Rightarrow i-E \Rightarrow i-E*E \Rightarrow i-i*E \Rightarrow i-i*i $  
	  
	     ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505112046714.webp)
	- 句子 **`int - int - int`** 存在两种结合方式（左结合 vs 右结合），对应不同分析树。
	  
	  2. **二义性的普遍性**：  
	  
	  编程语言中常见的二义性场景包括：
	- **运算符优先级与结合性**（如 `*` 和 `-` 的优先级不明确）。
	- **悬空else问题**（`if-then-else` 匹配歧义）。
- #### 处理二义性的方法
- ##### 方法一：消除二义性规则（Disambiguating Rules）
  
  1. **核心思想**：  
  
   在不修改文法的前提下，通过**附加规则**明确选择正确的分析树。  
  
   **示例**：
	- **优先级规则**：规定 `*` 优先级高于 `-`，则 `i - i * i` 必须解析为 `i - (i * i)`。
	- **结合性规则**：规定 `-` 左结合，则 `int - int - int` 解析为 `(int - int) - int`。
	  
	  2. **特点**：
	- **优点**：无需修改文法，快速解决特定歧义。
	- **缺点**：语法结构不再完全由文法定义，增加分析器实现复杂度。
- ##### 方法二：改写文法（Rewriting the Grammar）
  
  1. **核心思想**：  
  
   通过**重构文法结构**，强制生成唯一正确的分析树。  
  
   **示例**：
	- $$
	  E \rarr E - E | E * E | (E) | i
	  $$
	- **分离优先级**：  
	  $$
	  \begin{align*}
	  E &\to E + T \mid T \\
	  T &\to T * T \mid F \\
	  F &\to (E) \mid i
	  \end{align*}
	  $$
	  此时 `i - i * i` 只能通过 `T * F` 推导乘法，确保 `*` 优先于 `-`。
	- **显式结合性**： 左递归规则使运算符左结合，而右递归规则使运算符右结合
	  $$
	  \begin{align*}
	  E &\to E - T \mid T \quad \text{（左结合）} \\
	  T &\to T * F \mid F \\
	  F &\to (E) \mid i
	  \end{align*}
	  $$
	  `int - int - int` 只能展开为 `(int - int) - int`。
	  
	  2. **特点**：
	- **优点**：语法结构完全由文法定义，分析器实现更简单。
	- **缺点**：需要重新设计文法，可能增加非终结符数量。
- #### 总结对比
  
  | **方法**           | **实现方式**          | **示例**                   | **适用场景**     |
  | ------------------ | --------------------- | -------------------------- | ---------------- |
  | **消除二义性规则** | 附加优先级/结合性规则 | 规定 `*` 优先于 `-`        | 快速修复已知歧义 |
  | **改写文法**       | 重构文法结构          | 分离表达式为 `E → E+T ∣ T` | 彻底消除二义性   |
  
  **注意**：
- 二义性文法本身**不影响语言表达能力**，但会增加编译难度。
- 现代编译器通常优先选择**改写文法**，如使用 LL(1) 或 LR(1) 文法，因为它们能自动生成无二义性的分析器。
  
  ![image-20250625190745789](./../../source/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20250625190745789.png)
  
  
  
  ![image-20250625190800695](./../../source/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20250625190800695.png)