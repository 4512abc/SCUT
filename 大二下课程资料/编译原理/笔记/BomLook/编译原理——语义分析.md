# 编译原理——语义分析

符号表作用

- 将所有实体的名称以结构化形式存储在一个位置
- 验证是否已声明变量
- 类型检查：验证源代码中的赋值和表达式在语义上是否正确
- 确定名称的范围（范围解析） 
- 代码生成：根据函数的存储位置生成调用指令。



相关标识

- 名称（作为字符串）
- 属性：变量名称、过程名称、常量名称
- 数据类型
- 块级别
- 范围（全局、局部或参数）
- 内存中的位置



操作

- 插入

  - 用于在处理 name 声明时存储这些声明提供的信息
  - 在识别令牌的分析阶段更常使用
  - 将元件及其属性作为参数

- 删除

  - 当声明不再适用时，删除该声明提供的信息

- 搜索

  主要目的如下：

  - 表中是否存在该符号
  - 在使用之前是否进行了声明
  - 在 scope 中是否使用了该名称
  - 是否已经初始化
  - 是否被声明多次

通常在语法分析和语义分析阶段，构建抽象语法树 （AST），检查语义正确性时，会将标识符及其相关信息插入符号表中。





Static 域

- 在编译时确定的变量的范围
- 变量的可见性基于它们在源代码中的位置
- 范围的嵌套级别在编译时明确定义





Dynamic 域

- 在运行时确定的变量的范围
- 变量的可见性基于调用堆栈的当前状态
- 范围的嵌套级别是在运行时动态确定的





A language is block structured

- If the nesting blocks inside other blocks is permitted
- If the scope of declarations in a block is limited to that block and other blocks nested in that block



**Most-closely nested rule** for blocks can be implemented by **chaining symbol tables.**

- Chaining symbol tables is a static structure
- Each scope stores a pointer to its parents, but not vice-versa
- From any point in the program, symbol table appears to be a stack





Syntax-directed translation

- Intermediate Code or Target Code as a Synthesized Attribute
- Code generation can be viewed as an attribute computation.
- Intermediate code can be generated by a post-order traversal of the syntax tree
- Intermediate code can be generated during parsing