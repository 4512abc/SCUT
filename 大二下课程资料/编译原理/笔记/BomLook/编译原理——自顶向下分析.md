# 编译原理——自顶向下分析

## 自顶向下分析

语法分析的目标：恢复程序的语法结构，通过使用 CFG 描述编程语言。给定 token 序列，寻找一棵表示这些词法单元语法结构的解析树。恢复这棵语法树的过程称为解析。

解析分为两种：自顶向下，自底向上



### 自顶向下的解析

**定义**：解析从语法的起始符号开始，通过多步推导，尝试找出输入字符串的最左推导。

**解析树的构造**：语法的起始符号是**解析树的根**，解析树是从根到叶按先序构造的，解析树的叶子就是输入的 token 串。



### 从解析到搜索

我们可以将解析视为图搜索，每一个节点都是一个 sentence （即，从起始符号导出的，由终止符和非终止符组成的字符串）。如果存在 $ \alpha \to \beta$，则存在从节点 $\alpha $ 到 $\beta  $ 一条边。

但是，这个方法存在问题，如果有一个节点有很多个儿子，我们应该如何搜索？

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505120021374.webp)

所以，关键问题就是，如何确定选择哪一个产生式？比方说：要替换最左边的非终止符 $\alpha$， 一共有 $n$ 个产生式：
$$
\alpha \to A_1 \mid A_2 \mid A_3 \mid ...... \mid A_n
$$
如何选择哪一个 $A$ ？基于此，有两种自上而下的解析类别：回溯解析（Backtracking Parsing）和预测解析（Predictive parsing）



### 自顶向下解析的类别

#### 回溯解析 Backtracking Parsing (Depth-First)

采用深度优先搜索的方法，如果非终结符有多个产生式，则基于当前输入符号，解析器无法确定选择哪一个，如果一种可能性失败，它必须尝试其他可能性，但回溯可能会使其变慢。

#### 预测解析 Predictive parsing

解析器尝试使用**一个或多个前瞻标记（look-ahead）**来预测输入字符串中的下一个构造，基于此存在两种预测解析：

- 递归下降解析
- LL(1) 解析



### 预测分析

输入字符串的解析**从语法的起始符号**开始，如果它能够根据输入中的**前瞻标记唯一地确定在推导中接下来要使用哪个产生式**，那么解析就是预测性的。其要求必须是LL(1)语法。

#### LL(K) 语法

- L 表示从左到右进行扫描
- L 表示最左推导
- K 表示：最多需要 K 个 前瞻标记用于预测

在实践中，使用的 LL(1) 语法。

#### First 集 和 Follow 集

##### 1) 首符集（First Sets）

- **定义**：给定文法 $ G = (V_N, V_T, P, S) $ 和符号串 $ \beta \in (V_N \cup V_T)^* $，  
  $$
  \text{FIRST}(\beta) = \{ a \in V_T \mid \beta \xRightarrow{*} a \ldots \}
  $$
  （即能从 $ \beta $ 推导出的**所有首个终结符**的集合）。  

  若 $ \beta \xRightarrow{*} \varepsilon $（即 $ \beta $ 可推导为空串），则 $ \varepsilon \in \text{FIRST}(\beta) $。  

- **直观理解**：符号串 $ \beta $ 的首符集是**所有可能从 $ \beta $ 推导出的第一个终结符**（包括 $ \varepsilon $）的集合。

---

##### 后继符集（Follow Sets）

- **定义**：给定文法 $ G = (V_T, V_N, S, P) $ 和非终结符 $ A \in V_N $，  
  $$
  \text{FOLLOW}(A) = \{ a \in V_T \mid S \xRightarrow{*} \ldots Aa\ldots \}
  $$
  （即所有**在句型中紧接 $ A $ 后出现的终结符**的集合）。  

  若 $ A $ 可以是某句型的**最右符号**（即 $ S \xRightarrow{*} \ldots A $），则输入结束符 $ \$ \in \text{FOLLOW}(A) $。  

- **直观理解**：非终结符 $ A $ 的后继符集是**所有在文法句型中可能出现在 $ A $ 之后的终结符**（包括输入结束标记 $ \$ $）的集合。

---

##### 关键术语对照

- $\mathrm{FIRST(\beta)}$：首符集（β 能推导出的首个终结符集合）  
- $\mathrm{FOLLOW(A)}$：后继符集（紧接非终结符 A 后的终结符集合）  
- $ \$ $：输入结束标记（通常表示句子末尾）  
- $\varepsilon$：空串  
- $\mathrm{V_N}$：非终结符集合  
- $\mathrm{V_T}$：终结符集合  
- $S$：文法开始符号  

##### 示例说明

- **首符集**：若规则为 $ A \to aB $，则 $ \text{FIRST}(A) = \{a\} $；若 $ A \to \varepsilon $，则 $ \varepsilon \in \text{FIRST}(A) $。  
- **后继符集**：若句型可推导为 $ \ldots Aa \ldots $，则 $ a \in \text{FOLLOW}(A) $；若 $ A $ 是句型的结尾（如 $ \ldots A \$ $），则 $ \$ \in \text{FOLLOW}(A) $。  



##### 思考

其实下面的内容很多都是跟 AI 探讨后自己得出的一些个人理解

---

好的，看完上面一大串关于 First 集 和 Follow 集的定义，可能会一头雾水（我一开始也是如此，为什么要这样分？他们有什么用）

先说一个很关键的点：如果 $\mathrm{FIRST} \cap \mathrm{FOLLOW} = \varnothing$，解析器就可以唯一确定一个产生式。

一个很自然的问题是：为什么只有 $\mathrm{FIRST} \cap \mathrm{FOLLOW} = \varnothing$ ，才可以唯一确定一个产生式？

---

> ### **1. 为什么需要 First 和 Follow 集合？**
>
> 在 **自顶向下预测分析（如 LL(1) 分析）** 中，解析器需要根据 **当前输入符号** 和 **栈顶非终结符** 决定使用哪条产生式。  
>
> - **First(α)** 告诉我们：**使用产生式后，可能遇到的第一个终结符是什么**。  
> - **Follow(A)** 告诉我们：**如果当前非终结符 A 能推导出 ε，那么 A 后面可能跟什么符号**。
>
> ---
>
> ### **2. 如何确定选择哪条产生式？**
>
> 假设非终结符 **A** 有多个产生式：
> $$
> A \to \alpha_1 \mid \alpha_2 \mid \dots \mid \alpha_n
> $$
> 解析器需要根据 **当前输入符号 `a`** 决定使用哪条 `α_i`。规则如下：
>
> 1. **如果 `a ∈ First(α_i)`**  
>    - 选择 `A → α_i`，因为 `α_i` 可以推导出以 `a` 开头的串。  
>    - 例如：`A → aB`，`First(aB) = {a}`，如果输入是 `a`，就选这条。
>
> 2. **如果 `α_i` 能推导出 ε（即 `ε ∈ First(α_i)`），且 `a ∈ Follow(A)`**  
>    - 选择 `A → α_i`（即 `A → ε`），因为 `A` 后面可以跟 `a`。  
>    - 例如：`A → ε`，`Follow(A) = {b}`，如果输入是 `b`，就选择 `A → ε`。
>
> 3. **如果 `First(α_i)` 和 `Follow(A)` 的交集为空**  
>    - 这意味着 **不会出现冲突**，解析器可以明确选择产生式（或报错）。  
>    - 例如：
>      - `First(α_1) = {a}`，`First(α_2) = {b}`，`Follow(A) = {c}`  
>      - 输入 `a` → 选 `α_1`；输入 `b` → 选 `α_2`；输入 `c` → 选 `A → ε`（如果允许）。  
>      - **没有重叠**，所以选择是唯一的。
>
> ---
>
> ### **3. 为什么要求 `First ∩ Follow = ∅`？**
>
> 如果 `First(α_i)` 和 `Follow(A)` 有交集：
>
> - 当输入符号 `a` 同时属于 `First(α_i)` 和 `Follow(A)` 时，解析器无法确定：
>   - 是应该选择 `A → α_i`（因为 `a ∈ First(α_i)`），还是  
>   - 选择 `A → ε`（因为 `a ∈ Follow(A)`）。  
> - **这会引入歧义，导致 LL(1) 解析失败**。
>
> **例子**（冲突情况）：
> $$
> S \to a \mid \varepsilon
> $$
>
> - `First(a) = {a}`, `First(ε) = {ε}`  
> - `Follow(S) = {a}`（假设 `S` 后面可以跟 `a`）  
> - 当输入是 `a` 时，解析器不知道选 `S → a` 还是 `S → ε`（因为 `a ∈ First(a)` 且 `a ∈ Follow(S)`）。  
> - **这就是为什么 LL(1) 文法要求 `First` 和 `Follow` 不能有交集**。
>
> ---
>
> ### **4. 结论**
>
> - **当 `First` 和 `Follow` 不相交时**，解析器可以**唯一确定**选择哪条产生式（或无歧义地报错）。  
> - **如果相交**，则文法 **不是 LL(1) 的**，必须改写（如左递归消除、提取左公因子）。
>
> **LL(1) 文法的关键条件**：
>
> 1. 对于任何 `A → α | β`：
>    - `First(α) ∩ First(β) = ∅`（不同产生式的 `First` 集不相交）。  
>    - 如果 `ε ∈ First(α)`，则 `First(β) ∩ Follow(A) = ∅`（避免 `First` 和 `Follow` 冲突）。  
>
> 这样，解析器在任何情况下都能 **确定性地选择产生式**（或无歧义地报错）。

----

看完之后可能会有一些进一步的理解。我的理解是：$\mathrm{FIRST}$ 和 $\mathrm{FOLLOW}$ 集合是从集合的角度，针对两种不同的情况，描述了推导方法：

- $\mathrm{FIRST}$ 用于 **"正向推导"**，即不断展开非终结符，直到遇到终结符，可以理解为递归。
- $\mathrm{FOLLOW}$ 用于**处理 "当前非终结符可以消失（推导出 $\varepsilon$）的情况"**

**First 集合**和 **Follow 集合** 实际上对应了 **两种不同的解析场景**，分别用于处理 **不同的推导路径**，确保 LL(1) 解析器能 **确定性地选择产生式**。  

---

> ### **1. `First` 集合：处理 "当前产生式能直接推导出的首个终结符"**
>
> - **适用情况**：当解析器看到某个非终结符（如 `A`），它需要决定选择 `A` 的哪条产生式（如 `A → α` 或 `A → β`）。  
>
> - **规则**：如果当前输入符号 `a` 属于 `First(α)`，就选择 `A → α`，因为这条产生式 **最终能生成以 `a` 开头的句子**。  
>
> - **本质**：`First` 集合用于 **"正向推导"**，即不断展开非终结符，直到遇到终结符。  
>
>   - 例如： 
>     $$
>     A \to aB \quad (\text{First}(aB) = \{a\})
>     $$
>     如果输入是 `a`，就选择 `A → aB`，然后继续解析 `B`。
>
> ---
>
> ### **2. `Follow` 集合：处理 "当前非终结符可以消失（推导出 ε）的情况"**
>
> - **适用情况**：如果某个产生式可以推导出空（`A → ε`），解析器需要知道 **`A` 后面可以跟什么符号**，才能决定是否选择 `A → ε`。  
>
> - **规则**：如果当前输入符号 `a` 属于 `Follow(A)`，就选择 `A → ε`，因为 `A` 可以 **"消失"**，让解析继续处理 `A` 后面的符号。  
>
> - **本质**：`Follow` 集合用于 **"回退或跳过"**，即当非终结符不贡献任何字符（`ε`）时，解析器需要知道 **后面的符号是否合法**。  
>
>   - 例如：  
>     $$
>     S \to A b, \quad A \to a \mid \varepsilon
>     $$
>
>     - `Follow(A) = {b}`（因为 `A` 后面必须跟 `b`）。  
>     - 如果输入是 `b`，解析器选择 `A → ε`（因为 `b ∈ Follow(A)`），然后继续匹配 `b`。
>
> ---
>
> ### **3. 为什么两者不能有交集？**
>
> 如果 `First(A)` 和 `Follow(A)` 有共同符号 `a`，解析器会 **无法决定**：
>
> - 是应该选择 `A → α`（因为 `a ∈ First(α)`），还是  
> - 选择 `A → ε`（因为 `a ∈ Follow(A)`）。  
>
> **例子**（冲突情况）：
> $$
> S \to A a, \quad A \to b \mid \varepsilon
> $$
>
> - `First(A) = {b, ε}`, `Follow(A) = {a}`  
> - 如果输入是 `a`：  
>   - 可以选 `A → ε`（因为 `a ∈ Follow(A)`），然后继续匹配 `a`，得到 `S ⇒ Aa ⇒ a`（合法）。  
>   - 但如果有 `A → a`（假设），`a` 也属于 `First(A)`，解析器就不知道选 `A → a` 还是 `A → ε`。  
> - **这就是为什么 LL(1) 文法要求 `First(A)` 和 `Follow(A)` 不能相交**。
>
> ---
>
> ### **4. 你的理解完全正确**
>
> - **`First` 集合** 对应 **"继续展开（递归下降）"**，解析器沿着产生式一步步推导。  
> - **`Follow` 集合** 对应 **"回退或跳过（$\varepsilon$ 情况）"**，解析器检查后面的符号是否合法。  
> - **两者互斥** 才能保证解析器 **每一步的选择是唯一的**，否则会歧义。
>
> ---
>
> ### **总结（LL(1) 解析的关键）**
>
> | 情况                                                | 解析行为                                  | 使用的集合      |
> | --------------------------------------------------- | ----------------------------------------- | --------------- |
> | 输入 `a` 能匹配某个产生式的开头                     | 选择该产生式，继续解析                    | `a ∈ First(α)`  |
> | 输入 `a` 不能匹配任何 `First`，但 `A` 能消失（`ε`） | 选择 `A → ε`，检查 `a` 是否在 `Follow(A)` | `a ∈ Follow(A)` |
> | `First` 和 `Follow` 无交集                          | 选择唯一，无歧义                          | 保证 LL(1) 文法 |
>
> 这种设计让 **自顶向下解析器（如递归下降、LL(1)）** 能高效且无歧义地工作。



### LL(1) 语法

#### 定义

LL(1) 语法需要满足以下两个条件：

**条件 1：同一非终结符的不同产生式的 `First` 集互不相交**

对于任意形如 $$ A \to \alpha_1 \mid \alpha_2 \mid \dots \mid \alpha_n $$ 的产生式，所有 $$ i \neq j $$ 满足：
$$
\text{First}(\alpha_i) \cap \text{First}(\alpha_j) = \varnothing
$$
**解释**：

- 这意味着，对于同一个非终结符 $$ A $$ 的不同产生式 $$ \alpha_i $$ 和 $$ \alpha_j $$，它们的 **首个可推导终结符不能有重叠**。  
- 这样，解析器可以根据 **当前输入符号** 唯一地选择正确的产生式，而不会出现歧义。

**示例**：

- 如果 $$ A \to aB \mid bC $$，则：
  - $$ \text{First}(aB) = \{a\} $$
  - $$ \text{First}(bC) = \{b\} $$
  - 由于 $$ \{a\} \cap \{b\} = \emptyset $$，所以符合条件。  
- 如果 $$ A \to aB \mid aC $$，则：
  - $$ \text{First}(aB) = \{a\} $$
  - $$ \text{First}(aC) = \{a\} $$
  - 由于 $$ \{a\} \cap \{a\} \neq \emptyset $$，**不是 LL(1) 文法**（解析器无法决定选 $$ aB $$ 还是 $$ aC $$）。

---

**条件 2：如果某个非终结符能推导出 `ε`，则它的 `First` 集和 `Follow` 集不能相交**

对于任意非终结符 $$ A $$，如果 $$ \varepsilon \in \text{First}(A) $$，则必须满足：
$$
\text{First}(A) \cap \text{Follow}(A) = \varnothing
$$
**解释**：

- 如果 $$ A $$ 能推导出空串（$$ A \to \varepsilon $$），那么解析器在遇到 **`Follow(A)` 中的符号** 时，可以选择 $$ A \to \varepsilon $$。  
- 但如果 `First(A)` 和 `Follow(A)` 有交集，解析器就无法确定：
  - 是应该选择 $$ A \to \alpha $$（因为输入符号在 `First(A)` 中），还是  
  - 选择 $$ A \to \varepsilon $$（因为输入符号在 `Follow(A)` 中）。  
- 因此，必须保证这两个集合 **不能有共同符号**，否则会产生歧义。

**示例**：

- 设文法：
  $$
  S \to Aa, \quad A \to b \mid \varepsilon
  $$

  - $$ \text{First}(A) = \{b, \varepsilon\} $$
  - $$ \text{Follow}(A) = \{a\} $$（因为 $$ A $$ 后面必须跟 $$ a $$）
  - 由于 $$ \text{First}(A) \cap \text{Follow}(A) = \emptyset $$，符合 LL(1) 条件。  

- 如果改为：
  $$
  S \to Aa, \quad A \to a \mid \varepsilon
  $$

  - $$ \text{First}(A) = \{a, \varepsilon\} $$
  - $$ \text{Follow}(A) = \{a\} $$
  - 此时 $$ \text{First}(A) \cap \text{Follow}(A) = \{a\} $$，**不是 LL(1) 文法**（输入 `a` 时无法决定选 $$ A \to a $$ 还是 $$ A \to \varepsilon $$）。



#### Note

- $\varepsilon$ 是 $\text{FIRST}$ 集合的元素，但绝对不是 $\text{FOLLOW}$ 的元素
- $\text{FIRST}$ 是终结符和非终结符和非终结符的字符串定义的，而 $\text{FOLLOW}$ 仅为非终结符定义

#### 识别

LL(1) 的识别包含以下四个步骤：

1. 计算可空非终结符集合

2. 计算每个产生式右部符号串 $\alpha $ 的 $\mathrm{FIRST}(\alpha)$集合

3. 计算每个非终结符 $\mathrm{A}$ 的 $\mathrm{FOLLOW(A)}$ 集合

4. 根据 $\mathrm{LL(1)}$文法的定义进行判定

   

##### 计算可空（Nullable）非终结符集合

可空：如果存在 $A \rarr * \varepsilon$，则称非终结符 $A$ 是可空的。

**算法**

1. **初始化**：  

   - 将**所有直接能推导出 $\varepsilon$ 的非终结符**加入 $U$，即：  
     $$
     U = \{ A \mid A \to ε \ \text{is a production} \}
     $$

2. **迭代扩展**：  

   - 对于每个产生式 $A_p \rarr X_1.....X_n$，  
     $$
     \text{if } X_1, X_2, \dots, X_n \in U, \text{ then } U := U \cup \{A\}
     $$

3. **重复步骤 2**，直到 $U$ 不再变化（即没有新的可空非终结符被发现）。  

4. **示例**：

   - 文法：
     $$
     S \to AB, \quad A \to a \mid \epsilon, \quad B \to b \mid \varepsilon
     $$

- 初始 $U = \{A, B\}$（因为 $A \rarr \varepsilon$ 和 $B \rarr \varepsilon$ 存在）。  

- 检查 $S → AB$：由于 $A \in U$ 且 $B \in U$，所以 $S$ 也是可空的，更新 $U = {A, B, S}$。  

- 最终 $U = \{A, B, S\}$。

通俗地讲：就是判断基于原始元素，不断组合构造出新的产生式，这些产生式也是属于非终结符集合

---

##### 计算每个产生式右部 $\alpha$ 的 $\mathrm{FIRST(\alpha)}$ 集合

分为两种：

- 计算语法符号 $A(A \in V_T \cup V_n)$ 的 $\mathrm{FIRST(A)}$
  - 对于所有 $a \in V_T$，有 $First(a)=\{a\}$
  - 对于所有的 $A \in V_N$，如果 $A \in * \varepsilon$，则 $First(A) ={\varepsilon}$，否则 $First(A)=\{\}$
  - 对于任意产生式：$A_p =X_1...X_j...X_n$，则 $First(A)=First(A) \cup SectionFirst(X_1...X_j...X_n)$
  - 重复步骤3，直到 $First$ 没有变化

> ### SectionFirst 函数的正式定义
>
> 给定一个符号串 $ \alpha= X_1X_2...X_n$，其中每个 $X_i \in (V_N \cup V_T)$，$SectionFirst(\alpha)$ 的计算定义如下：
>
> $$
> \text{SectionFirst}(X_1X_2...X_n) = 
> \begin{cases}
> \text{FIRST}(X_1) & \text{如果 } X_1 \text{ 不可空} \\
> \left(\bigcup_{i=1}^k (\text{FIRST}(X_i) \setminus \{\varepsilon\}\right) \cup \text{FIRST}(X_{k+1}) & \text{如果前 } k \text{ 个符号可空且 } X_{k+1} \text{ 是第一个不可空符号} \\
> \left(\bigcup_{i=1}^n (\text{FIRST}(X_i) \setminus \{\varepsilon\}\right) \cup \{\varepsilon\} & \text{如果所有 } X_i \text{ 都可空}
> \end{cases}
> $$
>
>
> #### 详细说明：
>
> 1. **基本情况**（X₁ 不可空）：
>    $$
>    \text{SectionFirst}(X_1...X_n) = \text{FIRST}(X_1)
>    $$
>
>
>    - 因为第一个符号不可推导出 $\varepsilon$，所以整个串的首符号就是 $X_1$ 的首符号。
>
> 2. **递归情况**（存在可空前缀）：
>    $$
>    \text{SectionFirst}(X_1...X_n) = \left(\bigcup_{i=1}^k (\text{FIRST}(X_i) \setminus \{\varepsilon\}\right) \cup \text{FIRST}(X_{k+1})
>    $$
>
>
>    - 其中 $X_1$ 到 $X_k$ 都可空（即可推导出 $\varepsilon$），而 $X_{k+1}$ 是第一个不可空的符号。
>    - 计算时：
>      - 先收集所有可空符号的非 $\varepsilon$ 首符号
>      - 然后加入第一个不可空符号的全部首符号
>
> 3. **全可空情况**：
>    $$
>    \text{SectionFirst}(X_1...X_n) = \left(\bigcup_{i=1}^n (\text{FIRST}(X_i) \setminus \{\varepsilon\}\right) \cup \{\varepsilon\}
>    $$
>
>    - 如果所有符号都可推导出 $\varepsilon$，则在收集所有非 $\varepsilon$ 首符号后，额外加入 $\varepsilon$。
>
> #### 关键性质：
>
> - $SectionFirst$ 是计算 $FIRST(\alpha)$ 的核心辅助函数
>
> - 它处理了符号串中可空符号的"跳过"逻辑
>
> - 结果总是终结符的集合（可能包含 $\varepsilon$）
>
> - 该定义保证了：
>   $$
>   \text{FIRST}(A) = \bigcup_{A \rightarrow \alpha} \text{SectionFirst}(\alpha)
>   $$
>
> 这个定义完整刻画了在计算产生式右部的有效首符号时，如何处理可空符号的精确规则。

- 计算字符串 $\alpha=X_1X_2...X_n$ 的 $First(\alpha)$

  - 如果 $X_1$不可为空，则 $First(\alpha)=First(X_1)$

  - 如果 $X_j(1 \leq j < n)$ 是可空的，则 $\mathrm{ FIRST(\alpha)=(FIRST(X_1)-\{\varepsilon\}) \cup (FIRST(X_2)-\{\varepsilon\})... \cup (FIRST(X_j)-\{\varepsilon\}) \cup FIRST(X_{j+1})}$

  - 如果 $X_i (1 \leq i \leq n)$ 全部都是可空的，则：
    $$
    \mathrm{ FIRST(\alpha)=(FIRST(X_1)-\{\varepsilon\}) \cup (FIRST(X_2)-\{\varepsilon\})... \cup (FIRST(X_j)-\{\varepsilon\}) \cup (FIRST(X_{n})-{\varepsilon) \cup {\varepsilon}}}
    $$



##### 计算每个非终结符 $\mathrm{A}$ 的 $\mathrm{FOLLOW(A)}$ 集合

**算法**

给定文法 $G = (V_N, V_T, P, S)$，对每个非终结符 $A \in V_N$ 计算 $\text{FOLLOW}(A)$：

1. **初始化**：
   $$
   \text{FOLLOW}(S) = \{\$\} \quad \text{（$S$为开始符号）}
   $$

   $$
   \forall A \in V_N \setminus \{S\}, \text{FOLLOW}(A) = \emptyset
   $$

   

2. **产生式处理**：
   对每个产生式 $B \rightarrow \alpha A \gamma$（其中$A \in V_N$，$\alpha, \gamma \in (V_N \cup V_T)^*$）：
   $$
   \text{FOLLOW}(A) \leftarrow \text{FOLLOW}(A) \cup (\text{FIRST}(\gamma) \setminus \{\varepsilon\})
   $$

   $$
   \text{如果 } \varepsilon \in \text{FIRST}(\gamma), \text{ 则 } \text{FOLLOW}(A) \leftarrow \text{FOLLOW}(A) \cup \text{FOLLOW}(B)
   $$

   **简单证明**：
   $$
   \text{如果 } \varepsilon \in \text{FIRST}(\gamma), \text{ 则 } \text{FOLLOW}(A) \leftarrow \text{FOLLOW}(A) \cup \text{FOLLOW}(B)
   $$
   如果 $b \in \text{FOLLOW(B)}$，则 $S \rarr *...Bb...$，

   又因为 $B \rarr \alpha A \gamma \text{ and } \gamma \rarr * \varepsilon$

   故 $S \rarr * ... Bb... \rarr ... \alpha A\gamma b... \rarr *... \alpha A b...$，即 $b \in \text{FOLLOW(A)}$

3. **迭代计算**：
   重复步骤2直到$\forall A \in V_N$，$\text{FOLLOW}(A)$不再变化

> **数学表示**
> $$
> \text{FOLLOW}(A) = \bigcup_{B\rightarrow\alpha A\gamma \in P} \left( 
> \begin{cases}
> \text{FIRST}(\gamma) \setminus \{\varepsilon\} & \text{如果}\gamma \neq \varepsilon \\
> \text{FOLLOW}(B) & \text{如果}\gamma \Rightarrow^* \varepsilon \\
> \text{FIRST}(\gamma) \setminus \{\varepsilon\} \cup \text{FOLLOW}(B) & \text{如果}\gamma \text{可空且}\gamma \neq \varepsilon
> \end{cases}
> \right)
> $$
>
>
> **示例计算**
>
> 考虑文法：
> $$
> \begin{aligned}
> S &\rightarrow AB \\
> A &\rightarrow aA \mid \varepsilon \\
> B &\rightarrow bB \mid \varepsilon
> \end{aligned}
> $$
> 计算过程：
>
> 1. 初始化：
>    $$
>    \text{FOLLOW}(S) = \{\$\}, \quad \text{FOLLOW}(A) = \text{FOLLOW}(B) = \emptyset
>    $$
>
> 2. 处理 $S \rightarrow AB$：
>    $$
>    \begin{aligned}
>    \text{对A}: \gamma &= B \\
>    \text{FIRST}(B) &= \{b, \varepsilon\} \\
>    \text{FOLLOW}(A) &= \{b\} \cup \text{FOLLOW}(S) = \{b, \$\} \\
>    \text{对B}: \gamma &= \varepsilon \\
>    \text{FOLLOW}(B) &= \text{FOLLOW}(S) = \{\$\}
>    \end{aligned}
>    $$
>
> 最终结果：
> $$
> \text{FOLLOW}(A) = \{b, \$\}, \quad \text{FOLLOW}(B) = \{\$\}, \quad \text{FOLLOW}(S) = \{\$\}
> $$

----

下面是一些无关的课外阅读，可能与课内不是有很大关系：

> ### FOLLOW集合初始化原理详解
>
> #### 1. 开始符号的特殊初始化
>
> 对开始符号 $ S $ 的初始化：
> $$
> \text{FOLLOW}(S) = \{\$\}
> $$
> **原因**：
>
> - $\$$ 是输入结束标记，表示句子终止
> - 任何推导最终都会回到开始符号 $ S $，因此 $ S $ 后可能跟随的符号就是输入结束符
> - 例：对于句子 $ w $，有 $ S \Rightarrow^* w\$ $，故 $\$$ 必须属于 $ \text{FOLLOW}(S) $
>
> #### 2. 其他非终结符的初始化
>
> 对其他非终结符 $ A \neq S $：
> $$
> \text{FOLLOW}(A) = \emptyset
> $$
> **原因**：
>
> - 初始时我们不知道 $ A $ 后可能跟随什么符号
> - 这些信息需要通过后续的产生式规则推导获得
> - 空集初始化保证了算法的正确性和完备性
>
> #### 数学本质
>
> 该初始化满足以下不动点方程的初始条件：
> $$
> \text{FOLLOW}(A) = \bigcup_{B \rightarrow \alpha A \gamma \in P} \left( \text{FIRST}(\gamma) \cup \delta(\gamma)\text{FOLLOW}(B) \right)
> $$
> 其中：
> $$
> \delta(\gamma) = \begin{cases} 
> 1 & \text{if } \gamma \Rightarrow^* \varepsilon \\
> 0 & \text{otherwise}
> \end{cases}
> $$
>
> #### 示例分析
>
> 考虑简单文法：
> $$
> S \rightarrow aA
> $$
>
> 1. 初始化：
>    $$
>    \text{FOLLOW}(S) = \{\$\}, \quad \text{FOLLOW}(A) = \emptyset
>    $$
>
> 2. 处理产生式 $ S \rightarrow aA $：
>
>    - $ \gamma = \varepsilon $，故将 $ \text{FOLLOW}(S) $ 加入 $ \text{FOLLOW}(A) $
>
>    - 结果：
>      $$
>      \text{FOLLOW}(A) = \{\$\}
>      $$
>      这与直觉一致：$ A $ 只出现在句子末尾，故其后只能是 $\$$
>
> #### 为什么不能随意初始化？
>
> - 若初始化为全集会导致结果不正确
> - 空集初始化保证：
>   - 算法收敛性：单调递增直到不动点
>   - 正确性：所有跟随符号都通过产生式规则证明
>
> #### 算法复杂度
>
> 最坏情况下需要 $ O(|V_N|^2) $ 次迭代（$ |V_N| $ 为非终结符数量），但实际文法通常快速收敛。
>
> 这种初始化方式确保了：
>
> 1. 开始符号的正确终止语义
> 2. 其他非终结符信息的逐步推导
> 3. 算法的高效性和正确性



##### 根据 $\mathrm{LL(1)}$文法的定义进行判定

**条件 1：同一非终结符的不同产生式的 `First` 集互不相交**

对于任意形如 $$ A \to \alpha_1 \mid \alpha_2 \mid \dots \mid \alpha_n $$ 的产生式，所有 $$ i \neq j $$ 满足：
$$
\text{First}(\alpha_i) \cap \text{First}(\alpha_j) = \varnothing
$$
**条件 2：如果某个非终结符能推导出 `ε`，则它的 `First` 集和 `Follow` 集不能相交**

对于任意非终结符 $$ A $$，如果 $$ \varepsilon \in \text{First}(A) $$，则必须满足：
$$
\text{First}(A) \cap \text{Follow}(A) = \varnothing
$$


#### 补充

接下来是关于 LL(1) 语法的一些补充内容：关于非 $\text{LL(1)}$ 语法 和 $\text{LL(1)}$  语法的关系。

**非 LL(1) 语法**

- ==**如果一个语法具有左因子或左递归，或两者兼有，那么它一定是非 LL(1) 语法**==

- 没有左因子和左递归的语法**并不总是 LL(1) 语法**

- 左因子：指的是存在多个语法规则共享同一个前缀字符串，如：
  $$
  \text{A} \rarr \alpha \beta \mid \alpha r
  $$
  由于 $\mathrm{FIRST(\alpha \beta) \cap FIRST(\alpha r)= \varnothing} $，故不是 LL(1) 语法。

- 左递归：

  - **a) 直接左递归 (Immediate Left Recursion)**
    $$
    A \rightarrow A\beta
    $$

    - 特点：左递归仅发生在单个非终结符的产生式中

    - 示例：$ A \rightarrow Aa \mid b $

  - **b) 间接左递归 (Indirect Left Recursion)**
    $$
    A \rightarrow B\beta \quad \text{且} \quad B \rightarrow A\alpha
    $$

  - 特点：通过多个产生式形成递归环路 $ A \Rightarrow B\beta \Rightarrow A\alpha\beta $

  - 数学表达：$ A \Rightarrow^+ A\ldots $（至少一步推导后出现左递归）

- 左递归与LL(1)文法的冲突

  - 以直接左递归为例：
    $$
    A \rightarrow A\alpha \mid \beta
    $$
    （其中 $\alpha$ 和 $\beta$ 为任意符号串）

  - **冲突原因**：
    $$
    \text{FIRST}(A\alpha) \subseteq \text{FIRST}(\beta)
    $$

由于 $ A \rightarrow A\alpha $ 能产生以 $\beta$ 开头的串（通过多次展开），导致：
$$
\text{FIRST}(A\alpha) \cap \text{FIRST}(\beta) \neq \emptyset
$$
这违反了LL(1)文法要求不同产生式的FIRST集互不相交的条件

> ### 左递归与LL(1)文法的冲突原因详解
>
> #### 1. 核心冲突机制
>
> 对于左递归产生式：
> $$
> A \rightarrow A\alpha \mid \beta
> $$
>
> 其冲突本质在于：
>
> **FIRST集合的重叠**：
> $$
> \text{FIRST}(A\alpha) \cap \text{FIRST}(\beta) \neq \emptyset
> $$
>
> 这是因为：
>
> - 通过左递归的无限展开 $ A \Rightarrow A\alpha \Rightarrow A\alpha\alpha \Rightarrow \cdots \Rightarrow \beta\alpha\cdots\alpha $，最终 $ A\alpha $ 也能推导出以 $ \text{FIRST}(\beta) $ 开头的字符串
> - 因此 $ \text{FIRST}(\beta) \subseteq \text{FIRST}(A\alpha) $
>
> #### 2. 具体推导过程
>
> 考虑3步展开：
> $$
> \begin{aligned}
> A &\Rightarrow A\alpha \\
> &\Rightarrow A\alpha\alpha \\
> &\Rightarrow \beta\alpha\alpha 
> \end{aligned}
> $$
>
> 此时：
> $$
> \text{FIRST}(A\alpha) \supseteq \text{FIRST}(\beta\alpha\alpha) = \text{FIRST}(\beta)
> $$
>
> #### 3. 与LL(1)条件的矛盾
>
> LL(1)文法要求：
> $$
> \text{FIRST}(A\alpha) \cap \text{FIRST}(\beta) = \emptyset
> $$
>
> 但左递归导致：
> $$
> \text{FIRST}(A\alpha) \cap \text{FIRST}(\beta) = \text{FIRST}(\beta) \neq \emptyset
> $$
>
> #### 4. 预测分析时的困境
>
> 当解析器看到输入符号 $ a \in \text{FIRST}(\beta) $ 时：
>
> - 既可以选择 $ A \rightarrow \beta $（因为 $ a \in \text{FIRST}(\beta) $）
> - 也可以选择 $ A \rightarrow A\alpha $（因为 $ a \in \text{FIRST}(A\alpha) $）
>
> #### 5. 数学形式化证明
>
> 设 $ \text{FIRST}(\beta) = \{b_1,...,b_n\} $，则：
> $$
> \begin{aligned}
> \text{FIRST}(A\alpha) &= \text{FIRST}(A\alpha) \cup \text{FIRST}(\beta\alpha) \cup \text{FIRST}(\beta\alpha\alpha) \cup \cdots \\
> &= \bigcup_{k=0}^\infty \text{FIRST}(\beta\alpha^k) \\
> &\supseteq \text{FIRST}(\beta)
> \end{aligned}
> $$
>
> #### 6. 典型示例分析
>
> 考虑算术表达式：
> $$
> E \rightarrow E + T \mid T
> $$
>
> $$
> \text{FIRST}(T) = \{id,num,(,...\}
> $$
>
> 此时：
> $$
> \text{FIRST}(E+T) \supseteq \text{FIRST}(T)
> $$
> 导致看到 $ id $ 时无法决定选择哪个产生式。
>
> #### 7. 冲突的必然性
>
> 任何形如 $ A \rightarrow A\alpha \mid \beta $ 的产生式：
>
> - 必定存在 $ \text{FIRST}(\beta) \subseteq \text{FIRST}(A\alpha) $
> - 因此永远违反LL(1)的FIRST集不相交条件
>
> #### 8. 解决方案的本质
>
> 消除左递归的关键是将递归转为右递归：
> $$
> A \rightarrow \beta A' \\
> A' \rightarrow \alpha A' \mid \varepsilon
> $$
>
> 这样：
> $$
> \text{FIRST}(\beta A') \cap \text{FIRST}(\alpha A') = \emptyset
> $$
> （假设 $ \beta $ 不以 $ \alpha $ 开头）

- 关键结论

  - 左递归文法（无论是直接还是间接）**必然不是LL(1)文法**

  - 要使文法满足LL(1)，可以尝试以下方法并不能保证将语法转换为 LL(1) 语法

    - 左递归消除

      - **直接左递归**：转换为右递归形式

        简单情况
        $$
        A \rightarrow \beta A' \\
        A' \rightarrow \alpha A' \mid \varepsilon
        $$
        一般情况

        原始：
        $$
        A \rarr A \alpha_1 \mid A\alpha_2 \mid A\alpha_m \mid \beta_1 \mid \beta_2 \mid... \mid\beta_n
        $$
        改写后：
        $$
        \begin{aligned}
        A &\to \beta_1A' \mid \cdots \mid \beta_nA' \\
        A' &\to \alpha_1A' \mid \cdots \mid \alpha_mA' \mid ε
        \end{aligned}
        $$

      - **间接左递归**：通过非终结符排序和代入消除环路

    - 左分解：

      - 简单情况：将 $\mathrm{A \rarr \alpha \beta  \mid \alpha r}$ 改写为 $ \mathrm{A \rarr \alpha(\beta \mid r)}$，令 $\mathrm{A'= \beta \mid r}$，可以得到：
        $$
        \mathrm{A \rarr \alpha A, A' \rarr \beta \mid r'}
        $$

      - 一般情况：

        改写前：
        $$
        A \rarr \alpha \beta_1 \mid \alpha \beta_2 \mid ... \mid \alpha \beta_n
        $$
        改写后：
        $$
        \begin{align}
        A &\rarr \alpha A’ \\
        A'&\rarr \beta_1 \mid \beta_2 \mid ... \mid \beta_n
        \end{align}
        $$



### 递归下降解析

**主要思想**：

- 为每个非终结符 A 定义一个可识别 A 的过程
- A 的语法规则的右侧指定了 A 的该过程的代码结构
  - 终止符对应匹配的输入
  - 非终止符对应其他过程的调用
  - 选择对应于代码中的替代方案（case 或 if）

后续将分别介绍基于 BNF 和ENBF构建递归下降解析器的通用方法



#### 通用方法

1. 确认文法 $G$ 是否为 $\text{LL(1)}$，如果不是，需要改写，最终记为 $G'$

2. 计算 $G'$ 的 $\mathrm{FIRST}$ 集 和 $\mathrm{FOLLOW}$ 集

3. 构建 $G'$ 的递归下降解析器

   包含一个主程序和一组递归过程，每个过程对应文法中的一个非终结符

   - 使用的变量：TOKEN，该变量始终保存输入中当前待处理的词法单元
   - 使用的特殊子程序：
     - $\text{match(y)}$：将当前词法单元TOKEN与参数y进行匹配，若成功则前移输入指针，否则报错
     - $\text{error}$：输出错误信息并终止程序的子程序



#### **基于 BNF 和 EBNF 构建递归下降解析器的方法**  

递归下降解析（Recursive Descent Parsing）是一种自顶向下的语法分析方法，适用于符合 **BNF（Backus-Naur Form）** 或 **EBNF（Extended Backus-Naur Form）** 定义的上下文无关文法（CFG）。该方法通过一组相互递归的函数（每个非终结符对应一个函数）来解析输入，适用于手工编写解析器或自动生成解析器（如 ANTLR、Yacc 等工具）。

---

##### **1. BNF 和 EBNF 简介**

###### **(1) BNF（巴科斯范式）**

BNF 是一种形式化表示上下文无关文法的方式，基本结构为：

```
<非终结符> ::= 产生式1 | 产生式2 | ... | 产生式N
```

例如，一个简单的算术表达式 BNF 定义：

```
<expr> ::= <term> "+" <expr> | <term>
<term> ::= <factor> "*" <term> | <factor>
<factor> ::= "(" <expr> ")" | <number>
```

###### **(2) EBNF（扩展巴科斯范式）**

EBNF 在 BNF 基础上增加了更简洁的表示方式，如：

- `{ ... }` 表示 **0 次或多次重复**（类似 `*`）
- `[ ... ]` 表示 **可选**（类似 `?`）
- `( ... | ... )` 表示 **选择**  

例如，上述算术表达式的 EBNF 版本：

```
expr   ::= term { "+" term }
term   ::= factor { "*" factor }
factor ::= "(" expr ")" | number
```

EBNF 更简洁，更适合递归下降解析。

---

##### **2. 递归下降解析的基本方法**

递归下降解析器的核心思想是：

- **每个非终结符对应一个解析函数**，函数内部按产生式规则递归调用其他非终结符的解析函数。
- **使用 `match(token)` 匹配终结符**，并向前移动词法分析器指针。
- **遇到选择分支时，使用 `if-else` 或 `switch` 进行预测**（可能需要向前看 `lookahead`）。

###### **关键步骤：**

1. **词法分析（Lexing）**  
   - 将输入字符串转换为 **Token 流**（如 `NUM, PLUS, MUL, LPAREN, RPAREN` 等）。
   - 维护一个全局（或类成员）变量 `current_token` 表示当前待处理的 Token。

2. **递归下降解析函数**  
   - 每个非终结符对应一个函数，如 `parse_expr()`, `parse_term()`, `parse_factor()`。
   - 使用 `match(expected_token)` 检查当前 Token 是否符合预期，并消耗（consume）它。

3. **错误处理**  
   - 如果遇到意外的 Token，调用 `error()` 报告语法错误。

---

##### **3. 示例：算术表达式的递归下降解析**

###### **EBNF 文法**

```
expr   ::= term { "+" term }
term   ::= factor { "*" factor }
factor ::= "(" expr ")" | number
```

###### **递归下降解析器实现（伪代码）**

```python
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.current_token = None
        self.pos = 0
        self.advance()  # 初始化 current_token

    def advance(self):
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
            self.pos += 1
        else:
            self.current_token = None  # EOF

    def match(self, expected_type):
        if self.current_token and self.current_token.type == expected_type:
            self.advance()
        else:
            raise SyntaxError(f"Expected {expected_type}, got {self.current_token}")

    def parse_expr(self):
        """ expr ::= term { "+" term } """
        result = self.parse_term()
        while self.current_token and self.current_token.type == "PLUS":
            self.match("PLUS")
            result += self.parse_term()
        return result

    def parse_term(self):
        """ term ::= factor { "*" factor } """
        result = self.parse_factor()
        while self.current_token and self.current_token.type == "MUL":
            self.match("MUL")
            result *= self.parse_factor()
        return result

    def parse_factor(self):
        """ factor ::= "(" expr ")" | number """
        if self.current_token.type == "LPAREN":
            self.match("LPAREN")
            result = self.parse_expr()
            self.match("RPAREN")
            return result
        elif self.current_token.type == "NUMBER":
            value = self.current_token.value
            self.match("NUMBER")
            return value
        else:
            raise SyntaxError("Expected '(' or number")
```

---

##### **4. 递归下降解析的优化**

###### **(1) 左递归问题**

原始 BNF 可能包含 **左递归**（如 `A ::= A "+" B | B`），会导致递归下降解析器无限递归。  
**解决方法**：

- 改写为 **右递归**（可能影响结合性）。
- 使用 **EBNF 的 `{ ... }` 循环结构**（推荐）。

###### **(2) 预测分析（Predictive Parsing）**

- 对于 `A ::= X | Y`，需要 **向前看（lookahead）** 决定选择哪个产生式。
- 可使用 **LL(1) 分析法**（1 个 Token 预测）。

###### **(3) 错误恢复**

- 遇到错误时，可以尝试 **同步恢复**（如跳到下一个 `;` 或 `}`）。
- 提供更友好的错误信息（如期望的 Token 类型）。

---

##### **5. 总结**

| 方法                       | 适用场景 | 优点                     | 缺点               |
| -------------------------- | -------- | ------------------------ | ------------------ |
| **BNF + 递归下降**         | 简单文法 | 直观，易实现             | 需手动处理左递归   |
| **EBNF + 递归下降**        | 复杂文法 | 更简洁，支持 `{ }` `[ ]` | 需额外处理预测分析 |
| **自动生成（ANTLR/Yacc）** | 大型语言 | 自动处理冲突             | 学习成本高         |

递归下降解析适用于 **手写解析器**，特别是 **LL(1) 文法**，而 EBNF 能进一步简化代码。对于更复杂的文法（如含左递归），可考虑 **工具自动生成解析器**（如 ANTLR）。



#### **构建语法树（Syntax Tree）的操作方法**

语法树（Syntax Tree，也称 **解析树** 或 **抽象语法树 AST**）是编译器或解释器的核心数据结构，用于表示源代码的层次化结构。在递归下降解析过程中，通常会在解析的同时构建语法树，以便后续进行语义分析、优化和代码生成。

---

##### **1. 语法树的基本概念**

- **语法树** 是源代码的树状表示，其中：
  - **叶子节点** 通常是 **终结符**（如变量名、数字、运算符）。
  - **内部节点** 是 **非终结符**（如表达式、语句、函数声明）。
- **抽象语法树（AST）** 是语法树的简化版本，省略了一些无关细节（如括号、分号等）。

**示例**：表达式 `3 + 5 * 2` 的语法树：

```
      +
     / \
    3   *
       / \
      5   2
```

---

##### **2. 递归下降解析中构建语法树的方法**

在递归下降解析过程中，可以在每个解析函数中返回当前子树的根节点，最终组合成完整的语法树。

###### **(1) 定义语法树节点**

通常使用 **类（Class）或结构体（Struct）** 表示不同类型的语法树节点。例如：

```python
class ASTNode:
    pass

class BinOp(ASTNode):  # 二元操作符节点（如 +, -, *, /）
    def __init__(self, left, op, right):
        self.left = left
        self.op = op
        self.right = right

class Number(ASTNode):  # 数字字面量节点
    def __init__(self, value):
        self.value = value

class UnaryOp(ASTNode):  # 一元操作符节点（如 -x）
    def __init__(self, op, expr):
        self.op = op
        self.expr = expr
```

###### **(2) 修改递归下降解析函数，返回 AST 节点**

在解析过程中，不再直接计算值，而是返回对应的语法树节点。

**示例**：算术表达式的递归下降解析器（带 AST 构建）

```python
def parse_expr(self):
    """ expr ::= term { "+" term } """
    node = self.parse_term()  # 解析左子树
    while self.current_token and self.current_token.type in ("PLUS", "MINUS"):
        op = self.current_token
        self.match(op.type)
        node = BinOp(left=node, op=op, right=self.parse_term())  # 构建新节点
    return node

def parse_term(self):
    """ term ::= factor { "*" factor } """
    node = self.parse_factor()
    while self.current_token and self.current_token.type in ("MUL", "DIV"):
        op = self.current_token
        self.match(op.type)
        node = BinOp(left=node, op=op, right=self.parse_factor())
    return node

def parse_factor(self):
    """ factor ::= "(" expr ")" | number | ("+" | "-") factor """
    token = self.current_token
    if token.type == "LPAREN":
        self.match("LPAREN")
        node = self.parse_expr()
        self.match("RPAREN")
        return node
    elif token.type == "NUMBER":
        self.match("NUMBER")
        return Number(value=token.value)
    elif token.type in ("PLUS", "MINUS"):  # 处理一元运算符（如 -3）
        self.match(token.type)
        return UnaryOp(op=token, expr=self.parse_factor())
    else:
        raise SyntaxError("Expected number or '('")
```

---

##### **3. 语法树的遍历（访问者模式）**

构建完语法树后，通常需要 **遍历（Traverse）** 它进行进一步处理（如语义检查、代码生成）。常用的方法有：

###### **(1) 递归遍历**

```python
def evaluate(node):
    if isinstance(node, Number):
        return node.value
    elif isinstance(node, BinOp):
        left_val = evaluate(node.left)
        right_val = evaluate(node.right)
        if node.op.type == "PLUS":
            return left_val + right_val
        elif node.op.type == "MUL":
            return left_val * right_val
    elif isinstance(node, UnaryOp):
        return -evaluate(node.expr)  # 处理 -x
    else:
        raise ValueError("Unknown node type")
```

###### **(2) 访问者模式（Visitor Pattern）**

适用于复杂的 AST 处理（如类型检查、代码优化）：

```python
class ASTVisitor:
    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        if node.op.type == "PLUS":
            return left + right
        elif node.op.type == "MUL":
            return left * right

    def visit_Number(self, node):
        return node.value

    def visit_UnaryOp(self, node):
        return -self.visit(node.expr)

    def visit(self, node):
        method_name = f"visit_{type(node).__name__}"
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception(f"No visit method for {type(node).__name__}")

# 使用 Visitor 计算表达式
visitor = ASTVisitor()
result = visitor.visit(ast_root)  # ast_root 是语法树的根节点
```

---

##### **4. 语法树的优化**

在构建语法树后，可以进行 **优化**，例如：

- **常量折叠（Constant Folding）**：`3 + 5` → `8`
- **死代码消除（Dead Code Elimination）**：移除不会执行的代码
- **公共子表达式消除（CSE）**：避免重复计算

**示例**（常量折叠优化）：

```python
def optimize(node):
    if isinstance(node, BinOp):
        left = optimize(node.left)
        right = optimize(node.right)
        if isinstance(left, Number) and isinstance(right, Number):
            if node.op.type == "PLUS":
                return Number(left.value + right.value)
            elif node.op.type == "MUL":
                return Number(left.value * right.value)
        return BinOp(left, node.op, right)
    return node
```

---

##### **5. 总结**

| 步骤                            | 操作                                       |
| ------------------------------- | ------------------------------------------ |
| **1. 定义 AST 节点**            | 用类或结构体表示不同类型的语法树节点       |
| **2. 在递归下降解析时构建 AST** | 每个解析函数返回对应的子树                 |
| **3. 遍历语法树**               | 使用递归或访问者模式进行语义分析、代码生成 |
| **4. 优化语法树**               | 常量折叠、死代码消除等                     |

语法树的构建是编译器的关键步骤，递归下降解析器可以自然地与 AST 构造结合，适用于 **手写解析器** 或 **小型语言实现**。对于更复杂的语言，可以使用 **解析器生成工具（如 ANTLR）** 自动生成 AST。



### LL(1) 解析

自上而下的预测解析要求语法必须是 LL(1) 语法 。

预测解析包含两种：递归下降解析和 LL(1) 解析。

LL(1) 解析使用**显式堆栈**而不是递归调用来执行解析，堆栈**存储解析中等待匹配的符号**



#### LL(1) 解析的基本方法

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505122338311.webp)

成功的 LL(1) 解析示意图如下：

- 解析首先将**起始符号**推入堆栈
- 将**堆栈顶部的标记**与**下一个输入字符串**进行匹配，当匹配时，通过弹出堆栈并推进输入的方式，从堆栈和输入中丢弃标记。
- 使用语法规则 $A \rarr \alpha $，将栈顶的非终止符 $A$ 替换为 $\alpha$（$\alpha$ 被反向推送到堆栈中）。
- 成功解析后，堆栈和输入将为空



#### LL(1) 解析表

功能：表达**非终结符**在适当的解析步骤中使用的生成选择

- 由非终结符和终结符索引的二维数组
- `M[N,t]` 是基于当前输入 $\text{t (termimal or \$)}$，在适当的解析步骤中使用的 `N` 的产生式选择
- 如果 `M[N,t]` 在构造后仍为空，则表示解析过程中可能发生潜在错误



**构造 LL(1) 解析表**

对每个非终极符 $A$ 和 可选择的产生式 $A \rarr \alpha$ 重复以下两个步骤：

- 对于每一个 $\mathrm{First(\alpha)}$ 中的每一个 $\text{a}$，添加 $A \rarr \alpha$ 到 表格 `M[A,a]`
- 如果 $\varepsilon$ 在 $\mathrm{FIRST(\alpha)}$，对于 $\mathrm{FOLLOW(A)}$ 中的每一个元素 $\text{a (token or \$)}$，添加 $A \rarr \alpha$ 到 `M[A,a]`



**补充**

如果相关的 LL(1) 解析表在**每个表条目中最多有一个产生式**，则该语法为 LL(1) 语法。



### 自上而下的解析器中的错误恢复

- 解析器必须确定程序的语法是否正确
- 解析器对语法错误的响应通常是编译器实用性的关键因素



#### 常见的语法错误

- 程序、表达式和语句的起始和后续符号
- 标识符和常量错误
- 括号匹配错误
- 符号错误



#### 错误处理

- 给出有意义的错误信息
- **选择一个可能的位置继续解析。解析器应该始终尝试解析尽可能多的代码，以便在单次翻译过程中找到尽可能多的实际错误**。



#### 递归下降解析器中的错误恢复

**恐慌模式**

- 在复杂的情况下，错误处理程序将消耗大量的令牌，以尝试找到恢复解析的位置
- 基本机制：
  - 为每个递归过程提供一个由一组同步标记组成的额外参数
  - 如果遇到错误，解析器会继续扫描，丢弃标记，直到在输入中看到同步标记集之一中的标记