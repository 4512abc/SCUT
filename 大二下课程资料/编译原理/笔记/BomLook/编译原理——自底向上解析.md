# 编译原理——自底向上解析

## 自底向上解析

### 自底向上概述

#### 核心思想

**定义**：解析从输入字符串开始，通过减少的步骤，尝试将输入字符串减少到语法的起始符号。

**解析树的构造**：输入字符串是解析树的叶子，解析过程一直到根部，也就是起始符号

**例子**
$$
\begin{align}
\text{G:}&	\\
&\mathrm{S \rarr cAd}	\\
&\mathrm{A \rarr ab}	\\
&\mathrm{A \rarr a}		\\
\end{align}
$$
自底向上解析字符串：cabd
$$
\text{cabd |- cAd |- S}
$$
**使用 $\text{|-}$ 表示归约步骤，即最右推导步骤的逆过程**



#### 关键

在每个归约步骤中，与产生式右侧匹配的**特定子字符串**将被**产生式左侧的结构名称**替换。

**自底向上解析的关键是如何确定需要规约的子串。**参考上面的例子：
$$
\text{cabd |- cAbd}
$$


我们可以发现最后无法实现转为 $\text{S}$



#### 实现

自底向上的解析器通过使用显式堆栈来执行解析过程，示意图如下：（暂时还没看懂这个图）

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141407032.webp)

---

**比较**

- 自顶向下的解析栈包含了 token 和非终止符，自底向上的解析栈包含了 token，非终止符和状态。
- **自顶向下的解析栈存储解析中等待匹配的符号，自底向上的解析栈存储已经匹配的符号。**

---

1. 根据堆栈内容并使用输入中的下一个 token 作为前瞻来确定要执行的下一个操作
2. 自底向上的解析器有两种可能的操作：
   - 移位：将终端从输入的前端移到堆栈的顶部
   - 减少：给定产生式 $\mathrm{A \rarr \alpha}$，将堆栈顶部的子串 $\alpha$ 减少为非终止符 $\mathrm{A \rarr \alpha}$

故自底向上解析也被称为移位规约解析。

**例子**：

给定语法 $\text{G}$ 如下：
$$
\begin{align}
&\mathrm{S \rarr aAcBe }\\
&\mathrm{A \rarr b	}\\
&\mathrm{A \rarr Ab	}\\
&\mathrm{B \rarr d	}\\
\end{align}
$$


解析过程如下：

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141438839.webp)

一个关键的问题是：如何确定往前找多少位？或者说：

- 如何确定合适移位以及何时减少？不同的确定方法会导致不同的解析器，其能力和复杂性也各不相同。

我们接下来先从自底向上解析的特点入手。



#### 特点

1. Right Sentential Form 正确的句子形式
2. Viable Prefix 可行的前缀
3. Handle 句柄

##### 正确的句子形式

移位归约解析器以相反的顺序追踪输入字符串的最右推导，如：
$$
G:S \rarr aAcBe,A \rarr b, A\rarr Ab, B\rarr d \\
$$

$$
\text{Rightmost dervition}: S \rarr aAcBe \rarr aAcde \rarr aAbcde \rarr abbcde
$$

$$
\text{Shift-reduce}: abbcde |- aAbcde |- aAcde |- aAcBe |- S
$$

其中，最右推导中的每个中间句型被称为右句型。



每个正确的句子形式被拆分到解析栈中输入之间：
$$
\text{Shift-reduce}: abbcde |- aAbcde |- aAcde |- aAcBe |- S
$$
![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141458208.webp)

移位-归约解析器会将终端从输入移到堆栈，**直到可以执行归约**以获得下一个正确的句子形式



##### 可行的前缀

**解析堆栈上的符号序列**称为**正确句型**的可行前缀

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141500341.webp)

$aAcde$ 是一个正确的句子形式，它在第6，7，8步中被划分为两部分（在解析栈中和输入中），其中 $aA,aAc,aAcd$ 都是 $aAcde$ 的可行前缀。



##### 句柄

右句型 $\gamma=\alpha \beta \omega$ 的句柄是与产生式 $A \rarr \beta$ 的右侧匹配的子字符串 $\beta$，并且可以用 $A$ 替换以在 $\gamma$ 的最右侧推导中生成前一个右句型。

也就是说，右句型 $\alpha \beta \omega$ 的句柄 $\beta$ 有三个条件：

1. $\alpha \beta \omega$ 是右句子（即 $S \rarr * \alpha \beta \omega$）
2. $A \rarr \beta$ 是一个产生式
3. $S \rarr * \alpha A \omega \rarr \alpha \beta \omega$（注意，手柄右侧的 $\omega$ 仅包含终止符）

**示例**
$$
G: S \rarr aAcBe,A\rarr b, A\rarr Ab, B\rarr d
$$
给出 $aAbcde$ 的句柄

其最右推导为：
$$
S \rarr aAcBe \rarr aAcde \rarr aAbcde
$$
故 $aAbcde$ 的句柄为 $Ab$

然而，在很多情况下，与某些产生式 $A \rarr \beta $ 的右侧匹配的最左边子串 $\beta$ 可能不是一个句柄，因为通过产生式 $A \rarr \beta$ 产生的字符串不是正确的句子形式。

如：
$$
S \rarr cAd, A \rarr ab ,A \rarr a
$$
故：

1. $cabd |-cAd |- S$，$ab$ 是 $cabd$ 的句柄
2. $cabd |- cAbd$，$a$ 不是 $cabd$ 的句柄 



##### 联系

- 句柄和可行前缀
  - 可行前缀是右句形式的前缀，它从左到右不超过该句型句柄的右端。
  - e.g:  $aAbcde$ （其中 $Ab$ 是句柄），其中可行前缀有 $a,aA,aAb$

- 句柄和移位归约解析

  - **确定解析器中的下一个句柄**是移位-归约解析器的主要任务
  - 当下一个句柄位于栈顶部时，执行操作 **reduce**
  - 当下一个句柄尚未在栈顶部形成时，采取行动 **shift**

  ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141538012.webp)

#### 总结

**从实现角度分析自底向上解析的特点**

- **解析器不断将活前缀放入堆栈**

- **只要堆栈的内容是活前缀，解析就是正确的**
- **当句柄位于堆栈顶部时，将执行 reduce**



**一般特征**

- 比自顶向下的解析更强大，几乎可以解析所有的编程语言
- 构造更加复杂



### LR 解析方法概述

#### 定义

基于解析栈顶部的字符串（表示为状态），并使用输入中的接下来的 $K(K \geq 0)$个标记作为前瞻来确定减少的句柄

- $L$ 表示从左到右进行处理
- $R$ 表示生成最右推导
- $K$ 表示用于**做出解析决策**的前瞻输入符号数



**效果**

- LR(0) 解析：在制定解析决策时没有前瞻符号可以参考
- SLR(1) 解析（即简单 LR(1)）：对 LR(0) 的改进
- LR(1) 解析：最强大，最复杂

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141609447.webp)



#### 解析表

解析表每一行代表一个状态，每一列是一个语法符号

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141610985.webp)

- 动作：采取一个状态和一个终止符，确定下一步要采取的动作
- GOTO：获取一个状态和一个语法符号，确定下一个状态

为了节省空间，压缩终止符列上的 ACTION 和GOTO

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505141712116.webp)

##### ACTION 表

表格条码 $action[S_m,a_i]$ 有如下四种类型值：

1. $\text{Shift}(s_k)$：将符号 $a_i$ 和 状态 $K$ 放入栈中
2. $\text{Reduction}(r_k)$：根据 第 $K$ 个产生式 $A \rarr \gamma$，action 包括如下：
   - 假设当前堆栈顶部是状态 $S_i$，从栈中弹出字符串 $\gamma$ 和它所有对应的状态。
   - 将 $A$ 压入堆栈
   - 将状态 $S_j =GOTO[S_i,A]$ 压入堆栈
3. $Accept$：表示解析成功完成
4. $Error(Empty)$：表示解析发现了错误



#### 总结

LR 解析程序**对于所有 LR 解析器都是相同的，只有解析表在不同解析器之间有所不同**

LR 解析器的关键在于**如何针对每个不同的文法、不同的 LR 解析器构建解析表？**



### LR(0) 的有限状态机和 LR(0) 的解析

#### LR(0) 解析

- 使用 LR(0) 解析表的 LR 解析器称为 LR(0) 解析器
- LR(0) 语法：可以构建 LR(0) 解析表的语法
- LR(0) 解析器仅使用栈的内容来确定句柄，它不需要输入标记作为前瞻
- LR(0) 解析在实际应用中非常少见，但是 LR(0) 方法是学习 LR 解析的一个很好的起点。



#### 构建 LR(0) 解析表

- LR(0) 项
- LR(0) 项的有限状态机
- 构造 LR(0) 解析表



##### LR(0) 项

LR(0) 项是语法 $G$ 的一个产生式，该产生式的右侧中存在一个特殊的位置。

**示例**
$$
U \rarr XYZ
$$
有四项：
$$
\begin{align}
U &\rarr ·XYZ \\
U &\rarr X·YZ \\
U &\rarr XY·Z \\
U &\rarr XYZ·
\end{align}
$$


 特别地：
$$
A \rarr \varepsilon \text{只有一项} A \rarr ·
$$
上述这些被称为 LR(0) 项，因为他们不包含对前瞻的明确引用（？）



##### Item 的含义

一个 Item 记录了识别产生式右侧的中间步骤。

- $A \rarr ·\beta \gamma$：表示我们可能即将通过产生式 $A \rarr \beta \gamma$ 来识别 $A$
- $A \rarr \beta·\gamma$：表示 $\beta$ 已经被看到（？），且 $\beta$ 必须出现在栈顶部
- $A \rarr \beta \gamma ·$：表示 $\beta \gamma$ 位于栈顶部，且可能是句柄，并且 $A \rarr \beta \gamma$ 将用于下一次规约。

##### Item 的类别

Initial Item：形式为 $A \rarr ·\alpha$ 的项目，表示识别 $\alpha$ 的初始化

Complete Item：形式为 $A \rarr \alpha ·$ 的项，表示识别 $\alpha$ 的完整性



##### Items 的有限状态机

LR(0) 项可以作为有限状态机的状态，该自动机维护**有关解析栈和shift-reduce 解析进度**的信息。

1. 构建 LR(0) Item 的NFA。
2. 直接构建 LR(0) Item 集合的DFA。



###### 直接构建 Item 集合的DFA

**增强语法**

1. 在构建 DFA 之前，首先通过单个产生式 $S'\rarr S$ 来扩充语法，其中 $S'$ 是一个新的非终端，它成为扩充语法的起始符号。
2. $S' \rarr S$ 成为 DFA 起始状态中的第一个 Item。

**示例**
$$
G[E]: E \rarr aA | bB, A \rarr cA|d, B\rarr cB|d
$$

$$
\text{增强语法G[E]}:S' \rarr E,E \rarr aA |bB, A \rarr cA |d, B \rarr cB|d
$$



DFA 的每个状态都是一组 LR(0) Item，通过**闭包操作**构建状态

符号 $X$ 从状态 $i$ 到 $j$ 的转换过程如下：

- 如果 $X$ 是一个 token，则此转换对应解析过程中 $X$ 从输入移动到栈顶部。

- 如果 $X \in V_N$，此转换对应将 $X$ 推入到栈中，它只能在通过产生式 $X \rarr r$ 进行归约时发生。

- 通过 goto 操作，构造从一个状态到另外一个状态的转移。



**闭包操作**

如果 $\mathrm{I}$ 是 LR(0) item 的集合，则 $\mathrm{closure(I)}$ 是 一个 构造的 Items 集合，遵循如下规则：

1. 最初， $\mathrm{closure(I)=I}$
2. 如果 $A \rarr \alpha ·B\beta$ 在 $\mathrm{closure(I)}$ 中，且 $B \in V_N$，则对于每一个产生式 $B \rarr r$，如果不存在 $ B \rarr ·$，则将 Item $B \rarr ·r$ 添加到 $\mathrm{closure(I)}$ 中
3. 不断重复步骤2，直到不再添加新 Item。

对于每个以“ • ”结尾或后跟终止符的 Item，该 Item 的闭包就是该 Item 本身

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505142238400.webp)

**goto 操作**

$\mathrm{I}$ 是一组 Item 的集合， $X \in V_N \cup V_T$， $\mathrm{goto(I,X)=closure(J)}$，$J$ 是所有 Item 的集合，如 $[A \rarr \alpha ·X\beta]$。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505142243562.webp)

**DFA 的构建**

1. $\mathrm{closure({S'\rarr ·S})}$ 是 DFA 的起始状态，且是无标签的。
2. 从 DFA 获取未标记状态 $\mathrm{IS_i}$
   - 标签 $\mathrm{IS_i}$
   - 对于 $\mathrm{IS_i}$ 中的每个 Item $U \rarr x ·Ry(R \in V_N \cup V_T, \text{x and y are strings})$，计算 $\mathrm{goto(IS_i,R)=IS_j}$
     - 如果不存在，将 $\mathrm{IS_j}$ 作为未标记，添加到 DFA 中
     - 添加从 $\mathrm{{IS_i}}$ 到 $\mathrm{{IS_j}}$ 的传递（on $R$）
3. 重复步骤 2，直到 DFA 中没有未标记的状态



![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505142257789.webp)



**动作**：LR(0) 解析不参考输入标记，因此LR(0) 解析状态要么是 **shift** 状态，要么是 **reduce** 状态

**GOTO**：每个符合 $(V_N,V_T,\$)$ 都必须有一列



给定语法 $G$，我们扩充 $G$ 以生成 $G'$

1. 为 $G'$ 构建 LR(0) 项集的 DFA

2. 状态 $K$ 的 ACTION 部分确定如下：（将每个状态映射到一个动作）

   - 若 $A \rarr \alpha·\beta \in K$，则 `ACTION[K]=Shift`
   - 若 $A \rarr a · \in K$（约简 Item），且 $A\rarr \alpha $ 的数字为 $j$，则 设置 `ACTION[K]=R_j`

3. 状态 $K$ 的 GOTO 部分（将状态/符号对映射到下一个状态）是使用以下规则为所有符号构建的：

   如果 $\mathrm{goto(K,X)=J}$，$\mathrm{X\in V_N \cup V_N \cup{$}}$，则设置 `GOTO[K,X]=J`



### SLR(1) 解析

#### Item 中的冲突  

- 移进-归约冲突（Shift-Reduce Conflict） 

  若一个项集中同时包含移进项 $A \rarr \alpha · \alpha \beta$ 和归约项 $B \rarr r ·$，则会出现歧义：此时应移进符号 'a' 还是将 'r' 归约为 B。  

- 归约-归约冲突（Reduce-Reduce Conflict） 

  若一个项集中同时包含两个归约项 $A \rarr \beta·$ 和 $B \rarr r·$，则会出现歧义：此时应选择哪个产生式进行归约。 当且仅当文法所有项集均不存在移进-归约冲突和归约-归约冲突时，该文法才是 LR(0) 文法。  

  ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505142340612.webp)





#### 消除 SLR(1) 中的冲突

##### SLR(1)（简单 LR(1)）的核心思想  
SLR(1) 解析是 LR(0) 的一种简单而有效的扩展，其特点包括：  
1. **沿用 LR(0) 的 DFA 项集**：基于 LR(0) 的有限状态自动机构建。  
2. **增强 LR(0) 的解析能力**：通过预读输入串中的下一个符号（lookahead token）指导动作决策。  
3. **实际适用性**：这种简单的预读机制足以解析几乎所有实际编程语言。  

##### 预读符号（Lookahead Token）的两种应用方式  

1. **移进前的预读检查**  
   
   - 在移进前检查输入符号，确保存在对应的 DFA 状态转移。  
2. **归约时的 Follow 集约束**  
   - 对归约项 $A \rarr a ·$，仅当下一个符号 $a \in FOLLOW(A)$ 时才会执行归约。  
   
   ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505142348187.webp)



#### SLR(1)解析表的构造

给定文法 $ G $，首先对其进行**增广**，得到 $ G' $，然后按以下步骤构造分析表：  

**1. 构造 LR(0) 项集的 DFA**  

- 计算所有 LR(0) 项集，并构建 DFA（状态转换图）。  

**2. 确定 ACTION 表（状态 $ K $ 的决策）**  

**(a) 移进动作（Shift）**  
- 如果项集 $ K $ 包含 **$ A \to \alpha \cdot a \beta $**（其中 $ a $ 是终结符），且 **goto($ K, a $) = $ J $**，则：  
  $$
  \text{ACTION}[K, a] = '\mathrm{S_J}' \quad (\text{移进 } a \text{ 并跳转至状态 } J)
  $$

**(b) 归约动作（Reduce）**  
- 如果项集 $ K $ 包含 **$ A \to \alpha \cdot $**（即可以归约），并且该产生式编号为 $ j $，则：  
  $$
  \text{ACTION}[K, b] = \text{R}_j \quad \text{（对所有 } b \in \text{FOLLOW}(A) \text{）}
  $$

**(c) 接受动作（Accept）**  
- 如果项集 $ K $ 包含 **$ S' \to S \cdot $**（增广文法的初始项），则：  
  $$
  \text{ACTION}[K, \$] = '\mathrm{acc}' \quad (\text{接受输入，分析成功})
  $$

**3. 构造 GOTO 表（非终结符的跳转）**  

- 如果项集 $ K $ 包含 **$ A \to \alpha \cdot B \beta $**（其中 $ B $ 是非终结符），且 **goto($ K, B $) = $ J $**，则：  
  $$
  \text{GOTO}[K, B] = 'J' \quad (\text{遇到 } B \text{ 时跳转至状态 } J)
  $$

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202505150024145.webp)
