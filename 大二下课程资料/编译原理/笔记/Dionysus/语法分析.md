对于前面词法分析器给出的序列，分析其是否符合语言的文法

错误，则报错

正确，则构成语法分析树



#### 分类

1. 自顶向下，处理LL文法

   从语法树的根部开始构造

2. 自底向上，处理LR文法

   从语法树的叶子开始构造

3. 通用语法

   可以对任意文法分析，但效率低

4. 后两种方法

   从左到右、逐个扫描词法单元

#### 编程语言描述

- 上下文无关文法 CFG
- BNF

前者可以看作抽象的数学形式，后者是具体的语言规范

#### CFG

> 简单来说，**CFG 是一套规则**，用来描述语言（比如程序语言或表达式）里什么样的字符串是“合法的”，语法结构是怎么样的。
>
> 它由四个部分组成：
>
> ------
>
> ### （1）终结符号（Terminals）
>
> - 就是“语言的基本符号”，不能再拆了。
> - 类似于语言里的单词或者符号，比如程序里的关键词、运算符、标识符（变量名）等。
> - 在算术表达式中，就是：`id`（变量或数字）、`+`、`-`、`*`、`/`、`(`、`)`。
>
> ------
>
> ### （2）非终结符号（Non-terminals）
>
> - 是抽象的“语法类别”或“语法变量”，用来表示语法结构的组成部分。
> - 它们不会出现在最终的字符串里，只在语法规则里用来“展开”成终结符号序列。
> - 类似语法中的“句法单位”。
> - 你的例子中有：`expression`（表达式）、`term`（项）、`factor`（因子）。
>
> ------
>
> ### （3）开始符号（Start symbol）
>
> - 是**整个语法的起点**，从它开始推导可以产生所有合法的字符串。
> - 对应语言中的“最顶层结构”。
> - 例子中是 `expression`，意味着我们定义的语言是由表达式组成的。
>
> ------
>
> ### （4）产生式（Productions）
>
> - 就是语法规则，告诉我们如何用非终结符号“展开”成终结符号和其他非终结符号的组合。
>
> - 形式是：`头部 → 体部`
>
>   - 头部：一个非终结符号
>   - 体部：由终结符号和非终结符号组成的字符串
>
> - 例如：
>
>   ```
>   expression → expression + term
>   expression → expression - term
>   expression → term
>   term → term * factor
>   term → term / factor
>   term → factor
>   factor → ( expression )
>   factor → id
>   ```
>
> - 这些规则告诉我们：
>
>   - 一个表达式可以是“表达式 + 项”，也可以是“表达式 - 项”，或者就是“项”。
>   - 一个项可以是“项 * 因子”、“项 / 因子”，或者是“因子”。
>   - 一个因子可以是括号里的表达式，或者就是一个标识符（id）。
>
> ------
>
> ## 2️⃣ 这套规则怎么用？
>
> - 从开始符号 `expression` 出发，不断用产生式替换非终结符号，直到全部变成终结符号。
> - 得到的终结符号序列就是一个合法的表达式字符串。



项（item）、因子（factor）

| 名称   | 作用                             | 例子                        |
| ------ | -------------------------------- | --------------------------- |
| 因子   | 最小单元，数字/变量/括号内表达式 | `id`, `(expression)`        |
| 项     | 乘除法表达式层                   | `id * id`, `(id + id) / id` |
| 表达式 | 加减法表达式层                   | `id + id * id`              |

文法中的 | 表示多个可选项，可以解析为不同的产生式

##### 推导

从开始符号出发，根据文法一步步将非终结符号替换为终结符号

- 推导序列：

  用 => 表示每一步的替换过程

- =*> 表示零步或多步推导

  =+> 表示一步或多步推导

##### 句型、句子、语言

- 句型：

  某个开始符号经过一次或多次推导可以得到字符串a，这个字符串a就叫做句型，可以包含终结符号、非终结符号甚至空串

- 句子：

  只包含终结符号的句型

- 语言：

  句子集合

##### 语法分析树

- 树的叶子节点（终结、非终结符或ε）组成的序列是根（开始符号）的一个句型
- 一颗语法树有多个**推导序列**（这个倒是没啥，可以看定义），但是只有唯一的最左推导以及最右推导（不包含非终结符的推导序列）

从推导序列到语法分析树，其实就是逐步展开而已，没啥难的，ε也可以作为结点

- 任意正则表达式都有一个其对应的文法，可以对该正则对应的NFA构造CFG

  文法可以表示的语言比正则的更多，原因在于有穷自动机不能计数。比如要求在b的前后有任意相同数量的a，就无法做到

#### 文法的设计

在进行更高效的语法分析之前，需要对文法做以下处理

- 消除二义性

  一个文法下，相同的句子可以有多棵可选择的生成树，这一部分是由于无括号造成的

- 消除左递归

  对于某个非终结符号，在其推导若干步后，会得到包含该非终结符号的结构，这样的话会一直推导下去

- 提取左公因子

  消除产生式的冲突，当产生式右侧有相同的前缀时，可以提取出来，后面的写为一个新的产生式去处理

  避免first集冲突

#### 消除二义性

以 if then else为例，可能存在else不知道匹配哪个if的情况。这个时候可以采取匹配最近的

另外一种方法是加入matched和open两个前缀，区分语句是否已经匹配好

二义性的消除没有通用方法，而且有时候需要二义性，看具体情况来了

#### 消除左递归

必要性：自顶向下的语法分析不能处理左递归的情况，所以必须要消除

##### 立即左递归的消除

立即左递归：形如A -> Aα

希望改写为不会马上调用自己的形式

###### 例 A → A α | β

根据原来的式子，A会一直往下调用，但是至少会调用到一次β作为终止。

那么可以改写为：

```
A → β A'
A' → α A' | ε
```

α可以随意调用，就是说，β一定有，后面跟多少个α看心情，没有都可以

这个比喻比较有意思：β是套餐主菜，α是自助餐，随便吃

##### 消除多步左递归

核心思路：展开推导过程，将多步左递归转换成立即左递归，然后用立即左递归的方法解决就行

比如这个例子

```
S → Aa | b 
A → Ac | Sd | ε
```

① 一个文法一个文法地展开为立即左递归式，可以展则展

​	第一层S（i=1），往上没有可展开的（j=i-1=0）

​	第二层A，应用往上for（j=i-1）的文法进行展开，得到` A → Ac | Aad | bd | ε`

​	消除A的立即左递归：

```
A -> bdA' | A'
A' -> cA' | adA' | ε     # 记得要加上ε！要不就不是任意个而是无数个了，无法终止
```

#### 预测分析法

##### 简介

- 不回溯，但是要求文法没有左递归并且要提取左公因子

- 试图从开始符号推导输入的字符串

- 每次都为最左边的非终结符号选择一个产生式，但有多个产生式时就无能为力了

##### 提取公因子

对于非终结符号A，从它多个可选的产生式中找到最长公共前缀，简化文法

比如如下转换

```
A → αβ1 | … | αβn | γ 
```

↓

```
A → αA' | γ 
A' → β1 | … | βn
```

又比如：

![image-20250608152308141](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608152308141.png)

#### 自顶向下的语法分析

##### 简介

从根节点开始，按照先根次序，深度优先的创建各个结点

对应最左推导

##### 基本步骤

逐个对最左边的非终结符号展开，选择应用的产生式

将产生式与输入符号进行匹配

**注意，输入一般是一个表达式，逐步展开为语法分析树，在过程中，文法右侧可能存在多个推导，要选择能匹配输入式子的推导式来构建分析树**

每个非终结符号对应一个进程，该进程负责匹配该非终结符号对应的结构

##### 回溯

信息不足，给的输入不能唯一确定可能的产生式时，会发生回溯，回退到上一个选项的指针处选一个满足输入的产生式。当没有产生式可选时，输入就不是该文法下的一个句子了。

注意，对于可选产生式，按顺序从左边开始选，符合条件就往下，不符合条件就回退，选下一个

##### 向前看符号 lookahead

避免回溯的一种方法，一般向前看一个

比如：当前句型是xAβ，而输入是xa时，选择A -> α且满足唯一性，必须满足以下条件之一

① α =*> a… 

② α =*> ε，且β以a开头，即在某个句型中a跟在A之后

##### first和follow集

###### First(α)

表示从某个串α出发，能够推导出的最终串第一个终结符的集合（包含ε）

FIRST函数的意义 

– A的产生式 A → α | β，且FIRST(α)和FIRST(β)不相交 

– 下一个输入符号是a，若a ∈ FIRST(α)，则选择A → α，若a ∈ FIRST(β)，则 选择A → β

###### 计算First的方法

- First(X)
  1. 如果X本身就是终结符号，加入X
  2. 如果X展开为产生式（连接的情况，比如Y1Y2Y3…Yn）：
     1. 对于Yi中推导出的终结符a，必须满足在Yi之前的所有Y，都包含终结符ε，a才可以加入
     2. 如果所有的Y都有ε，才可以加入ε
  3. X是非终结符号且X->ε，那么加入ε
  4. 如果是多个产生式，或的形式，取并集

- First(X1X2X3…Xn)，和上面连接的情况一样

###### follow(A)

– 可能在某些句型中紧跟在A右边的终结符号的集合 

– 如：S → αAaβ，终结符号a ∈ FOLLOW(A)

应用：如果A->α且α->ε时，通过Follow(A)可以选择恰当的产生式

例如：A → α，而b属于FOLLOW(A)，如果α => ε，而当前输入符号是b， 则可以选择A → α，因为A最终到达了ε，而且后面跟着b

###### follow(A)的计算

基于先计算好了所有的first哈

首先将右端结束标记加入到Follow(S)中，即开始符号中

随后进行迭代，直到所有的Follow集合不再变化：

① 对于邻接的AB，follow(A) = first(B) - {ε}

② 对于产生式中的最后一个符号，或者该符号邻接的下一个符号的first集有ε，要将产生式左侧符号的follow集合并到该非终结符上。

比如 S -> AB，即上面情况中只有A了，那么follow(B) = follow(S) = {$}



看一下例子吧，其实要注意的还挺多的

首先是计算first，需要逐个深入，比如求first(E)，那要先看第一个产生式子T，然后又要看F，F产生式得到最终串，各选第一个终止符，( 和id

然后回溯，由于first(F)中没有ε，那也不用再看T ' 了，同理往上，得到了F T E的first集合。

同理，计算E ' 、T ' 的first集合，最终串可以直接拿到

![image-20250608161740888](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608161740888.png)然后再计算follow集合，先找开始符号，给$ ，然后从开始符号出发，通过产生式往下走，比如TE '，最好从右到左去找follow，避免递归，那E ’ 的follow就等于E ，然后找T的，加上first(E)

![image-20250608161748405](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608161748405.png)

#### LL(1)文法

满足三个条件

定义：对文法的任意两个产生式A → α | β 

– 不存在终结符号a使得α和β都可推导出以a开头的串 

– α和β最多只有一个可推导出空串 

– 如果β可推导出空串，那么α不能推导出以FOLLOW(A)中任何终结符号开头 的串

用数学语言描述其实就只有两个：

– FIRST(α) ∩ FIRST(β) = Φ (条件一和二) 

– 如果ε ∈ FIRST(β)，那么FIRST(α) ∩ FOLLOW(A) = Φ；反之亦然 (条件三)

##### 优点

能够在自顶向下的分析过程中，给定输入符号可以确定使用的产生式

#### 预测分析表

给定输入的文法G，可以得到一个预测分析表M输出

##### 操作方法

– 对于文法G的每个产生式A → α 

• 对于FIRST(α)中的每个终结符号a，将A → α加入到M[A, a]中 

• 如果ε在FIRST(α)，那么对于FOLLOW(A)中的每个符号b，将A → α也加入到M[A, b]中 

– 最后在所有的空白条目中填入error

可以看一下例子，主要是表的结构，行代表所有推导的左侧符号，列代表所有的终止符

**注意带有括号的产生式右侧项，括号里的项follow集里要加右括号 )**

![image-20250608165511113](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608165511113.png)

LL(1)文法必然不是二义的

预测分析表可能出现冲突，即同一个格子填了两个及以上产生式

#### 非递归的预测分析

使用栈来存放每次分析余下部分的左端

##### 分析时的处理过程

 – 初始化时，栈中仅包含开始符号S (和\$)，其中\$可以看作栈的保护符，当匹配到这一步时说明匹配成功

– 如果栈顶元素是终结符号，那么进行匹配 

– 如果栈顶元素是非终结符号：

​	• 使用预测分析表来选择适当的产生式 

​	• 在栈顶用产生式右部替换产生式左部

#### 预测分析算法

输入：串w，预测分析表M

分析过程直接参考实例吧：

![image-20250608170815586](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608170815586.png)

GPT例子：

![image-20250608170839151](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608170839151.png)

![image-20250608170856806](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608170856806.png)

嗯可以看出来如果复杂的情况下，有分析表确实会好办很多，将抽象文法和实际的输入符号匹配起来，直接选择就OK了，而且对于无二义性的文法来说甚至不用回溯，照着选就完事了

#### 自底向上的语法分析

也是为了给输入串构造语法分析树，但是从叶子开始

分析的通用框架：移入–归约(shift - reduce)，简称LR嘛

① 简单LR：SLR

② LR

看下面这个示例图，从具象符号到抽象文法，和自顶向下的反过来

![image-20250608171531213](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608171531213.png)

对比一下先前的自顶向下，现在看这个自顶向下更有感觉了，所有的first、follow是用来为后面LL(1)文法以及预测分析表作铺垫的，而有了预测分析表就可以明确地按照先根顺序决定每步要匹配什么了，LL(1)文法决定了唯一性

![image-20250608171700364](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608171700364.png)

- 规约：

  将串w匹配到开始符号S的过程，那这也很有说法了，也会产生二义性，到底要匹配到哪个非终结符号呢

  原则是：每一步规约的结果都必须是文法中的**句型**，只看当下的产生式的话，后面会无法进行，那么也要回溯？

- 采用最左规约，反过来就是最右推导

#### 移入 – 规约

要先逐个将符号移入栈，构成某个产生式的右部，就是归约了

- 每一步归约的的符号串就叫做句柄，句型的最左直接短语。句柄一旦形成就进行归约，这样下来就确保是最左归约了。 
- 一旦符合某条规则就进行归约，当输入栈没有符号且归约后只剩开始符号时，就完成了归约。如果输入栈已经没有符号，但分析栈中还剩一堆，那就归约失败了。
- 目前分析栈的右侧可能构成多个句柄，会有冲突

#### LR分析法

L：对输入进行从左到右的扫描

R：反向构造出一个最右推导序列

LR(k)，向前查看k个符号，实践里一般为0或1

##### 基本原理

- 正确识别句柄是自底向上分析的关键
- 句柄是逐步形成的。用状态来表示句柄识别的进展程度
  - 移进状态（尚未有输入）
  - 待约状态（在中间）
  - 归约状态（可以归约了）

#### LR分析表

这个很好用嗷，两个栈，一个存状态一个存当前分析所存的字符串，根据状态 + 下一个字符来确定操作是移入还是归约。当前栈顶如果是非终结符号，那么要进行GOTO操作，进入到某个状态，然后再查表进行操作

#### LR(0)分析法

##### 项目

产生式右侧标有圆点

项目描述识别状态

每个产生式对应一个项目

##### 增广文法

为了让文法的开始符号只出现在一个产生式的左部

##### 后继项目

同属于一个产生式，圆点的位置只差一个符号

##### 等价项目

对于待约项目而言的

等待某个非终结符，它会在一些产生式左侧出现，那么这些产生式的移进状态（第一条，圆点在最左边）状态是等价的

项目集闭包

##### 自动机

零号状态对应所有的产生式，然后根据不同输入进入到不同的状态。每个状态对应一个**项目集闭包**。

项目集闭包就是上面所说的等价项目，求法：当圆点右侧为非终结符时，看右侧该非终结符有什么产生式，将该产生式的移进项目放进该闭包集合

##### 分析表

通过自动机转换图，将不同状态接受不同输入后的情况填入表即可

表由状态、终结符（对应ACTION）、非终结符（对应GOTO）组成

可归约时表内填上rx

#### LR(0)分析表构造算法

##### CLOSURE()函数

计算项目集闭包（状态）

##### GOTO()函数

项目集I对应符号X的后继项目集闭包

##### 规范LR(0)项集族

开始状态是文法所有项目的移入状态

终止状态是圆点在开始符号右侧，对应该产生式的归约状态

LR(0)分析表存在移入-归约冲突以及归约-归约冲突

当不存在冲突时，称为LR(0)文法

#### SLR分析

LR(0)关键问题是没有向前查看符号，可能会导致归约后无法往下进行

利用follow集可以往后查看符号，判断是否可以归约

##### 方法

对于项目集闭包 I ，假设有一些移进项目和一些归约项目。对移进项目看它后面的终止符，对归约项目看它的FOLLOW集合，FOLLOW集和终结符两两不相交。

那么对于下一个符号，它在终结符/FOLLOW集里，就执行对应的操作。加入到相应的分析表中

##### 仍然会有冲突

仅有FOLLOW集不够

#### LR(1)分析法

在SLR分析法中，下一个字符在FOLLOW集中是归约的必要条件，可以排除一些不合理的，但非充分条件，不能确保归约步骤正确

在特定位置，A的后继符集合是FOLLOW集的子集。这说明了SLR法扩大了可选范围

##### LR(1)项目的形式

```
产生式，后继符（也称展望符）
```

也就是往前看符号，1表示后继符的长度为1

##### 等价LR(1)项目

和等价LR(0)类似，也都是对于待约项目而言的（移进项目不会再展开，归约项目没有等价项目），推法一样，当圆点后面为非终结符时，找到对应产生式的移进状态即可，只是每个项目的形式不一样了而已。对于移进状态的展望符b，是FIRST(βa)中的元素。

特殊情况：当β为空串时，b=a，继承后继符，否则为FIRST(βa)，自生后继符

##### 求状态转换图

初始化状态 I_0，根据输入找到下一个状态，然后看该状态是否有可展开的待约项目，构成项目集闭包

注意，某个产生式可能有多个项目（后继符不同），后续的状态可能比初始状态还多。

我草这个有点抽象了，加了后继符之后转换图太多辣

![image-20250609082753217](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250609082753217.png)

#### LR(1)分析表

和LR(0)分析表是一样的，也不需要加入后继符，只是状态更多了，细化了输入信息，能表示的表达式复杂程度更大

![image-20250609083315881](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250609083315881.png)

**同心LR(1)项目**：只有展望符不同的LR(1)项目

##### LR(1)项目集闭包

#### LALR分析法

根据同心状态集合去减少状态数

刚刚搜了下，gcc是手写的自顶向下编译器

LALR项目集只是在LR(1)项目集上做了些合并，将同心的项目放到同一个项目集中，主要是对应项目数量更少的集合，如果项目相同就可以合并到一个较大的项目集

![image-20250609085753027](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250609085753027.png)

黑线换为蓝线部分

如果合并之后的LALR分析表没有冲突，那么就称为LALR文法

似乎所有的文法都是在没有冲突的时候才能叫xxx文法

##### 归约-归约冲突

![image-20250609090013684](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250609090013684.png)

如上图，当目前栈顶为c，下一个符号为d或e时，状态机不明确要归约到哪个非终结符

##### 特点

但不存在移入归约冲突，合并的时候实际上是合并了展望符，操作是一样的。

合并同心项集后，可能会推迟错误的发现

形式上和LR(1)相同

分析能力强于SLR

#### 二义性文法的LR分析

为了取消二义性，会引入更多的非终结符，产生式会更多



用优先级、结合性、就近匹配原则（解决是要移入还是要归约，实质是最长子串）去解决冲突，比如乘法优先级高于除法

#### LR分析中的错误处理

##### 恐慌模式错误恢复

一直回溯到一个非终结符，选择其可能的其它产生式

##### 短语层次错误恢复

预测哪个位置最容易出错，预计的输入应该是什么



根据不同错误去调用不同的错误处理方法，下图e1-4

假设某个归约状态出错，直接归约即可

![image-20250609092616494](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250609092616494.png)

![](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250609093021649.png)

上图在空白处填好了错误处理