NFA要加上ε

一方面是表示无输入时可以到的状态，对应了或



#### NFA和DFA的区别

如果没有ε的转换，并且每个状态s和每个输入符号a有且仅有一条标号为a的离开s的边

对应了DFA的“确定”。

每个NFA都有一个等价的DFA



DFA的关键有一点是字符集的确认，下一个状态无关的字符是字符集中所有的字符而非空



正则表达式可以简洁、精确的描述词法单元的格式



主要掌握：正则到NFA + NFA到DFA



#### NFA到DFA

子集构造法

DFA的状态是NFA的状态子集（ε的存在）

最坏情况下DFA的状态个数会是NFA状态个数的指数多个

> 思想是：**DFA 的每个状态 = NFA 中某个状态子集**。
>
> - 因为 NFA 某一步可以到达**多个状态**，而 DFA 每一步只能去一个状态，那么就把 "能到达的状态集合" 作为 DFA 的一个状态来处理。
>
> 如果 NFA 有 `n` 个状态，那么 NFA 状态集合的所有子集有多少个？
>
> - 子集的个数 = 2n2^n2n 个。
> - 也就是说，**DFA 理论上可能有最多 2^n 个状态**，即 **指数级别**。

##### 基本操作

> 你列出的这些操作：
>
> - `ε-closure(s)`
> - `ε-closure(T)`
> - `move(T, a)`
>
> 正是 **子集构造法（Subset Construction）** 中的**基本操作**，用于 **将 NFA 转换为 DFA**。
>  我来给你详细解释一下**每一个操作是什么意思，怎么用**。
>
> ------
>
> ### 1️⃣ `ε-closure(s)`
>
> **定义**：
>  从 NFA 中某个状态 `s` 出发，只走 **ε-transition（ε 转换）**，能到达的所有状态的集合。
>
> - 也就是说，从 `s` 开始，沿着 ε 边能到达的所有状态。
> - 包括 `s` 本身（即使 s 没有 ε 边，结果里也包含 `s`）。
>
> **作用**：
>  帮助我们确定：如果某一步走完之后要考虑 ε 转移，需要知道当前能到的所有状态。
>
> ------
>
> ### 2️⃣ `ε-closure(T)`
>
> **实际上是一个图搜索过程，DFS**
>
> **T表示一个状态集合**
>
> **这个闭包包括此状态集合，以及遍历状态集合，从某个状态通过ε转换可到达的所有状态**
>
> **定义**：
>  从 **状态集合 T 中的每一个状态** 出发，各自计算它的 `ε-closure`，然后取 **并集**。
>
> - 也就是说，T 里每个状态 `s`，计算 `ε-closure(s)`，然后把所有结果合在一起。
>
> **作用**：
>  如果当前状态是一个**状态集合 T**（在子集构造法中，DFA 的状态对应 NFA 的状态子集），
>  那我们需要知道：**从 T 出发，沿着 ε 边最多能到达哪些状态？**
>  这一步就是 `ε-closure(T)`。
>
> ------
>
> ### 3️⃣ `move(T, a)`
>
> **定义**：
>  从状态集合 T 中的每个状态 `s` 出发，**沿着标号为 `a` 的转换边**，能到达哪些状态？
>  把所有到达的状态集合起来，形成新的集合。
>
> - 形式化表示：
>
>   move(T,a)={q∣∃s∈T,(s→aq)}move(T, a) = \{ q \mid \exists s \in T, (s \xrightarrow{a} q) \}
>
> **作用**：
>  在子集构造法中，模拟 DFA 读入一个字符 `a` 之后要跳到哪里。
>  但是注意：**只沿着 `a` 边走，不走 ε 边**。
>  如果你要考虑 ε 转移，应该先 `move`，再 `ε-closure`。
>
> ------
>
> ### 4️⃣ 整体流程（子集构造法大致步骤）
>
> 1️⃣ 初始状态：
>
> ```plaintext
> DFA 初始状态 = ε-closure(NFA 的初始状态)
> ```
>
> 2️⃣ 主循环（模拟输入符号）：
>
> ```plaintext
> 对 DFA 当前状态 T，和每个输入字符 a：
> 
>     U = move(T, a)
>     U' = ε-closure(U)
> 
>     将 U' 作为 DFA 的新状态之一，建立跳转 T --a--> U'
> ```
>
> 3️⃣ 重复直到没有新状态产生。
>
> ------
>
> ### 5️⃣ 小总结
>
> | 操作名         | 作用                                     |
> | -------------- | ---------------------------------------- |
> | `ε-closure(s)` | 从 s 出发沿 ε 边能到哪些状态             |
> | `ε-closure(T)` | 从 T 中所有状态出发沿 ε 边能到哪些状态   |
> | `move(T, a)`   | 从 T 中所有状态出发，沿 a 边能到哪些状态 |
>
> Dtran[a,b]表示对通过a、b边可以达到的状态的集合，求其闭包，不包括接受状态

![image-20250608120757241](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608120757241.png)

这个DFA状态就用字母而不是数字来表示了，然后接受的输入里只有确定的字符，不包括ε，然后左侧NFA状态是表示从该状态出发通过ε转换的可达状态，DFA状态集合是通过非ε转换可达的状态

写在图上时，还是通过NFA状态集合表示的，看下面这个

![image-20250608122608017](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608122608017.png)

#### 正则到NFA

##### 主要操作

- 处理单个字符，包括ε
- 处理字符串操作，比如连接、或、闭包

具体来说：

1. 处理基本的表达式，注意要从某个状态i开始

   ![image-20250608121339332](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608121339332.png)

2. 处理连接、或

   对于连接，只保留一个进入的ε，连接的字符串中间没有ε

   对于或，在进入或之前要构造两条ε转换，进入或中不同的处理

   ![image-20250608121359991](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608121359991.png)

3. 处理闭包

   对于某个字符串的闭包

   ① 添加一条从该字符串结束到字符串起始的ε转换

   ② 在字符串开始前，添加上一个状态到字符串闭包结束后进入的下一个状态的ε转换

   ③ 添加字符串结束后到下一个状态的ε转换

   ![image-20250608121425543](https://raw.githubusercontent.com/dionysusge/MyPic/refs/heads/img/img/image-20250608121425543.png)

#### 词法分析器

主要得构造一个自动机，步骤如下：

- 先构造各个模式对应的NFA
- 将这些NFA合并成为一个NFA
- 将NFA转为DFA

#### 合并NFA的方法

1. 引入新的开始状态，引入从该开始状态到原来各个开始状态的ε转换
2. 得到的NFA所接受的语言是原来各个NFA语言的并集
3. 不同的接受状态代表不同的模式

处理NFA时，通常采用并行计算状态转换

#### NFA到DFA

① 首先明确，DFA的每个状态都是NFA的状态子集，每个状态都是在NFA中通过确定的边可到达的以及该可到达状态通过ε转换可到达的状态

​	**DFA 状态 S 是否是接受状态？ → 看它对应的 NFA 状态子集 T 里是否包含至少一个 NFA 的接受状态。**

② 如果该状态子集包含了多个NFA的接受状态，将DFA图中，路径上第一个到达的接受状态的模式作为此接受状态的输出

③ DFA图中每一个状态，下一个状态必须是遍历了字符集的，接受每一个字符可以到达的下一个状态。在多个NFA中，接受一个字符可能到很多状态（并行），这些状态集合以及其ε转换可到的状态构成了图中的节点。但是，该状态接受同样的输入后，会跳到不同的DFA状态，它是新的NFA状态集合

#### DFA状态数量的最小化

一个正则语言可以对应多个识别该语言的DFA（不计同构），此时需要最小化，减少匹配的开销

##### 状态的可区分

如果存在一个字符串x，使得状态s1和s2通过该字符串，一个能达到接受状态，一个不能达到接受状态，那么就说明这两个状态是可区分的

如果状态不可区分，就称为等价状态，可以**合并**

##### 最小化步骤

1. 初始（ε步骤）：区分接受状态和非接受状态（DFA中可能有多个接受状态，只要该状态的状态集合包含了NFA中的一个接受状态）
2. 归纳：可以从第一步得到的非等价类出发，如果s和t是可区分的，且s'到s、t'到t有标号为a的边，那么s'和t' 也是可区分的
3. 从划分得到的等价类中选取代表，并重建DFA

数学介绍：

> - 设置初始划分：П = { S − F, F } 
>
> - 迭代，不断划分 
>
>   遍历Π中的元素（实际上是状态集合），比如S-F代表了A、B、C三个状态，任选两个状态比如A、B，如果这两个状态通过任意输入边a（那对于任意两个状态，其实也要遍历所有的字符，检查到达的状态是否还在同一组），到达了Π中的同一组（可以是S-F也可以是F），那么A、B仍在同一组，如果没有到Π中同一组，那么要将S-F再次划分，得到新的Π，再重头开始遍历Π，直到新的Π等于Π，作为Π_final
>
> - 从Π_final中每个元素（状态集合）中选一个状态作代表，作为最小化的DFA中的状态
>
> - 该代表状态s在原DFA中指向状态t，那么从t所在等价类r中，选一个状态即可

新DFA图也可以构造出一个转换表，也是状态最少的转换表

#### 词法分析器状态的最小化

和DFA的主要差别是，有多个模式

不同模式的接受状态一定不等价，在初始划分时将其放到不同等价类即可，剩下的步骤和DFA一样，遍历、划分即可



然后引入了死状态

>  **死状态 Φ 是一个非接受状态，对所有输入自环**，用于：
>
> - 补全 DFA 转换表（让 DFA 对所有输入都有定义）
> - 保证 DFA 完整性（尤其为了构造 DFA 补集）
> - 表示“非法输入已发生，后续无论输入啥都不接受”。