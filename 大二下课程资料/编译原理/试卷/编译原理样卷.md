# 编译原理样卷

## 1. 填空题 (10分)
**题目：** 编译器的阶段如图所示。请给出图中 A、B、C、D、E 的含义。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506071555050.webp)

**答案：**

- A: 语法分析器  
- B: 语法树  
- C: 语义分析器  
- D: 中间表达形式  
- E: 代码生成器  

---

## 2. 简答题 (20分)

### 1) [5分] 正则定义
**题目：** 请写出所有以 `a` 开头和结尾的字符串（由 `a` 和 `b` 组成）的正则定义。

### 2) [5分] 最左推导
**题目：** 考虑以下文法：
```
A → A or B | B  
B → B and C | C  
C → not C | ( A ) | t | f  
```
为字符串 `f or ( not t and f )` 写出最左推导。

### 3) [5分] 属性文法的依赖图
**题目：** 考虑以下属性文法，其中 \(h\) 是 \(S\) 和 \(L\) 的属性：
```
S → (L) {S.h = L.h × 2}  
S → a {S.h = 1}  
L → L(1), S {L.h = L(1).h + S.h}  
L → S {L.h = S.h}  
```
为字符串 `(a, a)` 绘制依赖图。字符串 `(a, a)` 的最终 \(S.h\) 值是多少？

### 4) [5分] 句型的句柄
**题目：** 给定文法 \(G[E]\)：
```
S → 0 S 1 | 0 1  
```
写出右句型 `00S11` 的句柄。

---

## 3. 最小状态 DFA 构造 (20分)
**题目：** 构造正则表达式 \((a* |b* ) *\) 的最小状态 DFA，包括以下步骤：
1. [5分] 将正则表达式转换为 NFA。
2. [8分] 使用子集构造法将 NFA 转换为 DFA，并提供转换表。
3. [7分] 最小化 DFA 的状态。

---

## 4. 三地址代码 (10分)
**题目：** 给出以下 C++ 语言的 for 循环对应的三地址代码：
```cpp
for (i = 0; i < 10; i++)  
    x = x + 1;
```

---

## 5. LL(1) 文法分析 (20分)
**题目：** 考虑以下文法 \(G[S]\)：
```
S → i | ( E )  
E → E + S | E - S | S  
```
1. [5分] 请重写该文法以消除左递归。
2. [10分] 计算 FIRST 和 FOLLOW 集。请解释重写后的文法是否为 LL(1) 文法。
3. [5分] 构造分析表。

---

## 6. LR 分析 (20分)
**题目：** 考虑以下文法 \(G[S]\)：
```
A → A b | b B a  
B → a A c | a | a A b  
```
1. [8分] 构造该文法的 LR(0) 项目 DFA。
2. [6分] 判断该文法是否为 LR(0) 或 SLR(1) 文法，并说明原因。如果是，请构造分析表。
3. [6分] 展示输入字符串 `aabcb` 的分析栈和分析器的动作。
