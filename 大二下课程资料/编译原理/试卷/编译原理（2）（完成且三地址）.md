# 编译原理习题 (2)（完成且三地址完成）

## 1. 编译器阶段问题
**题目：** 编译器对语句 “b = a + i * 2” 的各个阶段如图 1 所示。请给出图 1 中 A、B、C、D、E 的含义。

**答案：**

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506071532792.webp)

- A: Scanner  
- B: [未填写]  
- C: Semantic analyzer  
- D: IR Generation   
- E: Code generator  

**题目：** 字母表 $\Sigma = \{a, b\}$，写出一个正则表达式，生成包含偶数个 $a$ 的所有字符串。

**答案：**  
R.E.: $((ab^*a)|b)^*$

**题目：** 重写以下文法 $G(S)$，消除左递归和左因子。

```
A → bAbB | bABb | aB  
B → BaA | ab | ba  
```

**答案：**
重写后的文法：
```
A → bAA' | aB  
A' → bB | Bb  
B → abB' | baB'  
B' → aAB' | ε  
```

OK

**题目：** 考虑以下布尔表达式文法：

```
E → T + E | T - E | T  
T → 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0  
```
为字符串 “2 + 3 - 4” 写出最右推导。

**答案：**
```
E → T + E → T + T - E → T + T - T  
  → 2 + 3 - 4  
```

OK

**题目：** 给定文法 $G[E]$：

```
E → E + E | T  
T → T * F | F  
F → i | (E)   
```
写出句型 $T * F + i$ 的句柄。

**答案：**  
句柄：$T * F$

OK

---

## 2. 最小状态 DFA 构造
**题目：** 构造正则表达式 $a(b|ab)*$ 的最小状态 DFA，包括以下步骤：
1. 将正则表达式转换为 NFA。
2. 将 NFA 转换为 DFA。
3. 最小化 DFA 的状态。

**答案：**
1. **NFA 转换：** [未提供图示]
2. **NFA 转换为 DFA：**
   | I                     | Ia                  | Ib                    |
   | --------------------- | ------------------- | --------------------- |
   | {1}                   | {2, 3, 4, 5, 9, 12} | -                     |
   | {2, 3, 4, 5, 9, 12}   | {6, 7}              | {4, 5, 9, 10, 11, 12} |
   | {6, 7}                | -                   | {4, 5, 8, 9, 11, 12}  |
   | {4, 5, 9, 10, 11, 12} | {6, 7}              | {4, 5, 9, 10, 11, 12} |
   | {4, 5, 8, 9, 11, 12}  | {6, 7}              | {4, 5, 9, 10, 11, 12} |

3. **最小化 DFA：** [未提供图示]

OK

---

## 3. for 循环的三地址代码
**题目：** for 循环的通常形式为：
```
for i := initial to final do S
```
for 循环的语义可以用以下代码表示：
```
t1 = newtemp(); t2 = newtemp();  
t1 := initial;  
t2 := final;  
if t1 ≤ t2 then  
begin  
   v := t1;  
   S;  
   while v ≠ t2 do  
   begin  
       v := v + 1;  
       S;  
   end  
end  
```
1. 给出 “while E do S” 的属性文法。
2. 给出 for 循环的三地址代码：`for v := 1 to 10 do x := x + 1`。

**答案：**
1. **属性文法：**
   ```
   S' → while E do S  
   S'.begin = newlabel;  
   E.true = newlabel;  
   E.false = S'.next;  
   S.next = S'.begin;  
   S'.code = Label S'.begin || E.code || Label E.true || S.code || goto S'.begin  
   ```
2. **三地址代码：**
   ```
   t1 = 1  
   t2 = 10  
   if t1 ≤ t2 goto L1  
   goto L2  
   L1: v = t1  
       t3 = x + 1  
       x = t3  
       v = v + 1  
       if v ≠ t2 goto L1  
   L2: halt  
   ```

---

## 4. LL(1) 文法分析
**题目：** 考虑以下文法 $G[S]$：
```
S → (L) | aS'  
S' → S | ε  
L → SL'  
L' → SL' | ε  
```
1. 解释该文法是否为 LL(1) 文法。
2. 构造 LL(1) 分析表。

**答案：**
1. **解释：** 
   - Nullable nonterminals: {S', L'}
   - First 和 Follow 集：
     | Productions | First sets | Follow sets |
     | ----------- | ---------- | ----------- |
     | S → (L)     | {(, a}     | {$, (, a}   |
     | S → aS'     | {a}        | {$, (, a}   |
     | L → SL'     | {(, a}     | {)}         |
     | L' → SL'    | {(, a, ε}  | {)}         |
     - 原因：S' → S | ε，且 First(S') ∩ Follow(S') ≠ Φ，因此该文法不是 LL(1) 文法。
2. **LL(1) 分析表：**
   |      | (        | )      | a        | $      |
   | ---- | -------- | ------ | -------- | ------ |
   | S'   | S' → S   | S' → ε | S' → S   | S' → ε |
   | L    | L → SL'  |        | L → SL'  |        |
   | L'   | L' → SL' | L' → ε | L' → SL' |        |

OK

---



## 9. LR(0) 和 SLR(1) 分析

**题目：** 考虑以下文法 $G[A]$：
```
A → aAd | aAb | ε  
```
1. 构造 LR(0) 项目 DFA。
2. 判断该文法是否为 LR(0) 或 SLR(1) 文法，并说明原因。如果是，构造 SLR(1) 分析表。
3. 展示输入字符串 “abd” 的 SLR(1) 分析栈和动作。

**答案：**

1. **LR(0) 项目 DFA：**
   - [未提供图示]
2. **判断：**
   - 在 I0 和 I2 中存在移入-归约冲突。
   - Follow(A) ∩ {a} = {d, b, \$} ∩ {a} = Φ，因此 $G[A]$ 是 SLR(1) 文法。
3. **SLR(1) 分析表：**
   |      | a    | d      | b      | $      | A    |
   | ---- | ---- | ------ | ------ | ------ | ---- |
   | 0    | S2   | r3(r4) | r3(r4) | r3(r4) | 1    |
   | 1    |      |        |        | acc    |      |
   | 2    | S2   | r3     | r3     | r3     | 3    |
   | 3    |      | S4     | S5     |        |      |
   | 4    |      | r1(r2) | r1(r2) | r1(r2) |      |
   | 5    |      | r2(r3) | r2(r3) | r2(r3) |      |

3. **SLR(1) 分析栈和动作：**
   | Stack   | Input | ACTION | GOTO |
   | ------- | ----- | ------ | ---- |
   | $0      | abd$  | Shift  | 2    |
   | $0a2    | bd$   | r3     | 3    |
   | $0aA3   | bd$   | Shift  | 5    |
   | $0aA3b5 | d$    | r2     | 1    |
   | $0A1    | d$    | err    |      |
