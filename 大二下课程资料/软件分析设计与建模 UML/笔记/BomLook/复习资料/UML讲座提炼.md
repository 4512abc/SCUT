
## 一、GRASP设计模式
### 1. Controller（控制器模式）
- **Problem**  
  UI层之外，哪个对象首先接收并协调系统操作？
- **Solution**  
  将责任分配给代表“系统整体”“设备”或“用例场景”的类（如门面控制器、用例控制器）。
- **Benefits**  
  - 明确系统操作的入口，降低UI与领域逻辑的耦合。
  - 便于管理系统流程控制和业务逻辑协调。
  - 增加重用和可插拔接口的可能性
  - 有机会推断用例状态
- **Implementation**  
  - 在MVC架构中，Controller作为模型与视图的中介，处理用户输入并调用模型逻辑。
  - 示例：Java Swing或Struts框架中的控制器实现。
- **Issues and Solutions**  
  - **问题**：控制器可能因职责过多导致“臃肿”（低内聚）。
  - **解决方案**：拆分控制器职责，遵循单一职责原则，避免处理过多领域逻辑。

### 2. Information Expert（信息专家模式）

Information Expert 经常用于责任分配，它是对象设计中不断使用的基本指导原则。

- **Problem**  
  如何分配对象责任以确保其具备完成任务所需的信息？
- **Solution**  
  将责任分配给拥有完成该责任所需信息的类。
- **Benefits**  
  - 提高代码内聚性，确保对象职责与信息匹配。
  - 符合现实世界对象的行为逻辑（如Sale类负责计算总金额，因它包含商品信息）。
- **Implementation**  
  - 在NextGen应用中，Sale类通过包含SalesLineItem获取商品价格，实现总金额计算。
- **Issues and Solutions**  （存疑）
  - **问题**：当信息分散在多个类时，可能需要协作，增加复杂度。
  - **解决方案**：结合其他模式（如Indirection），通过中介对象协调多类信息。

### 3. High Cohesion & Low Coupling（高内聚低耦合）

- **概念补充**
  - 内聚：软件中各个功能模块内部的功能联系
  - 耦合：衡量软件中各个层 / 模块之间的依赖，关联程度

- **Problem**  
  
  - **高内聚**：如何让对象专注于特定功能，便于理解和维护？
  - **低耦合**：如何减少组件间依赖，降低变更影响，提高重用率？
- **Solution**  
  - **高内聚**：分配责任时确保模块功能高度相关，不做过多工作。
  - **低耦合**：分配职责，设计时减少组件间直接依赖，通过接口或中介交互。
- **Benefits**  
  
  - **高内聚**：代码更易理解、测试和维护，减少模块间干扰。
  - **低耦合**：组件可独立修改、复用，系统扩展性强，且易于理解。
  
  一个高内聚的类，方法数量相对较少，功能高度相关，且工作量较低。在任务较多时，该类会与其他对象协作以分担工作量
- **Implementation**  
  - 分层架构（如Controller-Service-Dao）中，各层职责分离（高内聚），通过接口交互（低耦合）。
- **Issues and Solutions**  
  - **问题**：过度追求低耦合可能导致系统复杂度增加（如引入过多中介）。
  - **解决方案**：平衡耦合度，根据场景选择合适的解耦策略（如适配器、门面模式）。

### 4. Indirection（间接模式）
- **Problem**  
  如何避免组件间直接耦合，支持低依赖和高复用？
- **Solution**  
  引入中间对象（中介）协调组件交互，避免直接依赖。
- **Benefits**  
  - 降低组件间耦合，支持独立变更和复用。
  - 符合“计算机科学中的大多数问题都可以通过增加一层间接性来解决”的原则。
- **Implementation**  
  - 适配器模式（Adapter）通过中介对象转换接口，如TypeC到USB的扩展坞。
  - 门面模式（Facade）为子系统提供统一接口，隐藏内部复杂性。
- **Issues and Solutions**  
  - **问题**：过多间接层可能导致系统性能下降或逻辑复杂。
  - **解决方案**：按需引入间接层，优先处理高耦合点。


## 二、GoF设计模式
### 1. Adapter（适配器模式）
- **Problem**  
  如何解决接口不兼容问题，使不同接口的组件协同工作？
- **Solution**  
  通过适配器对象**将原接口转换为目标接口。**
- **Benefits**  
  - **允许不兼容接口的组件协作，提高代码复用性。**
  - **符合低耦合原则，无需修改原组件代码。**
- **Implementation**  
  - 类适配器：继承原类并实现目标接口（Java中因单继承受限，更常用对象适配器）。  
  - 对象适配器：持有原类实例，通过委托实现目标接口，如TypeCAdapter适配USB接口。
- **Issues and Solutions**  （存疑）
  - **问题**：过多适配器可能增加系统复杂度。
  - **解决方案**：优先设计统一接口，减少适配器使用场景。
- 代理模式和适配器模式的区别
  - 适配器模式的主要目的是使接口不兼容的对象能够协同工作。适配器模式允许将一个类的接口转换成另一个类的接 口,使得不同接口的类可以协同工作。
- 总结
  - 低耦合是在变化点实现保护的一种方法。
  - 多态性是一种在变化点实现保护的方法，也是一种实现低耦合的方法。
  - 间接模式是实现低耦合的一种方法。
  - Adapter 设计模式是一种间接和纯制造模式，它使用多态性。


### 2. Singleton（单例模式）
- **Problem**  
  如何确保类仅有一个实例，并提供唯一的全局访问点？
- **Solution**  
  **定义静态方法，返回唯一实例。**
- **Benefits**  （存疑）
  - **控制资源访问（如数据库连接、配置管理器），避免重复创建。**
  - 全局状态统一管理，如购物车管理器仅需一个实例。
- **Implementation**（存疑）  
  - **饿汉模式**：静态初始化实例（线程安全），如ShoppingCartManager。
  - **懒汉模式**：延迟初始化（需考虑线程安全）。
- **Issues and Solutions**（存疑）  
  - **问题**：单例可能导致代码耦合度高，不利于测试和扩展。
  - **解决方案**：通过接口封装单例，或使用依赖注入替代全局访问。

### 3. Factory（工厂模式）
- **Problem**  
  如何封装对象创建逻辑，**分离创建与使用，提高灵活性**？
- **Solution**  
  **创建工厂类负责对象创建，客户端通过工厂获取实例。**
- **Benefits**  
  - **隐藏复杂创建逻**辑，如对象初始化、依赖注入。
  - **将复杂的创建逻辑分离出来，由高内聚的程序对象进行负责**。
  - **支持多态创建，便于扩展新对象类型**（如不同形状的积木工厂）。
- **Implementation**  
  - **简单工厂**：一个工厂创建多种对象（如ShapeFactory创建Circle/Square）。
  - **工厂方法**：抽象工厂定义接口，子类实现具体创建逻辑。
- **Issues and Solutions**  
  - **问题**：过多工厂类可能导致代码膨胀。
  - **解决方案**：结合抽象工厂模式，分组管理相关对象的创建。

### 4. Strategy（策略模式）
- **Problem**  
  如何**设计可变的算法或策略，支持运行时切换**？
- **Solution**  
  **将算法封装为独立策略类，实现共同接口，由上下文类动态选择**。
- **Benefits**  （存疑）
  - 算法与客户端解耦，**支持独立扩展**（如超市打折策略新增满减规则）。
  - **符合开闭原则，新增策略无需修改原有代码。**
- **Implementation**  
  - 定义DiscountStrategy接口，实现九折（DiscountStrategy1）和满减（DiscountStrategy2）策略。
- **Issues and Solutions**  
  - **问题**：策略类过多时，客户端选择策略可能复杂。
  - **解决方案**：结合工厂模式，由工厂根据条件选择策略。

### 5. Composite（组合模式）
- **Problem**  
  如何**处理组合对象，将像处理原子对象（即非组合对象）一样**？
  
- **Solution**  
  **为组合对象和原子对象定义类，实现统一接口。**
  
  可以做一个类比：原子对象是一棵树的叶子，是组合对象的组成成分，而根对象就是合成节点，可以包含其他原子对象（即叶子），从而形成一个统一整体。
  
  - Component 组件：组合模式的"根节点"，定义组合中所有对象的通用接口,可以是抽象类或接口。该类中定义了子类的共性内容
  - Leaf 叶子：实现了Component接口的叶子节点，表示组合中的叶子对象，叶子节点没有子节点。 
  - Composite 合成：作用是存储子部件，并且在Composite中实现了对子部件的相关操作，比如添加、删除、 获取子组件等。
  
- **Benefits**  
  
  - 客户端无需区分叶子与合成对象，简化操作（如遍历公司组织架构）。
  - 灵活扩展树形结构，新增节点不影响现有逻辑。
  
- **Implementation**  （存疑）
  
  - 抽象组件（如OrganizationComponent）定义通用接口，部门（Composite）可包含子部门/员工（Leaf）。
  
- **Issues and Solutions**  （存疑）
  
  - **问题**：大型树形结构可能导致性能问题（如递归遍历）。
  - **解决方案**：优化遍历算法，或引入缓存机制。

### 6. Observer（观察者模式）
- **Problem**  
  **如何让多个订阅者对象响应发布者的状态变化，同时保持低耦合？**
- **Solution**  
  **发布者维护订阅者列表，状态变化时通知所有订阅者。具体通过定义一个 “subscriber”o“Listener 接口（订阅者实现此接口）**，发布者可以动态注册对事件感兴趣的订阅者，并在事件发生时通知他们。
- **Benefits**  （存疑）
  - **发布者与订阅者解耦，支持动态添加/删除订阅者**。
  - 实现事件驱动模型，如消息推送、状态监听。
- **Implementation**（存疑）  
  - 定义Subject接口（register/remove/notify）和Observer接口（update），具体主题（ConcreteSubject）通知观察者。
- **Issues and Solutions**  （存疑）
  - **问题**：订阅者过多可能导致通知性能下降。
  - **解决方案**：引入异步通知或分组管理订阅者。

### 7. Facade（门面模式）
- **Problem**  
  如何为**复杂子系统提供统一接口**，简化客户端调用，**同时保持低耦合，降低子系统变化带来的风险**？
- **Solution**  
  **创建门面类，封装子系统Fecade组件，提供单一交互接口，与子系统组件进行协作**。
- **Benefits**  
  - **隐藏子系统复杂性，客户端无需了解内部组件协作**。
  - **降低客户端与子系统的耦合，便于子系统独立维护**。
- **Implementation**  （存疑）
  - 电源总开关（Facade）封装空调、台灯、电视的关闭操作，输入4时关闭所有设备。
- **Issues and Solutions**  （存疑）
  - **问题**：门面可能成为“万能接口”，违背高内聚原则。
  - **解决方案**：按功能拆分门面，避免单一门面承担过多职责。

### 8. Proxy（代理模式）
- **Problem**  
  **如何控制对真实对象的访问**，或在访问时添加额外逻辑？
- **Solution**  
  代理对象与真实对象实现相同接口，客户端通过代理间接访问真实对象。
- **Benefits**  
  - 支持访问控制（如权限验证、延迟加载），如房屋中介过滤面积不足的房源。
  - **客户端与真实对象解耦，便于扩展功能（如日志记录、缓存）**。
- **Implementation**  
  - 房屋代理（HomeAgentProxy）检查房屋面积，仅向客户展示面积>100㎡的房源。
- **Issues and Solutions**  
  - **问题**：代理链过长可能导致调用链复杂。
  - **解决方案**：明确代理职责，避免多层代理嵌套。

### 9. State（状态模式）
- **Problem**  
  如何**让对象在不同状态下表现不同行为，避免修改已有代码，同时遵守开闭原则**？
  
- **Solution**  
  **将状态行为封装为独立状态类，上下文对象根据状态切换行为**。
  
  一般包含如下几个角色：
  
  - state(状态)：定义一个接口，用于封装与Context的一个特定状态相关的行为。 
  - concretestate(具体状态)：负责处理Context在状态改变时的行为，每一个具体状态子类实现一个与Context的一个状态相关的行为。
  - Context(上下文)：维护一个具体状态子类的实例，这个实例定义当前的状态。

- **Benefits**  
  - **符合开闭原则，新增状态无需修改上下文代码。**
  - **状态逻辑分离，代码更易维护**（如台灯的开/关/闪烁状态）。
- **Implementation**  
  
  - 定义State接口（handle），实现OnState/OffState/BlinkState，Light上下文根据命令切换状态。
- **Issues and Solutions**  
  - **问题**：状态类过多可能导致系统复杂度增加。
  - **解决方案**：合并相似状态，或使用状态机框架管理状态转换。







## 三、UML 软件设计分析与建模总结  


### （一）UML 概述与视图分类  
UML（统一建模语言）是用于可视化、规格化、构造和文档化软件系统的标准建模语言，通过多种视图从不同角度描述系统。核心视图包括：  
1. **场景视图（Use-Case View）**：关注系统功能需求与用户交互。  
2. **逻辑视图（Logical View）**：关注系统类、接口及关系的逻辑结构。  
3. **过程视图（Process View）**：关注系统动态行为与交互流程。  
4. **物理视图（Physical View）**：关注系统硬件部署与组件分布。  


### （二）核心视图与建模元素详解  


#### 1. 场景视图（用例图，Use-Case Diagram）  
- **核心概念**：  
  - **参与者（Actor）**：与系统交互的外部实体（如用户、其他系统）。  
  - **场景（Scenario）**：参与者和系统之间的特定作和交互序列。
  - **用例（Use Case）**：描述参与者尝试实现目标的相关成功和失败场景的集合
  - **关系**：  
    - **包含（<<include>>）**：一个用例包含另一个用例的行为（如“登录”包含“验证密码”）。  
    - **扩展（<<extend>>）**：一个用例扩展另一个用例的功能（如“查询”扩展“导出结果”）。  
    - **泛化（Generalization）**：用例的继承关系（如“管理员审批”泛化“审批”）。  
- **示例**：ATM系统中，“取款”“存款”是“交易”用例的泛化，“插入卡片”与“交易”存在包含关系。  

#### 2. 逻辑视图（领域模型Domain Model，类图Class Diagram）  

注意领域模型不是软件构件的模型

- **核心概念**：  
  - **类（Class）**：封装属性与操作，描述系统中的对象类型。  
  - **关系**：  
    - **继承（Generalization）**：子类继承父类属性与方法（如“鸟类”继承“动物类”），是 is-a 关系。
    - **实现（Realization）**：类实现接口定义的方法（如“鸟类”实现“飞行接口”），是 is-a 关系，但特指接口和实现类之间。
    - **关联（Association）**：类之间的结构化关系（如“学生”与“课程”的关联），可以是单向或者双向，不推荐双向。
    - **聚合（Aggregation）**：整体与部分的弱关联（如“班级”与“学生”，学生可独立存在），部分可以脱离于整体而存在。
    - **组合（Composition）**：整体与部分的强关联（如“房间”与“墙壁”，墙壁不可独立存在），部分不能独立于整体而存在。
    - **依赖（Dependency）**：一个类使用另一个类的定义（如“医生”依赖“医疗设备”），通常是短暂的。
- **示例**：订单系统中，“订单类”与“商品类”是聚合关系，“商品类”与“规格类”是组合关系。  


#### 3. 过程视图（交互图与状态图）  
- **状态图（State Diagram）**：  
  - 描述对象在不同状态下的行为及状态转换，一般用于依赖于状态的类  
  - **元素**
    - 状态（State）：对象在某个时刻的状态
    - 事件（Event）：是重大或者值得注意的事项
    - 转换（Transition）：两种状态之间的关系，当事件发生时，对象会从当前状态转移到下一个状态
    - 初始状态、终止状态。  
  - **示例**：“销售订单”状态转换：创建→付款中→已付款→已发货→已完成。  

交互图包括了顺序图和通信图。

- **顺序图（Sequence Diagram）**：  
  - 按时间顺序展示对象间的消息交互，强调时间序列。  
  - **元素**：对象生命线（Lifeline）、消息（Message）、控制焦点（Activation）。  
  - **示例**：用户登录顺序图：用户→界面层→控制器→服务层→数据库的消息传递。  
- **通信图（Communication Diagram）**：  
  - 以对象为中心展示交互，强调对象间的连接关系。  
  - **与顺序图的区别**：顺序图侧重时间轴，通信图侧重对象关联。  
- **活动图（Activity Diagram）**：  
  - **描述系统流程或操作的执行步骤，支持并行分支与条件判断**。  
  - **元素**：活动（Activity）、分支（Branch）、合并（Merge）、分叉（Fork）、汇合（Join）。  


#### 4. 物理视图（部署图，Deployment Diagram）  
- **部署图**：一种结构图，描述运行时处理节点的物理配置以及部署在节点上的软件。
- **元素**：  
  - **节点（Node）**：运行时存在的物理元素，表示计算资源，如：硬件设备（如服务器、客户端）或软件环境（如虚拟机）。
    - 处理器节点：可以执行软件的硬件设备：物理服务器、计算机或虚拟机，通常运行软件应用程序或服务。  
    - 设备节点：表示由处理器节点控制的物理设备，可以是外围设备，如打印机、扫描仪或传感器，与处理器节点相连并受其控制。
  - **组件（Component）**：部署在节点上的软件模块（如Web服务、数据库）。  
  - **依赖关系**：节点间的通信链路（如网络连接）。  
- **示例**：电商系统部署图：Web服务器、数据库服务器、客户端节点的分布与连接。  
