# UML

## ”面向对象“思想基本概念

**class**：是一组有共同属性、操作、方法、关系或者行为的一组的对象的描述

**object**：是类的实体化，根据一个类而创造的实例



类定义了对象群体的逻辑结构，包括了属性和操作，所有相关对象之间相互协作，共同实现了软件功能。软件系统由多个对象组成。



## 面向对象

面向对象思考方式：在对世界/系统进行建模/观察的时候，将其看作是一些了相互交流、相互影响的对象集合。

- 面向对象：解决不确定/创新性问题
- 面向过程：处理已知事实

**面向对象核心特性**：

- 对象/类
- 方法/信息
- 封装
- 继承
- 接口/实现
- 多态
- 抽象
- 聚合/组合



### 封装

隐藏了对象的实现细节，内部状态不能被其他对象直接访问，其数据只能通过接口进行访问。可以封装类的属性、方法。

权限包含了：public，protected，private，package

**原则**：公开需要公开的细节，其他都需要隐藏。



### 继承

一个对象继承另外一个对象的属性和操作等。



### 多态

同一个类的接收者（不同对象）可以按照自己的方式接收和处理信息（针对同一个操作）。当一个类从另外一个类继承过来时，通过使用多态可以实现子类替代父类。而消息发送方不需要直到消息接收方属于哪一个子类。



### 聚合 / 组合

一个对象是另一个对象的一部分，即 has 关系。

**聚合**：表示一个对象包含一系列其他对象（不对称关系）

**组合**：聚合的变种，强调整体控制局部的生命，部分对象只存在于整体对象中，整体对象控制部分对象的生命周期



### 接口/实现

**接口**：描述一个类的用户如何于整个类交互

**实现**：完成接口所定义的功能，如类、构件等需要完成的任务

**原则**：软件系统由大量相关的类构成，修改某一个类时，不能影响其他类



### 抽象

表示一个对象与其他对象相区别的基本特征。由此提供了同观察者角度相关的清晰定义的概念界限。过滤掉对象的一部分特征和属性，只留下需要的特征和属性。



## UML 统一建模语言

**建模**：将不太理解的东西与类似之物做比较，类推，从而形成更深刻的理解。

**目的**：

- 可视化系统
- 允许详细说明系统的结构和行为
- 给出一个模板，用于构建系统
- 对决策文档化（？）

**UML**：包含了三部分：事物、关系、图

**事物**：包含了结构事物、行为事物、分组事物、注释事物

**关系**：包含了依赖（------>）关联（——），泛化（——|>），实现（------|>）



## 用例

### 用例模型

包含了参与者 Actor：用于系统之外并与系统进行交互的一类事物（示例：手机软件系统的 Actor：用户、网络、SIM卡）

### 用例 usecase

系统为响应 Actor 引发的一个事件而执行的一系列的处理/动作（包含了异常情况处理）

**用例名词**：一个简短的动名词（？）

**用例与用例之间的关系**（？）

- include：完成功能必须包含的
- extend（泛化关系）：条件满足则进行的



**用例描述**



**用例模型**

- 系统边界、参与者、用例、用例图、用例描述（操作契约）



### 活动图

用例模型与活动图相互补充，活动图描述了顺序的/并行的活动之间的关系，分成了多个泳道（？泳道是什么），表示各个部分的事情（？）



### 类图

把类相关的元素画在一起，即为类图。

**类的命名**：第一个词大写，操作除了第一个词之外都大写，属性也是除了第一个词之外都大写



### 顺序图

对对象的动态行为进行建模，有多个对象的参与协作。

顺序图包含了对象/角色，参与者，消息



### 交互图

**交互**：对象之间为实现某一个功能，而必须实施的协作过程、动态行为。

**消息**：对象之间的协作与交流表现为一个对象以某种方式启动另外一个对象的活动，而这种活动称为消息。

- **同步消息**：有发出，有回复（提问），无回复不进行
- **异步消息**：有发出，但继续进行不等待回复（发邮件）

交互图包含了通信图，顺序图



### 通信图

顺序图强调随时间推移，对象如何交互。而通信图展示对象之间的结构关系。

两者是等价的，通信图展示链接关系，顺序图有生命对象线，控制焦点（？）



### 状态图

**状态**：是对象生命周期的一个条件或状况，在此期间对象可以响应事件，并执行某种活动。

- 包含了名称，进入/退出动作，内部迁移，子状态，延迟事件。

**状态机**：说明对象在它的生命周期中响应事件所经历的状态序列，以及它们对每个事件的响应，是一种行为（对单个对象的行为进行建模）

**状态图**：可视化状态机

**事件**：对一个在时空上占有一定位置的有意义的事情们的描述。



### Step

1. 选定对象及祝点。
2. 定义对象在其生命周期内可能存在的状态。
3. 在每种状态下，可以接受的事件以及讲台转移到的新的状态。



## 面向对象分析

**软件系统的基本要求**：内聚性、可重用性、可维护性、可扩展性、灵活性



### GRASP 原则（通用职责分配软件模式）

**分析**：调查研究问题及其本质

**设计**：给出一个概念性的解决方案

**实现**：从代码来表达设计方案

**部署**：将代码模板部署到用户服务器上

**面向对象分析**：发现并描述问题领域里的对象或者概念

**面向对象设计**：定义软件对象以及它们如何协作完成功能（类）



**LRG 低表示差异**



**面向对象分析三种方法（表示概念类）**

1. 名词法
2. 分析模型
3. CRC 法：类/职责/协作



**面向对象分析布置**

- 识别对象
- 组织对象
- 定义对象之间的关系
- 定义对象的操作（设计阶段）
- 定义对象内部细节



### 名词法

**定义**：重用/修改已有模型，借助行业、公司的”概念类划表”，在需求分析中寻求名词。

名词法在文本描述中提取名词作为概念类或者属性（即分析名词）：

定义概念类——画出概念——添加关系——添加属性



### 分析模型法（Jacobson）

行为——信息——展示（三个特性分析）



### RDD 职责驱动设计

设计时考虑对象做什么，或者知道什么。

职责是一个对象的行为，被其他对象所依赖，分为认知职责（Knowing）和行为职责（Doing）

标识类和对象在初步时，即需要考虑职责。



### CRC 方法

C：类

R：职责

C：协作

**特点**：

1. 非正式的，不是很细节
2. 采取小组“头脑风暴”的形式提出概念
3. CRC 的目标不是提供完整的设计
4. CRC 产生的结果需要进一步精化



Step1：需求描述

Step2：建议的概念类（头脑风暴得到）

Step3：标识核心概念类

Step4：明确系统范围

Step5：去掉不必要的类

Step6：产生新的核心类（作为补充）

Step7：为核心类分配职责

Step8：分配协作



相应地，需要（？）：

1. 建立团队
2. 找出所有概念
3. 筛选
4. 建立 CRC 卡
5. 角色扮演



## 构建领域模型

领域模型：问题领域的概念的标识，即没有定义操作的类图

**创建领域模型**

1. 找概念类
2. 分配关系
3. 定义属性（不含有职责）



**概念类**

包含了三个层面：表象、内涵、外延



**指导**

1. 善用草图
2. 报告性或者总结性的对象，需要确认是否定义为概念
3. 构建领域模型、类似地图制作（参考现有名词，排除无需做的相关概念）
4. 不是现实中的数字/文本，可能就是概念类。
5. 由很多元素构成/有一些操作、行为/有数量单位，可能就是类
6. 对一些描述性质的概念进行建模



## 系统顺序图 SSD

将系统看作黑盒子，研究参与者与系统边界的交互

System event：系统顺序图上的事件（调用/消息）

System operation：对系统事件进行处理后返回

顺序图（SD）表示的是系统内部的对象的交互



## 需求获取（其他方面）

初期阶段：部分的词汇表、数据字典、前景描述

精化阶段：业务规则

构建阶段：微小的修改



需求可以划分为**功能性需求**和**非功能性需求**



**FURPS+**

包含了功能性，可使用性、可靠性、性能、可支持性（适配性）



**前景（vision）**

对于主要的功能，约束的简短总结，包含了：问题陈述、受众及其关注方向、参与者与目标、产品概览



## 用例模型

1. 参与者：主要参与者、协助性参与者、幕后参与者

2. 用例：系统为响应 Actor 引发的一个事件而执行的一系列的处理/动作（包含了异常情况处理），这些动作对参与者产生了一个有价值的结果

3. 系统边界：标识“合适的”用例

   **方法**：Boss  test，EBP（业务基本流程测验），规模测试

4. 用例描述：关注参与者的目标，而不是实现界面的细节

   1. 洞察参与者的目标
   2. 描述事物的本质，与用户界面无关
   3. 风格具体化（不能在设计早期实现）
   4. 简洁描述
   5. 从参与者及其目标的角度进行描述



## 契约式设计

### 契约

客户端：需要另外一方提供服务

服务器/服务端：为其他方提供服务

契约承载了相互间的义务和利益

断言定义了契约，其为逻辑表达式，不影响正常执行，可以被评估/忽略。

每个功能定义一个前置条件、一个后置条件。

规格说明必须精确，否则无法判断程序正确于否。




$$
\{P\} A \{Q\}
$$
其中 $P$ 为前置条件， $Q$ 为后置条件。如果满足 $P$ 执行 $A$，则结果需要满足 $Q$

**类不变量**：全局的特性，所有的操作都应该遵守类定义的一个断言。



### 操作契约

用例模型的一部分，是一种更细节的描述用例的方式。

**格式**

- 操作名称与参数
- 操作所属的用例
- 前置条件
- 操作完成的状态

后置条件描述了领域对象状态的变化。操作契约帮助我们更加完善了领域模型



### 设计

设计的输入为系统操作/操作契约



### 架构

关于如何组织软件系统的一系列重大决策。需要大规模组织类。以便形成模块、分层、子系统、命名空间等（不同于部署架构）



### 设计方法——分层法

**层**：粗颗粒度地组织结构元素，需要考虑内聚性，完成特定功能

**子系统**：约等于层

**模块**：比层更小一级的概念

**接口**：部分与部分之间的交流借助的结构

**优点**：

- 各层都容易被替换
- 较低层次包含了更大的操作细节，容易成为可重用的构件
- 每层都可以分布部署和连接

**需要考虑的问题**：

- 服务方高层还是低层次
- 服务是为应用专门设计的，还是通用的



## 面向对象设计

领域层与 UI 层、数据层通过特定接口进行通信

领域对象与设计对象的一致性需要考虑（设计活动从领域模型开始）



**RDD 职责驱动**

标识职责，并把它们分配给不同的类，分为行为职责、认知职责。

软件对象只有方法，没有职责。



### GRASP 原则

#### 原则一：创建者 Creator（由谁来负责创建某个类的新对象）

当下述的某一条成立时，$B$ 有职责去创建 $A$

1. B 包含了 A
2. B 记录了 A
3. B 与 A 关系密切
4. B 拥有 A 在实例化过程中所需要的数据

**不需要使用的情况（When not to use）**：创建进程池，创建一大批对象，委托责任/复杂情况

**优点**：

- 所创建的对象可视化，方便
- 高内聚
- 低耦合



#### 原则二：信息专家 Information Expert（给一个对象分配职责时，一般性原则是什么）

把职责分配给某一个类，该类拥有完成职责的所有信息（即，根据所拥有的信息分配职责）

**步骤**：

1. 清晰地描述职责
2. 在设计模式中寻找能够完成职责的类
3. 或者在领域模型中寻找、以及创建新的类

**优点**：

- 封装性（对象充分利用自身的信息）
- 低耦合
- 系统行为可以分布到不同的类（支持高内聚）



#### 原则三：低耦合 Low Coupling（如何保证设计方案支持低的内聚性、低的变化影响度、增加可重用性）

**耦合 Coupling**：两个子模块之间练习的强度

**内聚 cohesion**：模块内的操作之间联系紧密的程度

注意上述两者之间的区别。

**耦合**：一个元素和其他元素的连接，感知以及依赖程度的度量。

**高耦合的缺点**：

- 部分影响全局
- 难重利用
- 元素孤立，无法理解

**方式**：尽量保持低耦合地分配职责（可用于评价方案，优先低耦合）

**示例**：X 与 Y 存在耦合

- X 有一个属性是 Y
- X 调用了 Y 的方法
- X 有方法引用了 Y
- X 是 Y 的子类或者间接子类
- Y 是接口， X 实现了 Y

**优点**：低耦合支持类设计相对独立，减少变化带来的相互影响。

**注意**：低耦合原则与其他原则需要综合考虑，不可单独考虑低耦合，子类与父类耦合非常紧密。适度的耦合是正确且必须的，建立高耦合，对于稳定元素是可行且有优势的。



#### 原则四：控制器 Controller（由谁负责接受并协调 UI 的操作）

将接受系统的操作的职责给划分：

1. 代表系统 / 子系统 / 设备
2. 只负责解决当前用例



**controller**：系统内部处理来自 UI 层的系统操作的首个对象

分配职责给：

- 外观控制器（Facade）：代表了整个系统，一个根对象或一个软件运行所在的设备
- 用例控制器、会话控制器（session controller）（每一组用例一个控制器）：处理系统事件的类

如果是交给一个控制器，则为外观控制器（用例少，不分组），用例多则进行分组，交给多个会话控制器。

外部事件首先一定经过 controller



**优点**：

1. 容易适应 UI 层的变化
2. 领域层代码容易重利用
3. 有助于保证应用所需要的操作顺序
4. 可以对系统状态进行推理

**问题**：控制器过于臃肿（处理了太多事件）

**解决方式**：

1. 增加控制器
2. 采用会话控制替代外观控制器
3. 控制器委托任务分给其他的对象
4. 高内聚理念



**外观控制器应用场合**

1. 相对较小的系统
2. 有限数量的系统操作
3. 在消息处理系统中，不能转发消息到可选控制器时



**会话控制器应用场合**

1. 当采用外观控制器会导致高耦合、低内聚时
2. 很多系统事件跨越多个不同的处理过程
3. 概念上容易理解和构建



#### 原则五：高内聚 High cohesion（如何保证对象专注、可理解、可管理、同时支持低耦合）

**方法**：分配职责时保证高内聚（可用于评价方案、优先高内聚）

**内聚的特性**：

1. 一个对象完成的功能不太多
2. 这些功能都是同一类别的

**低内聚表现**：

1. 做了许多相互无关（彼此之间没有联系）的工作
2. 做了太多的工作

**原因**：大粒度抽象，做了太多本应该委托给其他类的工作

**缺陷**：

1. 难以理解
2. 难以重复利用
3. 难以维护
4. 没有稳定时刻，总是在修改

**高内聚优点**：

1. 易于理解
2. 易于维护
3. 易于重复利用





#### 原则六：多态 polymorphism（如何处理依据类型不同，而由不同行为的一类需求）（？）

**方法**：使用多态操作，作为依据类型发生变化时的行为，进行了职责的划分。

**推论**：

1. 不要去测试对象的类型或者条件逻辑，并以此选择相应的行为（即不要使用条件逻辑 if  / switch，而是为不同的类定义相同名字的方法）
2. 不同的类实现了相同的接口，或者有一个共同的父类（继承）

**优点**：重要部分的代码不必修改



#### 原则七：纯虚构 Pure fabrication（假如依据信息专家原则获得的解决方案不合适，既不想违反低耦合、高内聚、也不想违反其他原则，如何把职责分配给对象）

**方法**：把高内聚原则分配给一个虚构出来的类（这个类在领域模型中没有对应的概念）

**原则**：

1. 进行纯虚构产生的，要符合高内聚、低耦合，并且可以重复利用
2. 多数情况下按照功能类别定义新的类，是一种“以功能为中心”的对象
3. 功能相关性高，符合高内聚

**缺陷**：用太多就体现不出面向对象原则



#### 原则八：间接 Indirection（如何解决两个对象或者多个对象之间的耦合，使解耦对象保持高重用性）

**方法**：把职责分配给一个中介对象，隔离对象与其他构件或者其他服务，从而使得它们不直接产生耦合



#### 原则九：隔离变化 Protected Variations（如何以系统局部变化以应对变化，从而不对其他部分造成影响）

**方法**：标识出能够预计的变化或者不稳定点，在职责分配的时候创建一个稳定的接口，把它们与系统的其余部分隔离开来

隔离变化时一个高度抽象的原则，用于指导设计，编程的机制。

两种变化点：

- 已存在的变化
- 推测的以后发生的变化



#### 原则十：开—闭原则 ocp

软件系统应当允许功能扩展（开放性），但不允许修改原有的代码（关闭性）

**启发**：

1. 定义所有的对象——数据为私有的
2. 不要使用全局变量

与隔离变化是相似的，尽可能保持大部分稳定



#### 原则十一：能用组合的地方，不要使用继承

代码重用方式：继承、组合

**继承**：获得父类的全部功能，可以进行调整

**缺陷**：

1. 打破了封装性，导致了父类高度耦合，代码在静态 / 编译时绑定的
2. 客户需要买下整个软件包
3. 父类定义了许多硬性规定

**组合特点**：

- 没有打破封装性，耦合低
- 动态 / 运行时绑定
- 整体与部分之间由接口关联，耦合度较低
- 各部分职责明确
- 容易测试



#### 原则十二：依赖倒置原则（Dependency Inversion Principle）

1. 高层模块不应该依赖于底层模块，两者都依赖抽象
2. 抽象不能依赖细节，细节应依赖抽象

**启发**：

1. 面向接口设计，而不是面向实现设计（接口即为抽象层）

   **原因**：

   1. 抽象类 / 接口修改概率低
   2. 易于扩展 / 修改，抽象概念容纳范围广
   3. 不应当修改代表抽象的类 / 接口，符合 OCP 原则

   **例外**：类非常成熟

2. 避免依赖传递性（中间添加抽象层接口），与间接原则类似



### GoF 模式

**设计模式特点**:

- 描述了一个反复出现的问题
- 描述了一个核心方案
- 其他人可以无数次使用这个方案解决类似问题

模式由四个本质构成：

1. 模式名
2. 解决问题
3. 提出的解决方案（抽象）
4. 应用模式后果，折衷考虑的问题

**作用**：

1. 解决某些特殊设计问题
2. 减少重复设计的工作量
3. 把专家的知识、经验传递给新手
4. 为设计提供共同的词汇
5. 编写开发文档更加容易
6. 应用设计模式可以易于重构系统



### 设计模式

#### 单实例模式

**类的多重性**：类多重性指标在类的右上角，缺少指标则说明无限制。

确保类不被实例化：类包含显式构造函数（无法子类化）

Step1：拥有公有函数，以获取唯一的实例

Step2：私有的构造函数

Step3：私有的静态成负变量

**要点**：只能有一个实例，这个实例能够方便地被所有用户访问

**解决方法**：同上述的 3 个 Step，客户对象只能通过 getter 函数获取该单实例



#### 适配器模式（Adapter）

**定义**：将一个类的接口转换为客户希望的另外一个接口

使原本由于接口不兼容而不能一起工作的那些类可以一起工作，在两个接口中间通过适配器连接，不需要直接修改双方代码。

**实现模式**：Adapter，Client（两个角色）

**标识客户需要的接口**：adapter 里必须要有一个 adaptee 对象（或 wrapper 类），adapter 负责映射两者接口



#### 外观模式（Facade）

**背景**：现有系统的接口比较复杂，希望利用原有功能重新定义新的接口。

**问题**：只希望使用现有系统部分功能，以一种特殊方式与现有系统交互。

**与适配器区别**：

- **适配器**：将系统中的接口进行映射，进一步封装（一对一）
- **外观模式**：提供一套新的接口，一个新接口可能包含多个老接口的功能以及一些新代码（一对多）。大多数情况下外观都是单实例的。

**作用**：呈现一套简单的接口，易于使用。用户可能不能使用部分功能（因为在新接口中没有定义）

GRASP 中的外观控制器，就是外观模式

**优点**：

- 简化复杂系统的使用
- 在使用复杂系统的某个功能时，可以加入新功能
- 为客户软件层提供一个接口，隐藏现有细节
- 使客户与系统之间减少耦合，增加独立性、可移植性。节约成本（减少对系统的研究）



####  观察值模式（observer）

**定义**：对象之间一对多的依赖关系，一个对象改变状态，所有依赖的对象都获得通知。该模式又称为 发布——订阅模式、模型——视图模式、源——监听者模式，类似于隔离变化。

Observer Pattern = publishers + Subscribers（对主题数据感兴趣（？））



#### 消息发送

**推模式**是当通知消息来时，把所有相关信息都通过参数的形式 “推给” 观察者。

**优点**：

1. 所有消息都是通过参数传递过来的，直接简单。观察者可以马上进行处理
2. 观察者与被观察者没有一点联系，几乎没有耦合

**缺点**：

1. 观察者无法对信息进行拒绝
2. 如果想添加参数，就要修改所有观察者接口和函数

**拉模式**：通知函数不带任何相关的信息，而是要观察者主动去拉取。

**优点**：

1. 可以主动拉取自己感兴趣的信息
2. 要添加一个参数，无需修改观察者

**缺点**：二者要有一定的联系

**应用时考虑问题**：

1. 主题对象只与基类有耦合
2. 用户配置观察者的数量和类型
3. Object 首先要知道 Subject，注册到 Subject
4. Subject 要保持注册过的 Observer，状态发生变化时，发通知给观察者
5. Subject 可以通过 推 / 拉 模式与 Observer 交流



#### 策略模式（Strategy system）

将变化抽离出来，成为新的接口，以实现隔离变化。

**解决方法**：增加行为对象（即额外的属性）



#### 简单工厂模式（Factory Design Pattern）

1. 面向抽象，不面向实现
2. 在 new 时，无法对抽象类进行 new（？）
3. 定义新类需要根据不同类型 new 不同对象（即为 factory 类）
4. 由 factory 根据对象的不同类型，去创建一个具体的对象
5. 主类中要有一个 factory 对象，并在初始化时，对其只执行赋值操作

**优点**：factory 可以服务多个客户，客户代码不用关注具体 pizza 类型（？）细节。



#### 工厂模式

在简单工厂模式的基础上，对工厂进行抽象多样化。“工厂方法”把自己封装在一个子类中，负责对象创建、解耦父类相关的客户代码与子类的创建对象代码

**定义**：工厂模式定义了一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。



### 其他

泛化关系：is a kind of  不等价于 继承关系： is a inheritance of

用例图的节点包含了用例、边界、执行者，其中用例之间的关系主要是扩展、包含。 



**里氏替换原则**：子类对象应该可以替换父类对象，并且不影响程序的正确性。

- 基类为鸟类，子类包含了：麻雀和企鹅。基类有一个方法 fly（表示可以飞行），在此情况下，企鹅违反了该原则。导致了代码复用性降低，违反了开闭原则，系统的可维护性降低。



**开闭原则**：软件系统应该允许进行功能扩展，不允许对原有代码进行修改。

- 违反该原则，增加bug的风险，可维护性降低。



**面向对象设计**：定义软件对象以及它们如何协作以实现需求

**面向对象分析**：在问题领域内发现和描述对象（或者概念）













