# 计网笔记五

回顾：

- 应用程序使用传输层提供的数据传输服务
  - 无数据丢失，例如 Web/HTTP
  - 可容忍数据丢失，例如流式存储音频/视频
- 传输层使用网络层提供的分组交付服务
  - 请注意，网络基础设施是不可靠的！
  - 直接使用网络：尽力而为服务，意味着没有保证
  - **在网络之上构建一个可靠的数据通道：保证无数据丢失，时序保证以及其他**

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506042239157.webp)



逻辑通信信道模型：**所有操作都在两端完成，无需网络的帮助**

- 任何两个通信主机都可以通过多个路由器和多种链路类型连接。

- 传输层将**两个主机之间的网络服务扩展为两个运行在终端系统上的进程之间的数据传输服务**。就像运行进程的主机直接通过逻辑信道连接一样。

  > ### 解析：
  > 1. **传输层的作用**：  
  >    传输层（Transport Layer）的核心功能是提供 **端到端（end-to-end）** 的数据传输服务，即在两个主机的 **进程（Process）** 之间建立逻辑通信。**它扩展了网络层（Network Layer）提供的“主机到主机”服务，将其细化为“进程到进程”的服务。**
  >
  > 2. **关键概念**：  
  >    - **主机到主机**：网络层（如IP协议）负责**将数据包从源主机路由到目标主机**，但不关心具体是哪个进程在通信。  
  >    - **进程到进程**：传输层（如TCP/UDP）**通过端口号（Port）标识进程，确保数据传递给正确的应用程序（如Web服务器、电子邮件客户端等）。**  
  >
  > 3. **举例**：  
  >    - 当你在浏览器访问网站时，**传输层（TCP）会将数据从浏览器的进程（如端口号随机分配）传递到服务器的Web服务进程（如端口80）**。**网络层仅负责将数据送到目标主机，而传输层进一步完成“最后一公里”的进程间交付。**
  >
  > ### 为什么正确？  
  > - 原文明确区分了网络层和传输层的分工：**网络层解决主机间的通信，传输层在此基础上通过端口号扩展为进程间通信。**  
  > - 传输层的协议（如TCP/UDP）正是为此设计的，例如UDP的头部包含**源端口和目的端口字段，直接支持进程寻址。**
  >
  > ### 可能的误区：  
  > 有人可能混淆“网络服务”的具体范围，但传输层的核心功能确实是向上层（应用层）提供进程间通信服务，这是计算机网络分层架构（如OSI或TCP/IP模型）的基本定义。

- 逻辑上：应用程序使用传输层提供的逻辑通信功能，将消息发送给彼此，无需担心承载这些消息的物理基础设施的细节。发送方将消息拆分成多个数据块，并为每个数据块添加传输层头部，形成数据段；然后将数据段传递给网络层……（接收方？）

  ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506042247937.webp)





互联网传输服务：

- 关于互联网的网络层：
  - 协议：互联网协议，IP
  - 使用 32 位 IP 地址寻址主机
  - **IP 服务：尽力而为交付服务，不可靠！**
- 传输层基本服务（基础服务）
  - UDP（用户数据报协议），不可靠，无连接服务
  - TCP（传输控制协议），可靠，面向连接服务
- **流量控制（流量控制）：适应接受速率**
- 拥塞控制



复用和分用（当共享时需要复用）

- 多个进程共享两个主机之间的逻辑信道
- **套接字接口，应用程序通过它发送消息块：发送和接收时需要使用套接字进行识别**

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506042316183.webp)



操作系统角度看套接字

- 面向连接的套接字
  - 服务器套接字在**打开后准备好接收携带连接消息的数据段，服务器操作系统会为连接数据段分配新的缓冲区。**
  - 客户端套接字**发送连接段来建立连接，服务器操作系统会新建一个连接套接字，实际上，是新建一个缓冲区用于接收应用消息**
  - 连接建立后，**客户端套接字发送应用消息会被放入连接套接字的缓冲区中。**
- **一个客户端进程可以与同一个服务器套接字建立多个连接！**

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506042325658.webp)



无连接多路复用和分用（UDP 为例子）

- 一个 UDP 套接字完全由一个**包含目标 IP 地址和目标端口号的两元组**来标识，即`{D.IP, D.P}`。（`D.IP`：寻址主机；`D.P`：标识操作系统缓冲区）

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506042341840.webp)



面向连接的多路复用和分用（以 TCP 为例）

- **一个 TDP 套接字完全由一个四元组`{S.IP, D.IP, S.P, D.P}`来标识。用于标识操作系统缓冲区**

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506042341829.webp)

> UDP 和 TCP 的 **多路复用（Multiplexing）** 和 **分解（Demultiplexing）** 机制在核心目标上是相同的（即区分不同进程的数据流），但在具体实现和细节上存在显著差异。以下是两者的关键区别：
>
> ---
>
> ### **1. 多路复用（Multiplexing）的差异**
> #### **TCP：**
> - **基于连接的四元组**：  
>   TCP 的多路复用通过 **四元组**（源IP、源端口、目的IP、目的端口）唯一标识一个连接。  
>   - **同一主机的不同 TCP 连接（如多个浏览器标签访问同一服务器）即使目的IP和端口相同，也会因源端口不同而被区分。**  
>   - 示例：两个浏览器标签访问 `example.com:80`，但客户端使用不同临时端口（如 12345 和 12346），TCP 会视为两个独立连接。
>
> #### **UDP：**
> - **仅基于端口号**：  
>   UDP 的**多路复用仅依赖 二元组（目的IP、目的端口）。**  
>   - **UDP 是无连接的，不维护连接状态，因此同一主机的多个进程发送到相同目的IP和端口的数据会被视为同一数据流**。  
>   - 示例：两个客户端进程发送数据到 `10.1.1.1:53`（DNS服务），**接收方无法区分数据来自同一主机的不同进程**。
>
> ---
>
> ### **2. 分解（Demultiplexing）的差异**
> #### **TCP：**
> - **精确匹配四元组**：  
>   接收方的传输层通过检查数据包的 **四元组**，**将数据定向到对应的 Socket**（每个Socket绑定一个唯一连接）。  
>   - **需要维护连接状态（如TCP的序列号、窗口大小等）。**  
>   - 示例：Web服务器通过不同Socket区分来自不同客户端的连接（即使客户端端口不同）。
>
> #### **UDP：**
> - **仅匹配目的端口**：  
>   接收方仅根据 **目的端口** 将数据包交给对应进程，**不关心源IP或源端口（除非应用层手动处理）。**  
>   - **无连接状态，所有发送到同一端口的数据被视为同一数据流。**  
>   - 示例：DNS服务器接收所有发送到 `UDP 53` 端口的数据包，无法直接区分客户端来源（需应用层解析数据内容）。
>
> ---
>
> ### **3. 关键区别总结**
> | **特性**         | **TCP**                                  | **UDP**                              |
> | ---------------- | ---------------------------------------- | ------------------------------------ |
> | **标识符**       | 四元组（源IP、源端口、目的IP、目的端口） | 二元组（目的IP、目的端口）           |
> | **连接状态**     | 维护连接状态（如序列号、窗口）           | 无连接状态                           |
> | **多路复用粒度** | 细粒度（每个连接独立）                   | 粗粒度（同一目的端口的所有数据混合） |
> | **典型应用场景** | HTTP、FTP、SSH等需可靠传输的服务         | DNS、视频流、广播等无状态或实时应用  |
>
> ---
>
> ### **4. 示例场景**
> #### **TCP 场景（Web服务器）**
> - 客户端A（IP1:12345）和客户端B（IP2:54321）访问服务器（IP3:80）。  
> - 服务器通过四元组创建两个独立Socket，分别处理A和B的请求。
>
> #### **UDP 场景（DNS查询）**
> - 客户端A和B同时向DNS服务器（IP3:53）发送查询。  
> - 服务器接收所有发送到53端口的UDP包，无法直接区分来源（需通过查询ID等应用层字段区分）。
>
> ---
>
> ### **5. 为什么存在这种差异？**
> - **TCP** 是面向连接的协议，**需要精确管理每个连接的状态**，因此必须严格区分四元组。  
> - **UDP** 是无连接的，**设计简单，牺牲了细粒度的多路复用能力以换取低开销和高实时性。**
>
> 如果需要更深入的解释（如Socket API的实现差异），可以进一步探讨！



Web 服务器基本上是处理 HTTP 消息的 TCP 服务器（TCP 上的 HTTP）

作为 TCP 服务器意味着在**面向连接的服务器套接字上监听！**

- 接受**来自客户端套接字的连接**
- **在连接建立过程中，创建一个新的连接套接字/缓冲区！**

单线程 Web 服务器：**使用相同的执行过程处理服务器套接字和连接套接字！**

多线程 Web 服务器：通过**由管理服务器套接字的过程分叉的独立线程来处理连接套接字！**



无连接传输：UDP（一种简单、基础的传输协议，仅对 IP 服务进行少量增强）

- 无连接：**在发送数据段之前，发送和接收传输层实体之间没有握手过程。**

- 没有可靠性？可以构建到应用程序本身中。

  ![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506050028749.webp)

- 使用场景：
  - 对发送什么数据以及何时发送具有更精细的应用层控制。考虑需要最低发送速率的实时应用程序。
  - 无连接建立：比较 DNS 和 Web
  - 无连接状态：支持更多活跃客户端（比 TCP 多）（why？）
  - **小数据包头部开销：UDP：8 字节，TCP：20 字节**

> UDP（User Datagram Protocol）能够支持更多活跃客户端的核心原因在于其**无连接、轻量级、无状态**的设计特性。以下是具体分析：
>
> ---
>
> ### **1. 无连接（Connectionless）**
> - **TCP**：每次通信需通过三次握手建立连接，维护连接状态（如窗口大小、序列号等），每个连接占用内核资源（如文件描述符、缓冲区）。
> - **UDP**：无需建立连接，直接发送数据包。客户端和服务器的交互是“即发即忘”，**不占用长期连接资源**。  
>   **影响**：  
>   - 一台服务器可同时响应数十万UDP客户端请求，而TCP受限于连接表大小（如Linux默认`net.core.somaxconn`）。
>
> ---
>
> ### **2. 无状态（Stateless）**
> - **TCP**：需维护每个连接的完整状态机（如SYN_RECEIVED、ESTABLISHED），消耗内存记录序列号、重传定时器等。  
>   **示例**：  
>   - 每个TCP连接至少占用约4KB内核内存（包括读写缓冲区），10万连接需约400MB内存。  
> - **UDP**：服务端不保存客户端状态，仅处理收到的数据包。  
>   **影响**：  
>   - UDP服务端内存开销极低，仅需处理报文本身（如DNS服务器用UDP可轻松应对百万级查询）。
>
> ---
>
> ### **3. 头部开销小**
> - **TCP头部**：20字节（无选项） + 可选字段，包含序列号、确认号、窗口大小等复杂控制信息。  
> - **UDP头部**：仅8字节（源端口、目标端口、长度、校验和）。  
>   **影响**：  
>   - 更小的头部减少网络带宽消耗，允许在相同物理资源下处理更多客户端请求。
>
> ---
>
> ### **4. 无流量控制与拥塞控制**
> - **TCP**：通过滑动窗口、拥塞避免算法（如慢启动）限制发送速率，确保可靠性。  
>   **问题**：  
>   - 高并发时，TCP的拥塞控制可能导致吞吐量下降（如丢包触发拥塞窗口减半）。  
> - **UDP**：无内置控制机制，应用层可自由决定发送速率（如视频流直接按网络上限发送）。  
>   **影响**：  
>   - UDP适合高吞吐场景（如直播、游戏），但需应用层自行处理丢包（如QUIC协议在UDP上实现可靠性）。
>
> ---
>
> ### **5. 无握手与挥手延迟**
> - **TCP**：三次握手（1.5 RTT）和四次挥手（2 RTT）引入延迟。  
>   **示例**：  
>   - 若RTT=100ms，TCP需额外150ms建立连接，短连接场景（如HTTP）效率低下。  
> - **UDP**：直接发送数据，无握手开销。  
>   **影响**：  
>   - 快速响应适合高频短报文（如DNS查询、NTP时间同步）。
>
> ---
>
> ### **6. 内核处理效率**
> - **TCP**：数据需按序交付，内核需维护接收缓冲区并重组乱序报文。  
> - **UDP**：内核仅校验包完整性后直接交付应用，无重组开销。  
>   **影响**：  
>   - 相同硬件下，UDP的包处理速率更高（如C10M问题中，UDP更易实现高并发）。
>
> ---
>
> ### **典型应用场景对比**
> | **场景**               | **协议选择** | **原因**                     |
> | ---------------------- | ------------ | ---------------------------- |
> | 实时游戏（王者荣耀）   | UDP          | 低延迟，容忍偶尔丢包         |
> | 视频直播（Zoom）       | UDP          | 高吞吐，优先实时性而非可靠性 |
> | 网页浏览（HTTP/HTTPS） | TCP          | 需可靠传输与有序交付         |
> | 物联网传感器数据       | UDP          | 海量设备低功耗通信           |
>
> ---
>
> ### **为什么不是所有应用都用UDP？**
> - **可靠性问题**：UDP不保证数据到达顺序或是否丢包（需应用层解决，如QUIC）。  
> - **安全性问题**：无连接特性易受DDoS攻击（如UDP洪水攻击）。  
> - **防火墙兼容性**：部分网络会阻断UDP流量。
>
> ---
>
> ### **总结**
> UDP支持更多活跃客户端的根本原因是：  
> **“用资源换效率”**——通过舍弃连接管理、可靠性保障等机制，最大化吞吐量和并发能力。适合实时性要求高、可容忍部分数据丢失的场景。





UDP 数据段结构

- 端口号字段：用于（解）复用
- **长度字段指定 UDP 段中的字节数（包括头部和数据）。**
- 错误检测：**校验和 由接收主机用来检查段中是否引入了错误。**
- **只有错误检测，无错误纠正。**

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202506050033136.webp)



UDP 校验和

> UDP 和 TCP 的 **检验和（Checksum）** 用于检测数据在传输过程中是否发生错误（如比特翻转）。它们的计算方式类似，但覆盖的范围略有不同。以下是详细步骤和区别：
>
> ---
>
> ## **1. 检验和的计算方法**
> ### **通用步骤（适用于 UDP 和 TCP）**
> 检验和是一个 **16位（2字节）** 的反码和（One's Complement Sum），计算过程如下：
>
> 1. **构建伪首部（Pseudo-Header）**  
>    在计算检验和时，UDP 和 TCP 都会临时添加一个 **伪首部**（12字节），包含源IP、目的IP、协议类型（UDP=17，TCP=6）和数据长度。  
>    - **伪首部格式**（IPv4）：  
>      ```
>      0                   1                   2                   3  
>      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  
>      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
>      |                      源IP地址（4字节）                         |  
>      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
>      |                     目的IP地址（4字节）                        |  
>      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
>      |  全0  | 协议类型 |         UDP/TCP 数据报长度（2字节）         |  
>      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
>      ```
>      - **协议类型**：UDP=17（0x11），TCP=6（0x06）。  
>      - **UDP/TCP 数据报长度**：头部 + 数据的长度（不含伪首部）。  
>
> 2. **拼接数据（UDP/TCP 首部 + 数据）**  
>    - 将 **伪首部 + UDP/TCP 首部 + 数据** 拼接成一个连续的数据块。  
>    - **检验和字段在计算时暂时置为 0**。  
>
> 3. **按 16 位（2字节）分组求和**  
>    - 将整个数据块按 16 位（2字节）分组，如果数据长度为奇数，则在末尾补 1 字节的 0（填充）。  
>    - 对这些 16 位数据进行 **反码求和（One's Complement Sum）**。  
>
> 4. **取反码得到最终检验和**  
>    
>    - **对求和结果取反码（即按位取反），存入检验和字段。**  
>    
> 5. **接收方验证**  
>    - **接收方重新计算检验和（包括伪首部），如果结果 全为 1（0xFFFF），则数据无错误。**  
>
> ---
>
> ## **2. UDP 检验和 vs TCP 检验和**
> | **特性**           | **UDP**                          | **TCP**                  |
> | ------------------ | -------------------------------- | ------------------------ |
> | **是否强制使用？** | 可选（IPv4可关闭，IPv6强制使用） | 强制使用                 |
> | **覆盖范围**       | 伪首部 + UDP 首部 + 数据         | 伪首部 + TCP 首部 + 数据 |
> | **伪首部协议号**   | 17（0x11）                       | 6（0x06）                |
> | **检验和字段位置** | UDP 首部的第 6-7 字节            | TCP 首部的第 16-17 字节  |
>
> ---
>
> ## **3. 计算示例（UDP 检验和）**
> 假设：
> - **源IP**：`192.168.1.1` → `C0 A8 01 01`  
> - **目的IP**：`192.168.1.2` → `C0 A8 01 02`  
> - **UDP 数据长度**：`0x000A`（10字节，首部8字节 + 数据2字节）  
> - **UDP 首部**（检验和字段=0）：
>   ```
>   源端口：1234（0x04D2）  
>   目的端口：53（0x0035）  
>   长度：10（0x000A）  
>   检验和：0x0000（计算前设为0）  
>   ```
> - **数据**：`0xABCD`  
>
> **计算步骤：**
> 1. **伪首部**：
>    ```
>    C0 A8 01 01  C0 A8 01 02  00 11 00 0A
>    ```
> 2. **UDP 首部 + 数据**：
>    ```
>    04 D2 00 35  00 0A 00 00  AB CD
>    ```
> 3. **按 16 位分组求和**：
>    ```
>    C0A8 + 0101 + C0A8 + 0102 + 0011 + 000A + 04D2 + 0035 + 000A + 0000 + ABCD
>    ```
>    计算（16位反码和）：
>    ```
>    0xC0A8 + 0x0101 = 0xC1A9  
>    0xC1A9 + 0xC0A8 = 0x8251（溢出进位：0x8251 + 0x0001 = 0x8252）  
>    0x8252 + 0x0102 = 0x8354  
>    0x8354 + 0x0011 = 0x8365  
>    0x8365 + 0x000A = 0x836F  
>    0x836F + 0x04D2 = 0x8841  
>    0x8841 + 0x0035 = 0x8876  
>    0x8876 + 0x000A = 0x8880  
>    0x8880 + 0x0000 = 0x8880  
>    0x8880 + 0xABCD = 0x344D（溢出进位：0x344D + 0x0001 = 0x344E）  
>    ```
> 4. **取反码**：
>    - `0x344E` 取反 → `0xCBB1`（最终检验和）  
>
> **UDP 数据报**：
>
> ```
> 04 D2 00 35 00 0A CB B1 AB CD
> ```
> 接收方验证时，重新计算（包括伪首部），所有 16 位相加应得 `0xFFFF`。
>
> ---
>
> ## **4. 关键点**
> - **伪首部的作用**：**确保 IP 地址、端口等关键信息未被篡改。**  
> - **UDP 检验和可选**：IPv4 允许关闭（置0），但 IPv6 强制使用。  
> - **TCP 检验和强制**：TCP 必须校验数据完整性。  
>
> 如果需要更具体的代码实现（如C/Python计算检验和），可以进一步讨论！



为什么 UDP 需要错误检测？端到端原则

- **比特错误：在传输过程中，在缓冲过程中进行检测**
- 许多链路层协议（包括流行的以太网协议）也**提供错误检测，但无法保证源和目标之间的所有链路都提供错误检查。**
- 当一段数据**存储在路由器的内存时，可能会引入比特错误**。