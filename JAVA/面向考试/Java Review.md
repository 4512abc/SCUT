# Java Review
## 目录
- 第 1 章 计算机、程序与 Java 导论
- 第 2 章 基础编程
- 第 3 章 选择语句
- 第 4 章 数学函数、字符与字符串
- 第 5 章 循环
- 第 6 章 方法
- 第 7 章 一维数组
- 第 9 章 对象与类
- 第 10 章 面向对象思维
- 第 11 章 继承与多态（*）
- 第 12 章 异常处理与文本 I/O（*）
- 第 13 章 抽象类与接口（*）
- 第 14 章 Java FX 基础
- 第 15 章 事件驱动编程

### 第 1 章 计算机、程序与 Java 导论
1. Java 具有平台独立性，这意味着你可以编写一次程序并在任何地方运行它。
2. Java 源文件以.java 为扩展名。
3. 每个类都被编译成一个单独的字节码文件，其文件名与类名相同，并以.class 为扩展名。
4. JVM（Java 虚拟机）/ JRE（Java 运行时环境）/ JDK（Java 开发工具包）
5. 要从命令行编译 Java 源代码文件，请使用 `javac` 命令。要从命令行运行 Java 类，请使用 `java` 命令。
7. 每个 Java 程序都是一组类定义。关键字 class 引入类定义。类的内容包含在一个块中。
8. Java 程序必须有一个 main 方法。main 方法是程序执行时开始的入口点。
9. Java 源程序区分大小写（Java source programs are case sensitive）。
10. 有两种类型的 import 语句：特定导入和通配符导入（specific import and wildcard import）。特定导入在 import 语句中指定单个类。通配符导入导入包中的所有类。

### 第 2 章 基础编程
- 使用关键字 final 声明命名常量。按照惯例，常量用大写字母命名。
- 标识符是由字母、数字、下划线（_）和美元符号（$）组成的字符序列。它不能以数字开头，也不能是关键字。
- 字面量（ literal）是布尔、数字、字符或字符串数据的常量值，可赋给变量。
- Java 提供了四种表示不同大小整数的整数类型（byte、short、int、long）。
- Java 提供了两种表示不同精度浮点数的浮点类型（float、double）。注意：浮点数据的算术运算不准确。字符类型（char）表示单个字符。Java 提供执行数值运算的运算符：+（加法）、-（减法）、`*`（乘法）、/（除法）和 %（取余）。Java 还提供简写运算符 +=（加法赋值）、-=（减法赋值）、*=（乘法赋值）、/=（除法赋值）和 %=（取余赋值）。自增运算符（++）和自减运算符（--）将变量的值加 1 或减 1。
- 当计算具有混合类型值的表达式时，Java 会自动将操作数转换为适当的类型。
- 将小范围类型的变量转换为大范围类型的变量称为**加宽类型（widening a type）**。
- 将大范围类型的变量转换为小范围类型的变量称为**缩小类型（narrowing a type）**。
- 可以自动执行扩展类型，无需显式转换。必须**显式地执行缩小类型**的操作。
  - 您可以使用 `(type)exp` 表示法将值从一种类型显式转换为另一种类型。

### 第 3 章 选择语句
1. 布尔变量存储 true 或 false 值。
2. 关系运算符（<、<=、==、!=、>、>=）用于数字和字符，并产生布尔值。
3. 布尔运算符 &&、||、! 和 ^ 操作布尔值和变量。
   - 当计算 p1 && p2 时，Java 首先计算 p1，如果 p1 为 true，则计算 p2；
   - 如果 p1 为 false，则不计算 p2。
   - 当计算 p1 || p2 时，Java 首先计算 p1，如果 p1 为 false，则计算 p2；
   - 如果 p1 为 true，则不计算 p2。
   - 因此，&& 被称为条件或短路（conditional or short-circuit）与运算符，|| 被称为条件或短路或运算符。
4. 选择语句用于具有可选执行路径的编程。有几种类型的选择语句：if 语句、if...else 语句、嵌套 if 语句、switch 语句和条件表达式。
5. switch 语句根据 char、byte、short 或 int 类型的 switch 表达式进行控制决策。
6. 关键字 break 在 switch 语句中是可选的，但通常在每个 case 的末尾使用，以终止 switch 语句的其余部分。如果没有 break 语句，则会执行下一个 case 语句。

### 第 4 章 数学函数、字符与字符串
- 通过使用 Math 类中的方法解决数学问题，包括 `min/max/pow/sqrt/round/random [a + (int)Math.random() * b ]`。
- 字符类型表示字符。Java 字符使用 Unicode，一种 16 位编码方案。
- 字符串是封装在 String 类中的对象。可以使用构造函数或字符串字面量简写初始化器构造字符串。
- String 对象是不可变的；不可变对象中的内容不能更改。为了提高效率和节省内存，JVM 将具有**相同字符序列的两个字面字符串存储在一个唯一的对象**中。这个唯一的对象称为**字符串驻留对象**（`interned string object`）。
- 可以通过调用其 `length()`方法获取字符串的长度，使用 `charAt(index)`方法检索字符串中指定索引处的字符，使用 `concat` 方法连接两个字符串，或使用加号（+）连接两个或更多字符串；使用 `substring` 方法从字符串中获取子字符串；使用 `toLowerCase` 和 `toUpperCase` 方法转换大小写。
- `==`只能检查`string1 string2`是否指向同一个对象，而不会判断内容是否相同，所以不能使用`==`判断两个字符串变量的内容是否相同。
- 使用`equals` 和`compareTo` 方法比较字符串。如果两个字符串相等，则 `equals` 方法返回 `true`；如果不相等，则返回 `false`。
- `CompareTo` 方法返回 0、正整数或负整数，具体取决于字符串中每个字符的 Unicode 值。
- Character 类是单个字符的包装类。 Character 类提供了有用的静态方法来确定字符是字母 (`isLetter(char)`)、数字 (`isDigit(char)`)、大写 (`isUpperCase(char)`) 还是小写 (`isLowerCase(char)`)，以及方法例如 `toLowerCase(char)` 和 `toUpperCase (char)` 。
- 使用 `printf` 语句格式化输出，格式说明符以百分号开头（例如 `%md、%ms、%m.nf`）。
- 您可以从命令行将字符串传递给 main 方法。传递给主程序的字符串存储在 `args` 中，`args` 是一个字符串数组。第一个字符串用`args[0]`表示，`args.length`是传递的字符串数量。

### 第 5 章 循环
1. 有三种类型的重复语句：while 循环、do - while 循环和 for 循环。
   - while 循环和 for 循环称为预测试循环，因为在执行循环体之前检查继续条件。
   - do - while 循环称为后测试循环，因为在执行循环体之后检查条件。
2. 两个关键字 break 和 continue 可用于循环。break 关键字立即结束包含它的最内层循环。continue 关键字仅结束当前迭代。

### 第 6 章 方法
1. 方法头指定方法的修饰符、返回值类型、方法名和参数。
2. return 语句也可用于 void 方法中以终止方法并返回给方法的调用者。这偶尔用于规避方法中的正常控制流。
3. 在 Java 中，有返回值的方法也可以作为语句调用。在这种情况下，调用者只需忽略返回值。
4. 每次调用方法时，系统将参数和局部变量存储在称为栈的空间中。当一个方法调用另一个方法时，调用者的栈空间保持不变，并创建新空间来处理新的方法调用。当一个方法完成其工作并返回给调用者时，其关联的空间被释放。
5. 方法可以重载。这意味着两个方法可以有相同的名称，只要它们的方法参数列表不同。
6. 在方法中声明的变量称为局部变量。局部变量的作用域从其声明开始，一直持续到包含该变量的块的末尾。局部变量在使用前必须声明并初始化。
7. 通过将方法的使用与其实现分离来实现**方法抽象**。客户端可以使用方法而无需知道其实现方式。实现细节封装在方法中，并对调用该方法的客户端隐藏。这称为信息隐藏或封装（ information hiding or encapsulation.）。方法抽象以整齐的分层方式模块化程序。

### 第 7 章 一维数组
- 可以使用语法 `elementType[]` `arrayRefVar` 或 `elementType` `arrayRefVar[]`将变量声明为数组类型。
- 虽然 `elementType arrayRefVar[]` 是合法的，但更推荐使用 `elementType[] arrayRefVar` 风格。
- 与基本数据类型变量的声明不同，数组变量的声明不会为数组在内存中分配任何空间。数组变量不是基本数据类型变量。数组变量包含对数组的引用。
- 数组元素存储在堆中，堆是可以动态分配的内存区域。除非数组已创建，否则不能为其分配元素。
- 可以使用 new 运算符创建数组，语法为：`new elementType[arraySize]`。数组中的每个元素使用语法 `arrayRefVar[index]` 表示。索引必须是整数或整数表达式。

### 第 8 章 数组（续）
- 数组创建后，其大小变为固定的，并可以使用 `arrayRefVar.length` 获取。由于数组的索引始终从 0 开始，所以最后一个索引始终是 `arrayRefVar.length - 1`。如果尝试引用超出数组边界的元素，将发生越界错误。
- 数组创建时，其元素被赋予默认值：数值基本数据类型为 0，char 类型为 `'\u0000'`，布尔类型为 false。
- Java 有一种简写表示法，称为数组初始化器，它在一个语句中结合了声明数组、创建数组和初始化，语法为：`elementType[] arrayRefVar = {value0, value1,..., valuek}`。
- 当将数组参数传递给方法时，实际上传递的是数组的引用；也就是说，被调用的方法可以修改调用者原始数组中的元素。
- 您可以使用两种简单、直观的排序算法：选择排序和插入排序来对列表进行排序。
  - `java.util.Arrays` 类包含各种用于排序和搜索数组、比较数组以及填充数组元素的静态方法
  - 您可以使用`binarySearch` 来查找数组中的键，它返回`-insertionpoint -1`。
  - `java.util.Arrays.binarySearch`（排序数组）
  - 您可以使用 sort 方法对整个数组或部分数组进行排序：`java.util.Arrays.sort`（未排序的数组）


![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412100035206.webp)

### 第 9 章 对象与类
- 类是对象的模板。它定义了对象的属性，并提供用于创建对象的构造函数和操作它们的方法。
- 类也是一种数据类型。可以使用它来声明对象引用变量。看似持有对象的对象引用变量实际上包含对该对象的引用。严格来说，对象引用变量和对象是不同的，但大多数情况下这种区别可以忽略。对象是类的实例。使用 new 运算符创建对象，并使用点（.）运算符通过其引用变量访问对象的成员。**实例变量或方法属于类的实例。其使用与单个实例相关**。静态变量是由同一类的所有实例共享的变量。静态方法是可以在不使用实例的情况下调用的方法。
- 类的每个实例都可以访问该类的静态变量和方法。不过，为了清楚起见，最好使用 `ClassName.variable` 和 `ClassName.method` 调用静态变量和方法。
- 修饰符指定如何访问类、方法和数据。所有客户端都可以访问公共类、方法或数据。默认方法或数据只能在同一包内访问。私有方法或数据只能在类内部访问。
- **所有参数都使用值传递传递给方法**。对于原始类型的参数，传递的是实际值；对于引用类型的参数，将传递对象的引用。
- Java 数组是一个可以包含基本类型值或对象类型值的对象。**创建对象数组时，其元素被赋予默认值 `null`**。
- 对于不可变的类，它必须将所有数据字段标记为私有，并且不提供会返回对可变数据字段对象的引用的修改器方法和访问器方法。

### 第 10 章 面向对象思维
- 过程式范式（The procedural paradigm）侧重于设计方法。面向对象范式将数据和方法耦合到对象中。使用面向对象范式的软件设计侧重于对象和对对象的操作。面向对象方法结合了过程式范式的强大功能，并增加了将数据与操作集成到对象中的维度。
- 实例和静态变量的作用域是整个类，无论变量在何处声明。实例和静态变量可以在类中的任何位置声明。为了保持一致性，它们通常在类的开头声明。
- 关键字 this 可用于引用调用对象。它也可用于构造函数内部以调用同一类的另一个构造函数。
- 许多 Java 方法需要使用对象作为参数。 Java 提供了一种将原始数据类型合并或包装到对象中的便捷方法（例如，将 int 包装到 Integer 类中，将 double 包装到 Double 类中，将 char 包装到 Character 类中）
  - 整数静态方法： `static int parseInt(String s) / static Integer valueof(String or int)`
  - 整数实例方法：`String toString()`
  - 整数a=100；整数b=100；`a==b`
- 注意：默认情况下，对于值 -128 到 127，`Integer.valueOf()`方法不会创建 Integer 的新实例。它从缓存中返回一个值。
- Java 可以自动将原始类型值转换为其上下文中相应的包装对象，反之亦然。 （装箱和拆箱）
- String 对象是不可变的；其内容无法更改。为了改进。为了提高效率并节省内存，JVM 将两个具有相同字符序列的文字字符串存储在一个唯一的对象中。这个独特的对象称为实习字符串对象。
- 正则表达式（A regular expression）是描述匹配一组字符串的模式的字符串。您可以通过指定模式来匹配、替换或拆分字符串。
- 字符串/字符串生成器/字符串缓冲区（追加/插入/删除）

### 第 11 章 继承与多态
- 您可以使用 extends 关键字从现有类派生新类。这称为类继承。

- 超类的构造函数不会在子类中继承。它们只能从子类的构造函数中使用关键字 super 调用。

- Use super : `super() or super. method();` / Use this: `this. field or this(args)`

- 构造函数可以调用重载构造函数或其超类的构造函数。该调用必须是构造函数中的第一条语句。**如果没有显式调用它们，编译器会将 super() 作为构造函数中的第一个语句，这将调用超类的无参数构造函数。**

- 要重写方法，必须使用与其超类中相同的签名在子类中定义该方法。

- Java 中的每个类都是 `java.lang.Object` 类的后代。如果定义类时没有指定继承，那么它的超类是Object。

- 类定义类型。由子类定义的类型称为子类型，由其超类定义的类型称为超类型。

- 如果方法的参数类型是超类（例如，Object），则可以将对象传递给任何参数子类（例如，Circle 或 String）的此方法。这称为多态性。

- 当在方法中使用对象（例如，Circle 对象或 String 对象）时，被调用的对象（例如，`toString`）的方法的特定实现是动态确定的，也称为动态绑定。

- 方法匹配： .编译器在编译时根据方法签名找到匹配的方法。

- 
  当从引用变量调用实例方法时，变量的实际类型决定在运行时使用该方法的实现。

  当访问字段或静态方法时，引用变量的声明类型决定在编译时使用哪个方法。

- 您可以使用obj `instanceof` a class 来测试对象是否是类的实例。

- 您可以使用 protected 修饰符来防止来自不同包的非子类访问数据和方法。

- 您可以使用`final`修饰符来指示一个类是`final`的并且不能是父类，并指示一个方法是`final`的并且不能被重写。

- 声明为静态的方法不能被重写，但可以重新声明。

- 如果一个方法不能被继承，那么它就不能被重写（private/final）

  - `java.util.ArrayList` 类可用于创建对象来存储对象列表。
  - 存储在`ArrayList`中的元素必须是同一种对象，不能使用基本类型。

### 第 12 章 异常处理与文本 I/O
- 异常处理使方法能够向其调用者抛出异常。
- Java 异常是从 `java.lang.Throwable` 派生的类的实例。Java 提供了许多预定义的异常类，如 `Error、Exception、RuntimeException、ClassNotFoundException、IOException、NullPointerException` 和 `ArithmeticException`。也可以通过扩展 Exception 定义自己的异常类。异常在方法执行期间发生。`RuntimeException` 和 `Error` 是未检查异常；所有其他异常是检查异常。声明方法时，如果方法可能抛出检查异常，则必须声明它，从而告诉编译器可能出现的问题。**声明异常的关键字是 throws，抛出异常的关键字是 throw。**
- 在任何情况下都会执行`finally`块中的代码，无论`try`块中是否发生异常或被捕获。
- 异常处理将错误处理代码与正常编程任务分开，从而使程序更易于阅读和修改。
- 异常处理不应该用来代替简单的测试。您应该尽可能测试简单的异常，并保留异常处理以处理 if 语句无法处理的情况。
- `File`类用于获取文件属性和操作文件。它**不包含创建文件或从文件读取数据/向文件写入数据的方法**。
- 您可以使用 `Scanner` 从文本文件中读取字符串和原始数据值，并使用 `PrintWriter` 创建文件并将数据写入文本文件。您可以使用 `try-with-resources` 自动关闭资源。
- 抽象类就像具有数据和方法的常规类一样，但不能使用 new 运算符创建抽象类的实例。

### 第 13 章 抽象类与接口
- 抽象类类似于具有数据和方法的普通类，但不能使用 new 运算符创建抽象类的实例。
- 非抽象类不能包含抽象方法。如果抽象超类的子类未实现超类继承的所有抽象方法，则该子类必须定义为抽象类。
- 包含抽象方法的类必须是抽象的。但是，可以定义不包含抽象方法的抽象类。
- 子类即使其超类是具体的也可以是抽象的。
- 接口是一种类结构，仅包含常量和抽象方法。在许多方面，接口类似于抽象类，但抽象类可以包含常量和抽象方法以及变量和具体方法。
- 在 Java 中，接口被视为特殊的类。每个接口都被编译成一个单独的字节码文件，就像常规类一样。
- `java.lang.Comparable` 接口定义了`compareTo` 方法。 Java 库中的许多类都实现了 `Comparable`。
- `java.lang.Cloneable`是一个标记接口，不包含常量或方法。它用来表示一个类拥有某些理想的属性。（浅复制/深复制）
- 一个类只能扩展一个超类，但可以实现一个或多个接口。
- 一个接口可以扩展一个或多个接口。

### 第 15 章 事件驱动编程
- 事件类的根类是 `javafx.event.Event`。Event 的子类处理特殊类型的事件，如动作事件、窗口事件、组件事件、鼠标事件和键事件。如果一个组件可以触发一个事件，则该组件的任何子类都可以触发相同类型的事件。

- 处理程序对象的类必须实现相应的处理程序接口。JavaFX 为每个事件类 T 提供一个处理程序接口 `EventHandler<T extends Event>`。处理程序接口包含称为 `handler(T e)`的方法，用于处理事件。

- 处理程序对象必须由源对象注册。注册方法取决于事件类型。对于动作事件，方法是 `setOnAction`。

- 内部类或嵌套类是在另一个类的范围内定义的。内部类可以引用它所嵌套的外部类中定义的数据和方法，因此不需要将外部类的引用传递给内部类的构造函数。`(OuterClassName$innerclassName.class.)`

- 匿名内部类必须始终扩展超类或实现接口，但不能有显式的 extends 或 Implements 子句。

- 匿名内部类被编译为名为 `OuterClassName$n.class` 的类。

- 我们可以使用 `lambda` 表达式来简化事件处理。 `lambda` 表达式可以被视为语法简洁的匿名方法。

  - ```java
    (type1 param1, type2 param2, ...) -> expression
    (type1 param1, type2 param2, ...) -> { statements; }
    ```

    
