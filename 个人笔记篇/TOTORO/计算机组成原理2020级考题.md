# 计算机组成原理2020级考题

> 计算机组成原理，很难的一科，需要花点心思了。

## 选择题

**问题1：**

Which type of memory will need refresh circuitry?

A. DRAM 
B. Flash 
C. ROM 
D. Blu - ray

**答案**：A

**解释**：

- **DRAM（动态随机存取存储器）**：DRAM的基本存储单元是由一个晶体管和一个电容组成。电容用于存储二进制数据（充电代表1，放电代表0）。然而，电容存在漏电问题，随着时间推移，存储的数据会丢失。所以，需要刷新电路定期对存储单元进行刷新，以保持数据的完整性。一般这个刷新过程是每隔几毫秒就进行一次，通过刷新电路按照一定的顺序对存储单元进行读取和重写操作。
- **Flash（闪存）**：它是一种电可擦除可编程只读存储器（EEPROM）的变种。数据的存储是基于闪存芯片内部的浮栅晶体管结构。在写入数据后，即使断电数据也能长时间保存，不需要像DRAM那样的刷新操作来维持数据。
- **ROM（只读存储器）**：这是一种预先编程好数据的存储器，数据在制造过程中或者使用专门的编程设备写入后就固定不变了。其内容在正常工作过程中不会丢失，也不需要刷新电路，因为它的存储机制不是基于像DRAM中电容那种易失性的结构。
- **Blu - ray（蓝光光盘）**：这是一种光存储介质。数据是通过在光盘的记录层上使用高精度的激光技术烧蚀出微小的凹坑来表示0和1。数据的保存完全依赖于光盘物理层面的这些凹坑，不存在需要刷新电路来维持数据的情况。


**问题2：**

The advantage of carry - lookahead adder is.

A. decrease cost of the adder. 
B. save hardware parts.
C. augment CPU clock frequency. 
D. accelerate the generation of the carries.

**答案**：D

**解释**：

- **进位前瞻加法器（carry - lookahead adder）**：在传统的逐位进位加法器中，进位信号是从最低位开始逐位产生并传递的。例如，在计算两个二进制数相加时，每一位的相加结果可能会受到低位进位的影响。而进位产生和传递的过程是需要时间的，这就限制了加法器的运算速度。进位前瞻加法器的设计理念是通过逻辑电路提前计算出每一位可能产生的进位信号，而不是等待低位进位的逐位传递。这样就大大加快了加法运算的速度，其核心优势就是能够加速进位的产生。
- **关于选项A**：进位前瞻加法器通常需要更复杂的逻辑电路来实现进位的快速计算。相比于简单的逐位进位加法器，它的电路结构更复杂，往往会增加成本，而不是降低成本。
- **关于选项B**：由于其复杂的进位计算逻辑，需要更多的硬件部件来实现。例如，它需要额外的逻辑门来提前计算进位信号，而不是节省硬件部分。
- **关于选项C**：虽然进位前瞻加法器能够加快加法运算速度，但它和CPU时钟频率并没有直接的关联。CPU时钟频率主要是由晶振等硬件决定的，并且受到整个CPU流水线设计等多种因素的限制。进位前瞻加法器只是在加法运算这个环节加速了运算过程，不是直接用于增大CPU时钟频率。



**问题3：**

In the direct addressing mode.

A. The operand is inside the instruction.
B. The address of the operand is inside the instruction.
C. The register containing the address of the operand is specified inside the instruction.
D. The location of the operand is implicit.

**答案**：B

**解释**：

- **直接寻址模式（Direct Addressing Mode）**：在这种寻址方式中，指令中包含的是操作数的地址。计算机在执行指令时，会根据指令中给出的这个地址，从内存相应的位置获取操作数。
- **选项A**：如果操作数本身在指令中，这是立即寻址（Immediate Addressing）方式的特点，而不是直接寻址。例如，在指令“MOV AX, 5”中，5这个操作数直接在指令里，这是立即寻址。
- **选项C**：当指令中指定的是包含操作数地址的寄存器时，这是寄存器间接寻址（Register Indirect Addressing）方式。比如指令“MOV AX, [BX]”，这里是从BX寄存器所指向的内存地址中获取操作数。
- **选项D**：如果操作数位置是隐含的，通常是隐含寻址（Implicit Addressing）。例如在某些堆栈操作指令中，操作数的位置（栈顶等）是由指令的操作隐含确定的，与直接寻址模式不同。


**问题4：**

In a microprogram - control computer, the microinstructions are stored in a memory called the.

A. direct memory
B. physical memory
C. virtual memory
D. control store

**答案**：D

**解释**：

- **微程序控制计算机（Microprogram - Control Computer）**：在这种计算机体系结构中，微指令（Microinstructions）存储在控制存储器（Control Store）中。控制存储器是一种特殊的只读存储器（ROM）或可编程只读存储器（PROM），用于存储微程序。
- **选项A**：“直接内存”不是用于专门存储微指令的术语，这不是一个在微程序控制计算机中有特定指向存储微指令的概念表述。
- **选项B**：物理内存（Physical Memory）通常是指计算机系统中实际的主存储器，用于存储程序和数据等多种信息，并不是专门用于存储微指令的地方。
- **选项C**：虚拟内存（Virtual Memory）是一种通过硬件和软件结合的技术，为程序提供比实际物理内存更大的存储空间假象。它主要用于存储程序和数据的页面，不是存储微指令的专门存储区域。

**问题5：**

Consider a four - bit ALU which does four - bit arithmetic. When computing 1101+1011, what is the status of NZCV flags?

**答案**：$N = 1$，$Z = 0$，$C = 1$，$V = 0$

**解释**：

- 首先进行二进制加法：
  - 计算$1101 + 1011$，得到二进制结果为$11000$。但因为是4位ALU，只取低4位，结果为$1000$。
- 然后分析标志位：
  - **N（Negative）标志位**：结果$1000$最高位是$1$，在有符号数表示中意味着结果是负数，所以$N = 1$。
  - **Z（Zero）标志位**：由于结果$1000$不是$0$，所以$Z = 0$。
  - **C（Carry）标志位**：实际加法运算产生了进位（完整结果是$11000$），所以$C = 1$。
  - **V（Overflow）标志位**：把$1101$看作有符号数是$-3$（$1101$的补码表示的数），$1011$看作有符号数是$-5$，它们相加结果$1000$看作有符号数是$-8$。因为$-3+(-5)=-8$，没有溢出，所以$V = 0$。

四个标志位的解释

1. **N（Negative）标志位**
   - **定义**：N标志位用于表示运算结果的正负性。在有符号数运算中，如果运算结果的最高位（符号位）为1，则N = 1，表示结果为负数；如果最高位为0，则N = 0，表示结果为正数或零。
   - **示例**：在8位有符号数运算中，对于结果10000001，最高位为1，所以N = 1，该结果表示一个负数；对于结果00000001，最高位为0，N = 0，该结果表示一个正数。
   - **应用场景**：在算术和逻辑运算后，通过查看N标志位，处理器可以快速判断结果的正负，这对于条件分支等操作很重要。例如，在比较两个有符号数大小时，如果减法运算后的N = 1，说明被减数小于减数。
2. **Z（Zero）标志位**
   - **定义**：Z标志位用于表示运算结果是否为零。如果运算结果的所有位都是0，那么Z = 1；只要结果中有一位不为0，Z = 0。
   - **示例**：对于运算结果00000000，Z = 1；对于结果00000001，Z = 0。
   - **应用场景**：常用于判断一个操作是否产生了非零结果。比如在循环控制中，当某个计数器减到0时，通过检查Z标志位来确定是否结束循环。在条件判断语句中，也可以根据Z标志位来决定是否执行特定的代码块，例如判断两个数相减后是否相等。
3. **C（Carry）标志位**
   - **定义**：C标志位用于表示无符号数运算中的进位情况。在加法运算中，如果最高位（最左边的位）产生了进位，或者在减法运算中不够减而需要借位（可以看作向更高位的借位），则C = 1；否则C = 0。
   - **示例**：在4位无符号数加法中，计算1111+0001，结果是10000（实际只考虑4位时是0000），产生了进位，所以C = 1；计算1000 - 0001，不够减，产生借位，C = 1。
   - **应用场景**：在多字节或多位无符号数运算中非常重要。例如，在16位加法运算中，通常是先进行低8位的加法，此时如果产生进位（C = 1），则在进行高8位加法时要将这个进位考虑进去，保证运算的准确性。
4. **V（Overflow）标志位**
   - **定义**：V标志位用于表示有符号数运算中的溢出情况。当两个有符号数进行运算时，如果结果超出了有符号数所能表示的范围，则V = 1，表示发生了溢出；如果结果在范围内，则V = 0。
   - **示例**：在8位有符号数运算中，范围是 - 128到127。计算127+1，得到结果10000000（ - 128的补码），超出了正数范围，V = 1；计算 - 128 - 1，得到结果01111111（127的补码），超出了负数范围，V = 1。
   - **应用场景**：在进行有符号数的算术运算如加法、减法等操作后，通过检查V标志位可以确定结果是否有效。如果V = 1，说明运算结果不可靠，可能需要进行特殊处理，比如触发异常或调整运算策略。


**问题6：**

The pipelining technique typically improves the performance of a computer by.

A. decreasing the execution time of an instruction
B. improving CPU block frequency
C. improving the throughput
D. decreasing the cache miss rate

**答案**：C

**解释**：
- **选项A**：
  - 流水线技术不会减少单条指令的执行时间。在流水线中，每条指令仍然需要经过取指、译码、执行等多个阶段，每个阶段的时间并没有改变。只是通过让多条指令在不同阶段同时进行，提高了整体效率。
- **选项B**：
  - “CPU block frequency”这个概念表述不准确，流水线主要目的不是改善这个不太明确的参数，而是着重于指令的高效执行流程。
- **选项C**：
  - 流水线技术就像工厂的流水线一样，允许多个指令同时处于不同的执行阶段。例如，当第一条指令在执行阶段时，第二条指令可以在译码阶段，第三条指令可以在取指阶段等。这样在单位时间内能够完成更多的指令，从而提高了吞吐率（Throughput），这是流水线技术的主要优势。
- **选项D**：
  - 流水线技术和缓存（Cache）的命中率（Miss Rate）没有直接关联。缓存是用于减少CPU访问内存的延迟，通过存储最近使用的数据和指令来提高访问速度，而流水线是用于优化指令的执行流程。


**问题7：**

The required control signals in a hardwired control unit are determined by the following information except.

A. contents of the control step counter
B. contents of the MAR (memory address register)
C. contents of the IR (instruction register)
D. contents of the condition code flags

**答案**：B

**解释**：
- **硬连线控制单元（Hardwired Control Unit）**：
  - **选项A**：控制步计数器（Control Step Counter）的内容对控制信号有重要作用。它用于确定当前指令执行的步骤，不同的步骤需要不同的控制信号来驱动数据通路中的各个部件，如在取指阶段和执行阶段会产生不同的控制信号，这是由控制步计数器的值来决定的。
  - **选项B**：内存地址寄存器（MAR）主要用于存放要访问的内存单元的地址。它在存储访问操作中起到关键作用，但它的内容一般不直接用于确定硬连线控制单元中的控制信号。这些信号主要是围绕指令的执行步骤、指令本身的内容以及条件码标志来产生的。
  - **选项C**：指令寄存器（IR）的内容对控制信号的产生至关重要。因为它存放着当前正在执行的指令，根据指令的操作码和操作数等信息来确定需要哪些控制信号来完成指令的执行，比如是加法指令、减法指令还是跳转指令等不同指令会产生不同的控制信号。
  - **选项D**：条件码标志（Condition Code Flags）的内容也会影响控制信号。例如，根据标志位（如零标志位、进位标志位等）来决定是否进行分支跳转，这些标志位会作为产生控制信号的依据，以改变指令的执行流程。


**问题8：**

The processor informs the IO devices that it is ready to acknowledge interrupts by.

A. enabling the interrupt request line
B. activating the interrupt acknowledge line
C. activating the interrupt completion line
D. enabling the interrupt starting line

**答案**：B

**解释**：
- **中断处理（Interrupt Handling）**：
  - **选项A**：使能中断请求线（Interrupt Request Line）是由外部设备用来向处理器发送中断请求的，而不是处理器用来告知设备它准备好确认中断。
  - **选项B**：当处理器激活（activating）中断确认线（Interrupt Acknowledge Line）时，这是在告诉外部I/O设备，处理器已经准备好确认中断请求，之后可以开始进行中断处理的相关流程，例如获取中断向量等操作。
  - **选项C**：中断完成线（Interrupt Completion Line）是用于在中断处理完成后通知相关设备或系统中断处理已经结束，而不是用于告知准备确认中断。
  - **选项D**：没有“中断起始线（Interrupt Starting Line）”这个用于表示处理器准备确认中断的标准术语表述，这一选项不符合中断处理的常规概念。

**问题9：**

The starting address sent by the device in vectored interrupt is called as.

A. interrupt vector
B. location ID
C. service location
D. service ID

**答案**：A

**解释**：
- **中断向量（Interrupt Vector）**：在向量中断（Vectored Interrupt）中，当设备发出中断请求时，它会发送一个中断向量。这个中断向量实际上就是中断服务程序的起始地址。处理器通过这个起始地址能够快速地定位到相应的中断服务程序并开始执行，从而高效地处理中断。
- **选项B**：“位置标识符（Location ID）”这个术语通常不用于描述向量中断中设备发送的起始地址，它没有准确地体现这个在中断处理过程中的特定概念。
- **选项C**：“服务位置（Service Location）”表述比较模糊，没有像“中断向量”那样明确地指代在向量中断里设备发送的用于定位中断服务程序起始地址的这个概念。
- **选项D**：“服务标识符（Service ID）”主要是用于识别服务类型等相关信息，而不是专门用于表示向量中断中服务程序的起始地址。


**问题10：**

If the bytes 0x12, followed by 0x34, followed by 0x56, followed by 0x78 are interpreted as a 4 - byte little endian integer, what value will they have?

**答案**：0x78563412

**解释**：
- **小端序（Little -endian）**：在小端序存储格式中，数据的低位字节存于低地址，高位字节存于高地址。
- 对于给定的字节序列0x12、0x34、0x56、0x78，按照小端序解释为一个4字节整数时：
  - 最低地址存放的是0x12，它代表整数的最低位字节；接着地址递增，依次是0x34、0x56、0x78。
  - 组合起来得到的整数值就是0x78563412，即将这些字节按照从高地址到低地址（在小端序下是从右到左）的顺序排列构成一个完整的32位整数。



## 简答题

**问题1：**

**解释DMA（直接内存访问）的过程：（Explain the process of DMA.）**

1. **初始化阶段**
   - **设备请求**：外部设备（如磁盘驱动器、网卡等）需要传输大量数据到内存或者从内存读取大量数据时，它会向DMA控制器发送一个DMA请求信号。这个请求信号表明设备希望直接访问内存，以避免通过CPU来逐个字节或字地传输数据，从而提高数据传输效率。
   - **CPU响应**：当CPU接收到这个请求并且允许设备进行DMA操作（这通常取决于CPU的状态和优先级设置等因素）时，CPU会暂停当前正在执行的程序（如果需要），并且将系统总线的控制权交给DMA控制器。同时，CPU会向DMA控制器提供一些必要的信息，例如数据传输的起始地址（在内存中的位置）、传输的数据长度等。
2. **数据传输阶段**
   - **地址生成**：DMA控制器根据CPU提供的起始地址，在内存中生成一系列连续的内存地址。它会自动地递增或递减这个地址，以便按顺序访问内存单元。
   - **数据传输**：DMA控制器直接控制数据在外部设备和内存之间的传输。对于数据写入操作，它从外部设备读取数据，并将其写入内存单元；对于数据读取操作，它从内存单元读取数据，并将其发送到外部设备。这个过程不需要CPU的干预，数据是直接在设备和内存之间通过系统总线进行传输的，传输的速度通常由设备和内存的带宽以及DMA控制器的性能决定。
3. **传输完成阶段**
   - **中断请求**：当DMA控制器完成了指定的数据传输任务后，它会向CPU发送一个中断请求信号。这个信号通知CPU数据传输已经完成，CPU可以重新获得系统总线的控制权。
   - **CPU恢复操作**：CPU接收到中断请求后，会暂停当前的中断服务程序（如果正在执行），然后恢复之前被暂停的程序执行。此时，CPU可以根据需要对已经传输的数据进行进一步的处理，比如对从磁盘读取的数据进行解包、对发送到网络设备的数据进行校验等操作。

**问题2：**

1. **计算页内偏移量位数和页数（虚拟页和物理页）位数（Imagine a system with the following parameters. Virtual addresses 20 bits, physical addresses 18 bits, page size 1 KB. Please give the format of virtual address and physical address. Explain your answer.）**
   - 已知页大小为$1KB = 2^{10}$字节。因为页内偏移量是用来确定在一个页内的具体位置的，所以页内偏移量的位数$n$是根据页大小来确定的，由$2^{n}=页大小$，可得页内偏移量的位数$n = 10$位。
   - 对于虚拟地址，总共有$20$位。除去页内偏移量的$10$位，剩下的用于表示虚拟页号的位数为$20 - 10=10$位。
   - 对于物理地址，总共有$18$位。除去页内偏移量的$10$位，剩下的用于表示物理页号的位数为$18 - 10 = 8$位。
2. **虚拟地址格式**
   - 虚拟地址可以分为两部分：高$10$位为虚拟页号（VPN），用于定位虚拟内存中的页；低$10$位为页内偏移量（VPO），用于定位页内的具体字节。可以表示为：[VPN（10位）|VPO（10位）]。
3. **物理地址格式**
   - 物理地址也分为两部分：高$8$位为物理页号（PPN），用于定位物理内存中的页；低$10$位为页内偏移量（PPO），和虚拟地址中的页内偏移量是相同的（因为在页式存储管理中，虚拟页和物理页大小相同）。可以表示为：[PPN（8位）|PPO（10位）]。

这种格式的划分是基于页式存储管理的原理，通过虚拟页号和物理页号来实现虚拟地址到物理地址的映射，而页内偏移量则保证了在页内能够准确地访问数据。



以下是按照规范为你整理好的包含问题、选项（若有）、答案和解释的内容：

### 问题3
**问题**：The two numbers given below are multiplied using the Booth's algorithm. Multiplicand: 0101101011101110. Multiplier: 0111011110111101. How many additions/subtractions are required for the multiplication of the above two numbers?

**答案**：10

**解释**：

- **Booth算法原理阐述**：Booth算法是用于有符号数乘法的高效算法，其依据乘数二进制位相邻两位的变化情况决定操作。若相邻两位是“01”，执行加法；若相邻两位是“10”，执行减法；若为“00”或“11”，则不操作。并且在操作前需在乘数最低位添加一个额外的0用于处理最后一位情况。
- **明确乘数和被乘数位数**：给定的被乘数“0101101011101110”以及乘数“0111011110111101”均为16位二进制数。
- **分析加法/减法次数**：先在乘数最低位后添加一个0，变为“01110111101111010”。

![image-20241122164458335](C:\Totoro.trip\blog-demo\source\images\image-20241122164458335-1733372940081-5.png)

按照下图开始分析，即可得到10次。

### 问题4
**问题**：In a computer, can we build a memory system with one type of memory to get a large, fast and cheap memory?

**答案**：不能（或在实际中很难做到）

**解释**：
- **不同类型存储器特点分析**：
    - **速度方面**：SRAM（静态随机存取存储器）读写速度极快，可达纳秒级别，不过其成本高昂、集成度低，导致存储容量较小。例如在CPU的高速缓存（Cache）中常用SRAM，以便快速存取当前正在执行程序和数据的部分内容，提升CPU执行效率，但受成本和集成度限制，其容量通常不大。
    - **容量方面**：DRAM（动态随机存取存储器）容量较大，成本相对较低，可提供较大的存储空间，是计算机主存储器（内存）的主要构成部分，用于存储正在运行的程序和数据，但它的读写速度比SRAM慢，且因其基于电容存储数据，存在漏电问题，需定期刷新来维持数据，这也在一定程度上影响了读写速度。
    - **价格方面**：磁带、磁盘等存储设备价格便宜且存储容量巨大，然而读写速度非常缓慢，主要应用于长期大量数据存储场景，比如数据仓库、备份存储等。
- **综合考量**：
    - 若仅采用速度快的SRAM构建存储系统，虽能满足速度要求，但成本会高得离谱，而且难以实现大容量存储，毕竟SRAM集成度有限，单位存储成本过高。
    - 要是只使用大容量的DRAM构建，其速度无法达到最快标准，在CPU频繁快速读取指令和数据时，DRAM相对较慢的读写速度易成为性能瓶颈。
    - 而若只用价格便宜的磁带或磁盘，其过慢的读写速度根本无法满足计算机快速读写数据的需求，即便容量大也不能作为主要存储系统来提供高效的数据存储和读取服务。

所以，通常要采用多种类型的存储器构建层次化的存储系统，例如在CPU和主存间设置高速缓存（Cache）利用SRAM的高速特性缓存常访问数据，用大容量DRAM作主存，再配合大容量磁盘等存储设备用于长期存储数据，以此在速度、容量和成本间取得较好平衡。 



## 综合应用题

### 问题1
#### (1)
**问题**：Suppose we have a 7 - bit computer that uses IEEE floating - point arithmetic where a floating point number has 1 sign bit, 3 exponent bits, and 3 fraction bits. The exponent part uses an excess - 3 representation. The remaining 3 - bit mantissa is normalized with an implied 1 to the left of the binary point. Rounding is employed as the truncation methal. Write the largest positive normalized floating - point number. And write the smallest positive normalized floating - point number.

1. 对于一个使用IEEE浮点算术的7位计算机，其浮点数有1个符号位、3个指数位、3个尾数位，指数部分采用偏移量为3的表示法，剩余3位尾数通过在二进制小数点左边隐含1来进行归一化，舍入采用截断法：
    (1) 写出最大的正归一化浮点数以及最小的正归一化浮点数。
    (2) 已知$A = 1.001$，$B = 0.010111$，写出$A + B$的结果及计算过程，并以归一化形式给出结果。

### 答案
#### (1)
- **最大正归一化浮点数**：
    - 符号位为$0$（表示正数）。
    - 指数部分采用偏移量为$3$的表示法，3位指数能表示的最大无偏移值是$111_{(2)} = 7_{(10)}$，偏移量为$3$时，最大偏移后的指数值对应的无符号整数表示为$111_{(2)}$，偏移后的指数值为$7_{(10)}$，实际指数值为$7 - 3 = 4_{(10)}$ 。
    - 尾数部分，因为归一化且隐含了最高位的$1$，3位尾数位能表示的最大数值是$111_{(2)}$，整个尾数为$1.111_{(2)}$。
    - 按照这种格式，最大正归一化浮点数的二进制表示为$0111111_{(2)}$，转换为十进制其值为$(1 + 2^{-1} + 2^{-2} + 2^{-3})×2^{4} = (1 + 0.5 + 0.25 + 0.125)×16 = 1.875×16 = 30_{(10)}$。
- **最小正归一化浮点数**：
    - 符号位为$0$。
    - 指数部分采用偏移量为$3$的表示法，最小非零指数值对应的无符号整数表示为$001_{(2)}$，偏移后的指数值为$1_{(10)}$，实际指数值为$1 - 3 = -2_{(10)}$。
    - 尾数部分最小为$1.000_{(2)}$（隐含了前面的$1$）。
    - 所以最小正归一化浮点数的二进制表示为$0001100_{(2)}$，转换为十进制其值为$1×2^{-2}= 0.25_{(10)}$。

#### (2)
首先将$A = 1.001_{(2)}$和$B = 0.010111_{(2)}$转换为符合该计算机浮点表示格式的形式。

- **对于$A = 1.001_{(2)}$**:
    - 其等于$1×2^{0}$，符号位为$0$（正数），指数$0$采用偏移量为$3$的表示法，对应的偏移后指数表示为$011_{(2)}$，尾数部分归一化后，隐含前面的$1$，实际存储的尾数位是$001_{(2)}$，所以$A$在该计算机中的表示为$0011001_{(2)}$。
- **对于$B = 0.010111_{(2)}$**:
    - 写成科学计数法形式为$1.0111×2^{-2}$，符号位为$0$，指数$-2$采用偏移量为$3$的表示法，对应的偏移后指数表示为$001_{(2)}$，尾数部分为$0111$（去掉前面隐含的$1$后），所以$B$在该计算机中的表示为$0001011_{(2)}$。

#### 对阶
- 在浮点运算中，要进行尾数相加，前提是两个数的指数要相同，这就是“对阶”这个步骤的目的。
- 这里 $A$ 的指数（偏移后）是 $011_{(2)}$（对应实际指数 $0$），$B$ 的指数（偏移后）是 $001_{(2)}$（对应实际指数 $-2$），所以 $B$ 的指数比 $A$ 的小，需要将 $B$ 的指数调整为和 $A$ 一样。
- 调整的方法就是把 $B$ 的尾数右移，右移几位取决于两个数指数的差值，这里差值为 $2$，所以将 $B$ 的尾数右移 $2$ 位，右移的时候按照截断舍入法舍去后面多余的位，$B$ 原来的尾数是 $0.010111_{(2)}$，右移 $2$ 位后就变成了 $0.0101_{(2)}$（舍去了后面的 $1$），同时指数要相应增加 $2$，这样 $B$ 调整后的指数就和 $A$ 一样了（偏移后变为 $011_{(2)}$），此时 $B$ 对应的表示变为 $0011010_{(2)}$。

#### 尾数相加
- 经过对阶后，$A$ 的尾数为 $1.001_{(2)}$，$B$ 调整后的尾数为 $0.0101_{(2)}$，就可以像普通二进制数相加一样进行尾数相加了：
$
\begin{align*}
&1.001_{(2)}\\
+&0.0101_{(2)}\\
=&1.0111_{(2)}
\end{align*}
$
- 但是要注意，根据题目给定的截断舍入法，我们只能取 $3$ 位尾数，所以对 $1.0111_{(2)}$ 进行截断舍入后得到 $1.011_{(2)}$。

#### 结果规格化及判断
- 此时得到的结果是 $1.011_{(2)}×2^{0}$，按照计算机的表示规则：
    - 符号位依然是 $0$（因为结果还是正数）。
    - 指数（偏移后）为 $011_{(2)}$（因为结果的实际指数是 $0$，采用偏移量为 $3$ 的表示法，偏移后就是 $011_{(2)}$）。
    - 尾数为 $011_{(2)}$（这里是去掉前面隐含的 $1$ 后实际存储的尾数位），所以最终结果在该计算机中的表示为 $0011011_{(2)}$。
- 最后为了更直观地知道这个结果对应的数值大小，把它转换回常规二进制数表示的数值，$1.011_{(2)} = 1×2^{0} + 0×2^{-1} + 1×2^{-2} +1×2^{-3}= 1.375_{(10)}$，这样就能清楚计算得到的具体数值了。

### 问题2
是否有可能设计一种扩展操作码，以便能在 12 位的指令中对以下情况进行编码：
1. 6 条带有 3 个寄存器的指令（假设一个寄存器操作数需要 3 位，且该指令集不允许在指令中直接使用内存地址）。
2. 14 条带有 2 个寄存器的指令。
3. 15 条带有 1 个寄存器的指令。
4. 8 条不带寄存器的指令。需判断是否可行并给出理由。

### 答案
是有可能设计出这样的扩展操作码来满足上述要求的。

### 解释
由于指令长度为 12 位，且寄存器操作数每个需要 3 位，同时指令集不允许直接使用内存地址。

1. **对于 6 条带有 3 个寄存器的指令**：
    - 每条指令需要 3 个寄存器操作数，总共占用 $3×3 = 9$ 位用于表示寄存器。
    - 还剩下 $12 - 9 = 3$ 位可用于操作码。操作码有 3 位，可以表示 $2^3 = 8$ 种不同的操作码，而这里只需要编码 6 条指令，所以是足够的，因为 $6 \lt 8$。

2. **对于 14 条带有 2 个寄存器的指令**：
    - 2 个寄存器操作数共占用 $2×3 = 6$ 位。
    - 剩余用于操作码的位数为 $12 - 6 = 6$ 位。操作码有 6 位时，可以表示 $2^6 = 64$ 种不同操作码，远远超过需要编码的 14 条指令，因为 $14 \lt 64$，所以能够满足编码要求。

3. **对于 15 条带有 1 个寄存器的指令**：
    - 1 个寄存器操作数占用 3 位。
    - 剩下 $12 - 3 = 9$ 位用于操作码，操作码有 9 位能表示 $2^9 = 512$ 种不同操作码，显然 $15 \lt 512$，足够用来编码这 15 条指令。

4. **对于 8 条不带寄存器的指令**：
    - 所有 12 位都可用于操作码，能表示 $2^{12} = 4096$ 种不同操作码， $8 \lt 4096$，完全可以对这 8 条指令进行编码。

综上，通过合理分配操作码位数和寄存器操作数所占位数，是可以设计出扩展操作码来满足上述各种情况的编码要求的。 





### 问题3
Part of a RISC-style processor's datapath is shown as the following figure. Instruction execution can be divided into 5-stages. Now we want to execute Mutiply R7, R8, R9 on this datapath. Before this instruction, [R7]=20, [R8]=10, [R9]=30. Write the values of registers at the end of instruction stage 2, stage 3, stage 4. 
1. [RA].
2. [RB].
3. [RZ].
4. [RY].


#### 第1阶段：取指（IF）
- 在这个阶段，会使用程序计数器（PC）从内存中取出指令。不过这一阶段并不会直接影响我们所关注的这些寄存器（RA、RB、RZ、RY）的值。

#### 第2阶段：译码（ID）
- 在指令译码阶段，会从寄存器堆中读取指令的操作数。
- 对于“Multiply R7, R8, R9”这条指令，我们需要读取寄存器R8和R9的值作为源操作数。
- 因此，寄存器RA会加载寄存器R8的值。已知[R8] = 10，所以在第2阶段结束时，[RA] = 10。
- 寄存器RB会加载寄存器R9的值。已知[R9] = 30，所以在第2阶段结束时，[RB] = 30。

#### 第3阶段：执行（EX）
- 在执行阶段，会通过算术逻辑单元（ALU）执行实际的算术运算（在这里是乘法运算）。
- ALU会取RA和RB中的值（在我们这个例子中分别是10和30）并进行相乘运算。
- 相乘的结果（10×30 = 300）会存储在RZ中。所以，在第3阶段结束时，[RZ] = 300。

#### 第4阶段：访存（MEM）
- 对于“Multiply”（乘法）指令来说，它属于寄存器到寄存器的操作，不像加载/存储指令那样会涉及到对内存的数据读写操作，对于这类算术运算指令而言，访存阶段相当于一个直通阶段。
- 所以，在执行阶段计算得到的值保持不变。在第4阶段结束时，[RY] = [RZ] = 300。

总结如下：
1. 在第2阶段结束时：[RA] = 10。
2. 在第2阶段结束时：[RB] = 30。
3. 在第3阶段结束时：[RZ] = 300。
4. 在第4阶段结束时：[RY] = 300。 

> PPT上有专门的习题：这里附上

### 示例 1: Add R3, R4, R5（将 R4 和 R5 相加，结果存入 R3）
#### 步骤 1：指令获取
- **内存地址 ← [PC]**：程序计数器（PC）提供当前指令的内存地址。
- **读取内存，IR ← 内存数据**：处理器从内存中读取指令并将其存入指令寄存器（IR）。
- **PC ← [PC] + 4**：指令获取完毕后，程序计数器（PC）递增 4（假设每条指令占用 4 字节），指向下一条指令。

**解释**：第一步完成了从内存中获取当前指令，并更新了程序计数器，使得下一条指令的获取地址准备好。

#### 步骤 2：解码指令
- **RA ← [R4]**：从寄存器文件中读取寄存器 R4 的值，存入临时寄存器 RA。
- **RB ← [R5]**：从寄存器文件中读取寄存器 R5 的的值，存入临时寄存器 RB。

**解释**：在第二步，解码指令并准备好操作数。寄存器 R4 和 R5 的内容被加载到寄存器 RA 和 RB 中，供下一步计算使用。

#### 步骤 3：执行计算
- **RZ ← [RA] + [RB]**：将 RA 和 RB 寄存器中的值相加，结果存入临时寄存器 RZ。

**解释**：在执行阶段，ALU（算术逻辑单元）对两个寄存器的值进行加法运算，计算出结果并存入寄存器 RZ。

#### 步骤 4：保存计算结果
- **RY ← [RZ]**：将临时寄存器 RZ 中的结果存入寄存器 RY（这里假设 RY 是一个临时寄存器或计算结果的存储寄存器）。

**解释**：这一步可能是为了准备将计算结果进一步处理，或将结果传递给下一步。

#### 步骤 5：写回结果
- **R3 ← [RY]**：将最终的计算结果从寄存器 RY 写回到目标寄存器 R3。

**解释**：最后，计算结果存回寄存器 R3，完成指令的执行。 



### 问题4
The following sequence of RISC instructions are executed on a 5-stage pipeline. We can indicate the 5 stages of the pipeline using: F, D, C, M and W.
Add R2, R1, R3.
Sub R4, R2, R1
And R5, R1, R2
Sub R6, R2, R4
(1) Write all the data dependencies in the four instructions above.
(2) Draw a figure to illustrate the execution of the four instructions on the pipeline. Assume that the pipeline has operand forwarding paths. Pay attention to mark the forwarding paths.

1. **数据依赖关系**
   - **Add指令与Sub（R4, R2, R1）指令的依赖关系**：
     - **指令对**：Add R2, R1, R3和Sub R4, R2, R1
     - **依赖寄存器**：R2。Sub指令需要等待Add指令将结果存储到R2中才能执行。
   - **Add指令与And（R5, R1, R2）指令的依赖关系**：
     - **指令对**：Add R2, R1, R3和And R5, R1, R2
     - **依赖寄存器**：R2。And指令需要等待Add指令将结果存储到R2中才能执行。
   - **Sub（R4, R2, R1）指令与Sub（R6, R2, R4，Add R2, R1, R3）指令的依赖关系**：

如图：

![ac55b2d764cc2286c47d5f91d62ca67](C:\Totoro.trip\blog-demo\source\images\ac55b2d764cc2286c47d5f91d62ca67.jpg)





---



 ### 问题5
An integrated circuit RAM chip can hold 2048 words of 8 bits each (`2k*8`).
(1) How many addresses and the data lines are there in the chips?
(2) How many chips are needed to construct a `32k*16 `RAM?
(3) How many addresses and the data lines are there in a` 32k*16 `RAM?
(4) What size of the decoder is needed to construct `32k*16 `memory from the` 2k*8 `chips? What are the inputs to the decoder and where are its outputs connected?

#### 分析
1. **（1）芯片中的地址线和数据线数量**
    - 对于存储容量为$2048$（$2K$）字，每个字$8$位的芯片：
    - 地址线数量：因为存储单元的数量是$2048 = 2^{11}$，所以地址线的数量$n$满足$2^{n}=2048$，解得$n = 11$条。
    - 数据线数量：每个存储单元存储$8$位数据，所以数据线的数量是$8$条。

2. **（2）构建`32k*16` RAM所需芯片数量**
    - 首先，目标是构建一个$32K\times16$的RAM。
    - 已知已有芯片是$2K\times8$。
    - 计算字数倍数：$32K\div2K = 16$（表示在字的方向上需要的芯片数量倍数）。
    - 计算位数倍数：$16\div8 = 2$（表示在数据位方向上需要的芯片数量倍数）。
    - 总共需要的芯片数量：$16\times2=32$片。

3. **（3）`32k*16 `RAM中的地址线和数据线数量**
    - 对于$32K\times16$的RAM：
    - 地址线数量：因为存储单元的数量是$32K = 2^{15}$，所以地址线的数量$m$满足$2^{m}=32K$，解得$m = 15$条。
    - 数据线数量：每个存储单元存储$16$位数据，所以数据线的数量是$16$条。

4. **（4）从`2k*8`芯片构建`32k*16`存储器所需解码器的大小、输入和输出连接**
    - 因为有$32$片芯片，地址线分为两部分，一部分用于芯片选择，一部分用于片内地址。
    - 对于$2K\times8$的芯片，片内地址线有$11$条（前面已计算），那么用于芯片选择的地址线数量为$15 - 11=4$条。
    - 解码器大小：需要一个$4 - to - 16$的解码器（因为$2^{4}=16$，刚好可以选择$32$片中的$16$组，每组$2$片用于扩展数据位）。
    - 解码器输入：输入是高$4$位地址线（用于选择不同的芯片组）。
    - 解码器输出：输出连接到$32$片芯片的片选信号端，每次选择一组芯片（$2$片，用于构成$16$位数据）进行读写操作。

#### 总结
1. （1）芯片有`11`条地址线和`8`条数据线。
2. （2）构建`32k*16 `RAM需要`32`片芯片。
3. （3）`32k*16 `RAM有15条地址线和`16`条数据线。
4. （4）需要一个`4 - to - 16`解码器，输入是高`4`位地址线，输出连接到芯片的片选信号端用于选择芯片组。



---



### 问题6
A computer system uses 16-bit memory addresses. It has a 2k-byte cache organized in a direct-mapped manner with 64 bytes per cache block. Assume that the size of each memory word is 1 byte.
(1) Calculate the number of bits in each of the tag, block and word fields of the memory address.
(2) When a program is executed, the processor reads data sequentially from the following word addresses: 0080H, 0090H, 0880H, 0884H, 0080H, 0880H. Assume that the cache is initially empty. For each of the above addresses, indicate whether the cache access will result in a hit or a miss. 

#### 分析
#### （1）计算内存地址中标记（tag）、块（block）和字（word）字段的位数
1. **首先确定相关参数**：
    - 已知内存地址长度为$16$位。
    - 缓存（cache）大小为$2K$字节，换算成字节数为$2\times1024 = 2048$字节。
    - 每个缓存块（cache block）大小为$64$字节。
    - 每个内存字（memory word）大小为$1$字节。

2. **计算块地址（block）字段的位数**：
    - 缓存中块的数量$N_{block}=\frac{缓存大小}{每个缓存块大小}=\frac{2048}{64} = 32$块。
    - 表示$32$个块需要的地址位数$n_{block}$满足$2^{n_{block}} = 32$，通过计算可得$n_{block}=5$位。

3. **计算字地址（word）字段的位数**：
    - 因为每个缓存块大小为$64$字节，也就是一个块内有$64$个字节（字），表示一个块内字的地址位数$n_{word}$满足$2^{n_{word}} = 64$，可得$n_{word}=6$位。

4. **计算标记（tag）字段的位数**：
    - 内存地址总位数是$16$位，已经确定块地址占$5$位，字地址占$6$位，那么标记字段的位数$n_{tag}=16 - 5 - 6 = 5$位。

#### （2）判断各地址访问缓存时是命中（hit）还是缺失（miss）
1. **将十六进制地址转换为二进制地址（方便按字段分析）**：
    - $0080H$转换为二进制为$0000 0000 1000 0000$。
    - $0090H$转换为二进制为$0000 0000 1001 0000$。
    - $0880H$转换为二进制为$0000 1000 1000 0000$。
    - $0884H$转换为二进制为$0000 1000 1000 0100$。

2. **按标记、块、字字段分析各地址访问情况**：
    - 对于地址$0080H$（$0000 0000 1000 0000$）：
        - 标记（tag）字段：$00000$。
        - 块（block）字段：$00100$。
        - 字（word）字段：$000000$。
        - 由于缓存初始为空，首次访问该地址必然是缺失（miss），会将对应内存块调入缓存。
    - 对于地址$0090H$（$0000 0000 1001 0000$）：
        - 标记（tag）字段：$00000$。
        - 块（block）字段：$00100$（与$0080H$地址的块地址相同）。
        - 字（word）字段：$010000$。
        - 因为之前已经将包含$0080H$地址所在块调入缓存（虽然访问的字不同，但在同一个块内），所以这次访问是命中（hit）。
    - 对于地址$0880H$（$0000 1000 1000 0000$）：
        - 标记（tag）字段：$00001$。
        - 块（block）字段：$00100$。
        - 字（word）字段：$000000$。
        - 其标记与之前缓存中已有的（对应$0080H$地址调入的块）不同，所以是缺失（miss），会重新调入对应内存块到缓存。
    - 对于地址$0884H$（$0000 1000 1000 0100$）：
        - 标记（tag）字段：$00001$。
        - 块（block）字段：$00100$（与$0880H$地址的块地址相同）。
        - 字（word）字段：$000100$。
        - 因为之前已将包含$0880H$地址所在块调入缓存，所以这次访问是命中（hit）。
    - 对于地址$0080H$（第二次访问）：
        - 标记（tag）字段：$00000$。
        - 块（block）字段：$00100$。
        - 字（word）字段：$000000$。
        - 由于之前已经调入过该地址所在块且未被替换（缓存替换策略暂不影响此处，因为前面操作未涉及替换情况），所以这次访问是命中（hit）。
    - 对于地址$0880H$（第二次访问）：
        - 标记（tag）字段：$00001$。
        - 块（block）字段：$00100$。
        - 字（word）字段：$000000$。
        - 之前已经调入过该地址所在块，所以这次访问是命中（hit）。

#### 总结
1. **（1）**
    - 标记（tag）字段的位数为$5$位。
    - 块（block）字段的位数为$5$位。
    - 字（word）字段的位数为$6$位。
2. **（2）**
    - 地址$0080H$第一次访问是缺失（miss），第二次访问是命中（hit）。
    - 地址$0090H$访问是命中（hit）。
    - 地址$0880H$第一次访问是缺失（miss），第二次访问是命中（hit）。
    - 地址$0884H$访问是命中（hit）。 

