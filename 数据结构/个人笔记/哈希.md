# 哈希

## 问题

给出一个集合$L$，包含若干个键值对$(K_j,I_j)$，想要的是如何找到一个键值对，满足$K_j=k$，其中$k$为要查找的键值。

## 方法：查找

- 列表法和顺序法：适合存储在`RAM`中的数据
- 通过键值直接访问：哈希，适合存储在`RAM`或者在磁盘上的数据
- 树索引：适合查找在磁盘上的内容。

---------

### 对于无序数组的查找

- **顺序查找** 在无序列表上的最坏情况下需要 $\Theta(n)$ 时间。

- **线性查找的平均成本**：

  - $p_i$ 是 $K$ 位于列表 $L$ 中第 $i$ 个位置的概率，$i \in [0, n-1]$。
  - $p_n$ 是 $K$ 不在列表 $L$ 中的概率。
  - 当 $K$ 位于位置 $i$ 时，需要 $(i + 1)$ 次比较。
  - 当 $K$ 不在 $L$ 中时，需要 $n$ 次比较。

  - 平均成本 $T(n)$ 计算公式：
    $$
    T(n) = n p_n + \sum_{i=0}^{n-1} (i+1) p_i
    $$

  - 如果所有的 $p_i$（除了 $p_n$）相等，即 $n \cdot p + p_n = 1$：

    $$
    T(n) = n p_n + \sum_{i=0}^{n-1} (i+1) p = p_n n + p \frac{n(n+1)}{2} = \frac{n+1 + p_n (n-1)}{2}
    $$

  - 依据 $p_n$ 的值，有：
    $$
    \frac{n+1}{2} \leq T(n) \leq n
    $$
    

---

### 对于有序数组的查找

- **当数组元素有序时**：

  - 元素 $i$ 与 $K$ 的一次比较可以排除从位置 $0$ 到 $i-1$ 的元素（或从位置 $i+1$ 到 $n$ 的元素）。

- **跳跃查找 (Jump search)**：
  - 对于某个值 $j$，我们检查列表 $L$ 中每隔 $j$ 个元素，即 $L[j]$、$L[2j]$ 等。
  - 只要 $K$ 大于所检查的值，就继续向后检查。
  - 如果 $L[mj] < K < L[(m+1)j]$，则在范围 $(L[mj], L[(m+1)j])$ 内检查 $j-1$ 个元素。

  - 总成本（比较次数）为：
    $$
    T(n, j) = m + j - 1 = \left\lfloor \frac{n}{j} \right\rfloor + j - 1
    $$

  - 当 $j = \sqrt{n}$ 时，$T(n, j)$ 达到最小值。

- 也可采用分治法，最常见的就是二分查找。

---

## 哈希表

实现$O(1)$查找和插入。

### 直接地址法

假设：

- 键值是整数，且在$U=\{ 0,1.....m-1 \}$范围内，$m$ 小。
- 没有两个键值是相同的。

实现：

- 对应的数据存储在$array[key]$即可。

```cpp
delete(Table T, ElementType x):
	T[key[x]] = null;
	
insert(Table T, ElementType x):
	T[key[x] = x;
      
Find(Table T, Key k):
	return T[k];
```



**可能存在的问题**

$U$太大，可能浪费了太多空间，甚至无法存储到内存中，理想情况是基本上$U$的所有键值都被使用到，且$U$的范围（也就是$m$）比较小，可以采用映射法解决这个问题。

![](https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411051452199.webp)

具体方法：

- 将$N$个数据存储在大小为$M$的表中
- 每个数据的位置（表索引）是由键值$Key$通过哈希函数计算得到的。
- 需要处理哈希冲突（索引冲突）的问题。

主要思想：

- 通过键值直接索引到数组下标位置。
- 访问时间为$O(1)$。



问题的关键在于哈希函数：

哈希函数：

- 将字符串或者其他数据类型转换为整数$i$，利用这个整数索引到数组位置$array[i]$
- $i$需要小于数组大小
- $i$尽可能均匀分布。

