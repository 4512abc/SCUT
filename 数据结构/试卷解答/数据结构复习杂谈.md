# 数据结构复习杂谈

复习中遇到的一些问题，记录一下。

### 向一个有 127 个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动（ ）个元素。

- **选项：**
  - A. 8
  - B. 63.5
  - C. 63
  - D. 7

**答案：B**。

假设只有3个元素，那么一共有4个位置可以插入：

```css
[] 1 [] 2 [] 3 []
```

那么平均情况下需要$(\frac{1+2+3}{4})=1.5$，可以得到计算公式：
$$
\frac{\frac{(n+1)n}{2}}{n+1}= \frac{n}{2}
$$
所以答案是$63.5$。



如果是删除，假设有四个元素：

```css
1 2 3 4
```

删除第一个，需要移动3个元素，删除第二个，需要移动2个元素，后面依次 1 个 0 个元素。

所以是$\frac{3+2+1+0}{4}=1.5$。

得到一般公式：
$$
\frac{\frac{n(n-1)}{2}}{n}=\frac{n-1}{2}
$$

### 若让元素 1，2，3 依次进栈，则出栈次序不可能出现哪种情况（ ）。

- **选项：**
  - A. 3，2，1
  - B. 2，1，3
  - C. 3，1，2
  - D. 1，3，2
- **答案：** **C. 3，1，2**：
- **不可能**。如果 3 出栈后，栈中剩下的顺序是 1、2，因此 1 必须先于 2 出栈。而这个顺序无法通过任何合法的栈操作实现，因为 3 弹出后不可能将 1 留在栈内再弹出 2。



下面存疑

注意是可以插入到一半后出栈。


1. 对序列 (49,38,65,97,76,27,13,50) 采用快速排序法进行排序，以序列的第一个元素为基准元素得到的划分结果是 **[13 27 38] 49 [50 65 76 97]**。
- **解释：** 使用 49 作为基准元素进行快速排序，会将小于 49 的元素分到基准元素左边，大于基准元素的元素分到右边。



下面存疑

判定一个循环队列 QU（最多元素为 m）为满队列的条件是 **(rear + 1) % m == front**。

- **解释：** 在循环队列中，如果 `rear` 指向最后一个元素，则 `rear + 1` 指向队列的头部。如果这个位置正好等于 `front` 的位置，表示队列已满。



快速排序在平均情况下的空间复杂度为 **O(log⁡n)**，在最坏情况下的空间复杂度为 **O(n)**。

- **解释：** 在快速排序的平均情况下，递归的深度为 O(log⁡n)，因为每次划分大约将问题规模减半；而在最坏情况下（例如已排序或逆序数组），递归深度为 n，因此空间复杂度为 O(n)。





**（y）** 直接选择排序是一种不稳定的排序方法。

- **解释：** 直接选择排序在相同关键字的元素之间可能会改变它们的相对位置，因此是一个不稳定的排序算法。

**（n）** 折半搜索只适用于有序表，包括有序的顺序表和有序的链表。

- **解释：** 折半搜索仅适用于有序的顺序表（数组）而不适用于链表，因为链表的访问时间是线性的，不能高效地直接访问中间元素。

**（n）** 数据结构是指相互之间存在一种或多种关系的数据元素的全体。

- **解释：** 数据结构不仅仅是数据元素的集合，更重要的是它们之间的关系和组织方式。

**（n）** 若有一个叶子结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点。

- **解释：** 前序遍历的最后一个节点不一定是中序遍历的最后一个节点，因为前序遍历先访问根节点而后访问子树，不能确定其在中序中的相对位置。

**（y）** 最优二叉搜索树的任何子树都是最优二叉搜索树。

- **解释：** 最优二叉搜索树的定义是为了优化搜索效率，因此其任何子树也应满足最优性质。

**（y）** 有 n（n≥1）个顶点的有向强连通图最少有 n 条边。

- **解释：** 有向强连通图要求每一对顶点都有路径相连，至少需要 n 条边以保持这种连通性。

**（n）** 连通分量是无向图中的极小连通子图。

- **解释：** 连通分量是指图中所有的连通子图，而不是 “极小” 的，因为连通分量可以包含多个顶点。





#### 顺序表的优缺点

- **优点**：
  - 存取速度快：顺序存储结构下，元素在内存中是连续存放的，支持 O (1) 的随机访问。
  - 占用内存小：结构简单，内存管理相对容易。
- **缺点**：
  - 插入和删除操作不灵活：需要移动大量元素，时间复杂度为 O (n)。
  - 预先需要分配固定大小的内存，可能导致内存浪费或溢出。

#### 链表的优缺点

- **优点**：
  - 插入和删除操作灵活：只需改变节点指针，时间复杂度为 O (1)。
  - 不需要预先分配固定大小的内存，支持动态扩展。
- **缺点**：
  - 存取速度慢：需要逐个访问节点，随机访问时间复杂度为 O (n)。
  - 额外的内存开销：每个节点除了存储数据外，还需要存储指针。



**中文题目**:
下列哪个选项是不正确的？

**英文题目**:
Which statement is not correct among the following four:

(A) 非空二叉树中空子树的数目比节点数少一个。
(The number of empty sub-trees in a non-empty binary tree is one less than the number of nodes in the tree.)
(B) 归并排序是一种稳定的排序算法。
(The Mergesort is a stable sorting algorithm.)
(C) 一棵通用树可以转换为一棵二叉树，且根节点只有左子节点。
(A general tree can be transferred to a binary tree with the root having only left child.)
(D) 扇区是记录分配的最小单位，所以所有记录的大小都是扇区大小的倍数。
(A sector is the smallest unit of allocation for a record, so all records occupy a multiple of the sector size.)

**答案**:
(A) 非空二叉树中空子树的数目比节点数少一个。
(The number of empty sub-trees in a non-empty binary tree is one less than the number of nodes in the tree.)

**解释**:
(A) 这个说法是不正确的。对于一棵有 n 个节点的二叉树，它有 2n 个子树，其中 n 个子树为空。如果树是空的，没有节点，这个说法显然不成立。

> 解释一下题目 3 中的选项 (A) 为什么是不正确的：
>
> **选项 (A)** 的原文是：“非空二叉树中空子树的数目比节点数少一个。”
> 这意味着它说的是，如果你有一棵非空的二叉树，空子树的数目应该比节点的数目少一个。
>
> 首先，**什么是空子树？**
>
> - 空子树是指节点没有子节点的情况下，其左子树或右子树为空。例如，如果一个节点没有左子节点或右子节点，那么该位置就是空子树。
>
> **分析为什么选项 (A) 是错误的：**
>
> 1. **正确的空子树计数方法：**
>    在一棵有 n 个节点的二叉树中，总共有 2n 个可能的子树位置（每个节点都有左右两个子树）。其中，空子树的数目等于没有左子节点或者右子节点的情况。对于每个节点，它可能有左子树、右子树、两个子树或者都没有子树。
> 2. **正确的公式：**
>    一个二叉树中，空子树的数目实际上是 n+1。原因是，二叉树的总子树数等于 2n（每个节点都有两个子树位置），其中 n 个位置被实际节点占用，剩下的 n+1 个位置是空的。
> 3. **示例**：
>    假设有一棵二叉树，里面有 3 个节点（根节点和两个子节点）。这棵树有 4 个可能的子树位置：根的左子树、根的右子树、子节点的左子树和右子树。其中 1 个位置有节点（根节点），另外 3 个位置为空。所以这棵树有 3 个空子树，符合 n+1 的规律。
>
> 因此，选项 (A) 中的描述 “空子树的数目比节点数少一个” 是不正确的，因为空子树的数目实际上是比节点数多一个，而不是少一个。
>
> **总结**：
>
> - 在非空二叉树中，空子树的数目是 n+1，而选项 (A) 说的是空子树比节点少一个，说明它错误地描述了空子树的数目。





## 栈的运用

### 问题 (a)：

给定一个字符串，判断其中的括号是否是平衡的且正确嵌套的。如果括号正确嵌套，则返回 `true`，否则返回 `false`。使用栈来跟踪已看到的左括号的数量。提示：在扫描合法的字符串时，左括号的数量始终不小于右括号的数量。

### 解答 (a)：

我们可以使用栈来跟踪左括号的数量。扫描字符串时，遇到左括号时将其推入栈中，遇到右括号时检查栈是否为空。如果栈为空，则表示有多余的右括号。如果栈最终非空，则表示有多余的左括号。

### 算法步骤：

1. 初始化一个空栈。

2. 从左到右扫描字符串：

   - 如果遇到左括号 `'('`，将其压入栈中。

   - 如果遇到右括号

      

     ```
     ')'
     ```

     ，检查栈是否为空：

     - 如果栈为空，说明右括号没有匹配的左括号，返回 `false`。
     - 如果栈非空，弹出栈顶元素，表示匹配了一个左括号。

3. 如果扫描完成后栈为空，返回 `true`，否则返回 `false`。

### 代码 (a)：

```
cpp
#include <iostream>
#include <stack>
using namespace std;

bool areParenthesesBalanced(const string& str) {
    stack<char> s;  // 用栈来存储左括号

    for (char ch : str) {
        if (ch == '(') {
            s.push(ch);  // 遇到左括号，压入栈
        } else if (ch == ')') {
            if (s.empty()) {
                return false;  // 遇到右括号，但栈为空，表示多余的右括号
            }
            s.pop();  // 匹配到左括号，弹出栈顶元素
        }
    }

    return s.empty();  // 如果栈为空，表示括号匹配成功
}

int main() {
    string str = "((())())()";
    if (areParenthesesBalanced(str)) {
        cout << "Parentheses are balanced." << endl;
    } else {
        cout << "Parentheses are not balanced." << endl;
    }
    return 0;
}
```

### 解释：

- **栈操作**：使用栈来存储每个左括号的位置，遇到右括号时判断栈是否为空，如果为空则表示不平衡，否则弹出栈顶元素。
- **时间复杂度**：`O(n)`，其中 `n` 是字符串的长度。我们只需扫描一遍字符串。
- **空间复杂度**：`O(n)`，栈最多需要存储所有左括号的位置。

### 问题 (b)：

给定一个字符串，返回第一个不匹配的括号的位置（如果存在），否则返回 `-1`。如果字符串中有过多的右括号，返回第一个多余右括号的位置；如果有过多的左括号，返回第一个多余左括号的位置。

### 解答 (b)：

我们可以使用栈来存储左括号的位置，并在扫描过程中跟踪不匹配的括号。当遇到右括号时，如果栈为空，表示多余的右括号；如果扫描结束时栈非空，表示有多余的左括号。

### 算法步骤：

1. 初始化一个空栈。

2. 从左到右扫描字符串：

   - 如果遇到左括号 `'('`，将其位置压入栈中。

   - 如果遇到右括号

      

     ```
     ')'
     ```

     ：

     - 如果栈为空，返回当前位置，表示发现多余的右括号。
     - 如果栈非空，弹出栈顶元素，表示匹配到左括号。

3. 扫描完成后，如果栈非空，返回栈顶元素的位置，表示多余的左括号；如果栈为空，则返回 `-1`，表示括号匹配成功。

### 代码 (b)：

```
cpp
#include <iostream>
#include <stack>
using namespace std;

int firstUnbalancedParenthesis(const string& str) {
    stack<int> s;  // 用栈来存储左括号的位置

    for (int i = 0; i < str.size(); i++) {
        if (str[i] == '(') {
            s.push(i);  // 遇到左括号，压入栈
        } else if (str[i] == ')') {
            if (s.empty()) {
                return i;  // 遇到右括号，但栈为空，表示多余的右括号
            }
            s.pop();  // 匹配到左括号，弹出栈顶元素
        }
    }

    if (!s.empty()) {
        return s.top();  // 栈非空，表示有多余的左括号，返回第一个多余左括号的位置
    }

    return -1;  // 如果没有多余括号，表示括号匹配成功
}

int main() {
    string str = "())(";
    int result = firstUnbalancedParenthesis(str);
    if (result == -1) {
        cout << "Parentheses are balanced." << endl;
    } else {
        cout << "First unbalanced parenthesis is at position: " << result << endl;
    }
    return 0;
}
```

### 解释：

- **栈操作**：我们使用栈存储左括号的位置。当遇到右括号时，检查栈是否为空。如果为空，则表示多余的右括号，返回其位置；如果栈非空，则弹出栈顶元素。

- 返回值

  ：

  - 如果发现多余的右括号，返回其位置。
  - 如果扫描完成后栈非空，返回栈顶元素的位置，表示多余的左括号。
  - 如果括号匹配成功，返回 `-1`。

### 时间复杂度：

- 时间复杂度：`O(n)`，其中 `n` 是字符串的长度。我们只需扫描一遍字符串。
- 空间复杂度：`O(n)`，栈最多存储所有左括号的位置。

### 示例：

对于字符串 `())(`，程序将返回位置 `2`，因为第一个多余的右括号出现在位置 `2`。





###  循环队列**__**。

- A. 不会产生下溢出
- B. 不会产生上溢出
- C. 不会产生假溢出
- D. 以上都不对

**正确答案**: C. 不会产生假溢出
**解析**: 循环队列通过将队列的尾指针与头指针进行循环连接，避免了线性队列中的假溢出现象，但仍可能发生上溢出和下溢出。



### 17. 一个稀疏矩阵采用压缩后，和直接采用二维数组存储相比会失去**__** 特性。

- A. 顺序存储
- B. 随机存取
- C. 输入输出
- D. 以上都不对

**正确答案**: B. 随机存取

**解析**: 压缩存储稀疏矩阵时，通常不再保留矩阵的随机存取特性，数据元素的存储位置不再连续，可能需要额外的查找操作。



### 若一棵二叉树具有 10 个度为 2 的结点，5 个度为 1 的结点，则度为 0 的结点个数为**__**。

- A. 9
- B. 11
- C. 15
- D. 不确定

**正确答案**: B. 11

**树的度是指出度。**



###  高度为 5 的二叉树至少有**__** 个结点。

- 选项:
  - A. 5
  - B. 6
  - C. 7
  - D. 31
- **正确答案**: A. 5
- **解释**: 二叉树的高度是从根节点到最深叶子节点的最长路径上的边数。高度为 5 的二叉树至少需要有 5 个结点（最小情况下，形状为链状）。

**不是满二叉树，而是二叉树**



### 一个有 n 个顶点的无向图最多有**__** 条边。

- 选项

  :

  - A. n
  - B. n(n-1)
  - C. n(n-1)/2
  - D. 2n

- **正确答案**: C. n(n−1)2

- **解释**: 在无向图中，任意两个顶点之间最多有一条边，因此最多的边数为 n(n−1)2。

  **注意要除以2**

- **正确答案**: B. 按长度递增的顺序
- **解释**: Dijkstra 算法通过优先选择当前路径长度最小的节点来逐步更新到其余节点的最短路径。



### 关键路径是事件结点网络中**__**。

- 选项:
  - A. 从源点到汇点的最长路径
  - B. 从源点到汇点的最短路径
  - C. 最长的回路
  - D. 最短的回路
- **正确答案**: A. 从源点到汇点的最长路径
- **解释**: 关键路径是确保项目按时完成所需的最长路径，标识出项目中的关键活动。



### **在哈希查找过程中，可用\**__\** 来处理冲突。**

A. 除留余数法
B. 数字分析法
C. 线性探测法
D. 关键字比较法

**正确答案：** C
**解析：** 哈希查找是一种通过哈希函数将关键字映射到哈希表位置的方法，但当两个或多个关键字映射到相同的地址（即哈希冲突）时，需要采用解决冲突的方法。线性探测法是一种处理哈希冲突的开放寻址法，简单来说就是在冲突发生后，向后查找下一个可用的位置，从而实现插入、删除或查找操作。这种方法简单易实现，但在负载因子高时可能会导致性能下降。



###  **哈希表中出现同义词冲突是指\**__\**。**

A. 两个元素具有相同的序号
B. 两个元素的关键字不同，而其他属性相同
C. 数据元素过多
D. 两个元素的关键字不同，而对应的哈希函数值相同

**正确答案：** D
**解析：** 同义词冲突发生在哈希表中，当两个不同的关键字经过哈希函数计算后得到相同的哈希值（即同一地址），导致它们无法正确地存储或访问。这种冲突是哈希表设计中需要解决的重要问题，合理的哈希函数和冲突处理策略对于哈希表的效率至关重要。



### **以下排序方法中，\**__\** 不需要进行关键字的比较。**

A. 快速排序
B. 二路归并排序
C. 基数排序
D. 堆排序

**正确答案：** C
**解析：** 基数排序是一种非比较排序算法，它基于数字的位数对数据进行排序，而不是通过直接比较元素的大小。基数排序首先根据最低位进行排序，然后根据次低位排序，依此类推，最终形成有序序列。由于不涉及元素间的比较，基数排序在某些情况下（例如处理大量整数数据）具有较快的排序速度。



**存疑**

### **线性表的顺序存储结构是一种（）。**

A. 随机存取的存储结构
B. 顺序存取的存储结构
C. 索引存取的存储结构
D. 散列存取的存储结构

**正确答案：** A
**解析：** 顺序存储结构是通过连续的内存空间来存储线性表中的元素，这样可以通过计算地址快速访问任意元素，实现随机存取。每个元素的地址可以通过基地址和元素的索引计算得出，这种存取方式的时间复杂度为 O (1)。而顺序存取是一种读写方式，强调的是数据的访问顺序，而非其存储方式。





### 以下关于顺序表的叙述中，正确的是（）。

- **A.** 顺序表可以利用一维数组表示，因此顺序表与一维数组在结构上是一致的，它们可以通用
- **B.** 在顺序表中，逻辑上相邻的元素在物理位置上不一定相邻
- **C.** 顺序表和一维数组一样，都可以进行随机存取
- **D.** 在顺序表中每一个元素的类型不必相同

**正确答案:** C. 顺序表和一维数组一样，都可以进行随机存取

**解析:**
顺序表中所有元素必须连续存放，而一维数组中所有元素可以不连续存放，另外，一维数组只有按下标的存、取两个操作，而顺序表可以进行线性表的插入、删除等操作，所以选项 A 错误。在顺序表中，逻辑上相邻的元素在物理位置上也一定相邻，所以选项 B 错误。顺序表中每一个元素的类型必须相同，所以选项 D 错误。



### **关于串的叙述，正确的是（ ）。**

A. 串是含有一个或多个字符的有穷序列
B. 空串是只含有空格字符的串
C. 空串是含有零个字符或含有空格字符的串
D. 串是含有零个或多个字符的有穷序列

**正确答案：** D. 串是含有零个或多个字符的有穷序列



### **下面关于串的叙述中，正确的是（ ）。**

A. 串是一种特殊的线性表
B. 串中元素只能是字母
C. 空串就是空白串
D. 串的长度必须大于零

**正确答案：** A. 串是一种特殊的线性表



### **关于串的叙述，不正确的是（ ）。**

A. 串是字符的有限序列
B. 空串是由空格构成的串
C. 替换是串的一种重要运算
D. 串既可以采用顺序存储，也可以采用链式存储

**正确答案：** B. 空串是由空格构成的串



### **以下关于二叉树遍历的说法中，正确的是（ ）。**

A. 二叉树遍历就是访问二叉树中所有的结点
B. 二叉树遍历就是访问二叉树中部分结点
C. 二叉树遍历就是按照某种规律访问二叉树中所有的结点，且每个结点仅访问一次
D. 二叉树遍历就是随机访问二叉树中所有的结点，且每个结点仅访问一次

**正确答案：** C. 二叉树遍历就是按照某种规律访问二叉树中所有的结点，且每个结点仅访问一次



### **引入线索二叉树的目的是（ ）**

A. 加快查找结点的前趋或后继结点的速度
B. 为了能在二叉树中方便插入和删除
C. 为了能方便找到双亲
D. 使二叉树的遍历结果唯一

**正确答案**
A. 加快查找结点的前趋或后继结点的速度

**解析**
线索二叉树通过指针链接前趋和后继结点，从而提高遍历的效率。



###  **一个无向连通图的生成树是含有该连通图的全部顶点的（ ）。**

A. 极小连通子图
B. 极小子图
C. 极大连通子图
D. 极大子图

**正确答案**
A. 极小连通子图



### **冒泡排序最少关键字比较的次数是 ( )。**

A. 0
B. n
C. n-1
D. 3n(n-1)/2

**正确答案**
C. n-1

遍历一次，没有发生交换，说明已经有序。



### 二）平衡二叉树

#### 题目

将关键字序列 \{116, 100, 101, 115, 117, 103\} 依次插入到初始为空的平衡二叉树（AVL 树），给出每插入一个关键字后的平衡树，并说明其中可能包含的平衡调整步骤（即，先说明是哪个结点失去平衡，然后说明做了什么平衡处理）；然后分别给出前序、中序和后序遍历该二叉树的输出结果。

------

经过基本的左旋右旋后得到：

注意`（LL,LR,RL,RR)`。

[![image-20241005123229010](https://www.totorocatcat.top/images/image-20241005123229010.png)](https://www.totorocatcat.top/images/image-20241005123229010.png)

> - 前序遍历（根左右）: 115，101，100，103，116，117
> - 中序遍历（左根右）: 100，101，103，115，116，117
> - 后序遍历（左右根）: 100，103，101，117，116，115



### 第一题：给定前序和中序遍历，求后序遍历

**问题描述**：
给定二叉树的前序遍历和中序遍历，要求你输出二叉树的后序遍历结果。

**答案**：
假设前序遍历序列为 `preorder[]`，中序遍历序列为 `inorder[]`，可以通过递归的方法得到后序遍历结果。后序遍历的过程是：首先遍历左子树，再遍历右子树，最后访问根节点。

```
cpp
void postOrder(int preorder[], int inorder[], int startPre, int endPre, int startIn, int endIn) {
    if (startPre > endPre || startIn > endIn) return;

    int root = preorder[startPre];  // 根节点是前序遍历的第一个元素
    int rootIndex = -1;

    // 在中序遍历中找到根节点的位置
    for (int i = startIn; i <= endIn; i++) {
        if (inorder[i] == root) {
            rootIndex = i;
            break;
        }
    }

    // 递归地处理左子树和右子树
    postOrder(preorder, inorder, startPre + 1, startPre + rootIndex - startIn, startIn, rootIndex - 1);
    postOrder(preorder, inorder, startPre + rootIndex - startIn + 1, endPre, rootIndex + 1, endIn);

    cout << root << " ";  // 后序遍历根节点
}
```

**解释**：

1. **前序遍历**的第一个节点是根节点。
2. 在**中序遍历**中，根节点将左右子树分开。
3. 递归地对左右子树进行相同的操作，最终输出后序遍历结果。

**时间复杂度**：

- 每次在中序遍历中查找根节点的时间是 O (n)，递归处理子树的总时间复杂度是 O (n)，因此总时间复杂度为 **O(n)**。



### 第二题：希尔排序

**问题描述**：
这道程序填空题是关于**希尔排序**，有三个空需要填充：

1. **第一个空**：插入排序的细节。
2. **第二个空**：希尔排序的细节，主要涉及步长的选择。
3. **第三个空**：调用一个函数。

**答案**：

```
cpp
// 插入排序的细节
for (int i = gap; i < n; i++) {  
    int temp = arr[i];
    int j = i;
    while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap];
        j -= gap;
    }
    arr[j] = temp;
}

// 步长的选择（使用一个递减的步长序列）
for (gap = n / 2; gap > 0; gap /= 2) {  
    // 调用插入排序的函数
    shellSort(arr, n, gap);
}
```

**解释**：

- **插入排序**：在希尔排序中使用插入排序对每个步长分组进行排序。插入排序的核心是通过逐一比较和交换，确保小元素移到数组的前面。
- **步长选择**：希尔排序的关键在于步长的选择，常见的步长序列是从 `n/2` 开始，逐步减小，通常减半，直到步长为 1。
- **调用插入排序**：在每个步长下，对数组元素执行插入排序，直到整个数组有序。

**时间复杂度**：

- **希尔排序的时间复杂度**是取决于步长序列的，通常在最优情况下为 **O(n log n)**，最差情况下可能为 **O(n^2)**，这取决于步长序列的选择。例如，如果使用较好的步长序列，希尔排序比直接的插入排序快很多。

------

### 第三题：二叉堆（小根堆）的下沉函数

**问题描述**：
这道程序填空题是关于**二叉堆（小根堆）**的**下沉操作**，有两个空需要填充：

1. **第一个空**：完全二叉树的父子关系（根节点索引为 1）。
2. **第二个空**：比较三者（父节点和两个子节点）的大小，取最小的。

**答案**：

```
cpp
// 父子关系的计算（根节点索引为1）
int leftChild = 2 * i;  // 左子节点的索引
int rightChild = 2 * i + 1;  // 右子节点的索引

// 下沉函数
int smallest = i;
if (leftChild <= n && arr[leftChild] < arr[smallest]) {
    smallest = leftChild;
}
if (rightChild <= n && arr[rightChild] < arr[smallest]) {
    smallest = rightChild;
}

if (smallest != i) {
    swap(arr[i], arr[smallest]);
    heapify(smallest);  // 递归调用下沉
}
```

**解释**：

- **父子关系**：在一个完全二叉树中，根节点的索引为 1，左子节点的索引为 `2 * i`，右子节点的索引为 `2 * i + 1`。
- **比较三者的大小**：对于下沉操作，需要检查当前节点与其左右子节点的大小，找到最小的节点，然后交换。
- **下沉操作**：如果当前节点不是最小的节点，就需要交换当前节点和最小的子节点，并递归地对下沉后的节点继续进行调整。

**时间复杂度**：
二叉堆的下沉操作的时间复杂度为 **O(log n)**，因为在最坏情况下需要沿着堆的深度（即高度）进行比较和交换。





### 第一题：给定前序和中序遍历，求后序遍历

**问题描述**：
给定二叉树的前序遍历和中序遍历，要求你输出二叉树的后序遍历结果。

**答案**：
假设前序遍历序列为 `preorder[]`，中序遍历序列为 `inorder[]`，可以通过递归的方法得到后序遍历结果。后序遍历的过程是：首先遍历左子树，再遍历右子树，最后访问根节点。

```
cpp
void postOrder(int preorder[], int inorder[], int startPre, int endPre, int startIn, int endIn) {
    if (startPre > endPre || startIn > endIn) return;

    int root = preorder[startPre];  // 根节点是前序遍历的第一个元素
    int rootIndex = -1;

    // 在中序遍历中找到根节点的位置
    for (int i = startIn; i <= endIn; i++) {
        if (inorder[i] == root) {
            rootIndex = i;
            break;
        }
    }

    // 递归地处理左子树和右子树
    postOrder(preorder, inorder, startPre + 1, startPre + rootIndex - startIn, startIn, rootIndex - 1);
    postOrder(preorder, inorder, startPre + rootIndex - startIn + 1, endPre, rootIndex + 1, endIn);

    cout << root << " ";  // 后序遍历根节点
}
```

**解释**：

1. **前序遍历**的第一个节点是根节点。
2. 在**中序遍历**中，根节点将左右子树分开。
3. 递归地对左右子树进行相同的操作，最终输出后序遍历结果。

**时间复杂度**：

- 每次在中序遍历中查找根节点的时间是 O (n)，递归处理子树的总时间复杂度是 O (n)，因此总时间复杂度为 **O(n)**。

------

### 第二题：AVL 树的插入和平衡

**问题描述**：
给定几个数字，要求插入到 AVL 平衡树中，并进行平衡操作，通常这涉及到**单旋转**的操作。

------

### 第三题：图的邻接表表示、入度计算和拓扑排序

**问题描述**：
给定一个有向图，要求用邻接表表示并计算每个节点的入度，最后进行拓扑排序。

**答案**：

1. **邻接表表示**：

```
cpp
// 图的邻接表表示
vector<vector<int>> adjList(n);  // n为节点数
for (int i = 0; i < m; i++) {    // m为边的数量
    int u, v;
    cin >> u >> v;
    adjList[u].push_back(v);  // 从u到v有一条边
}
```

1. **计算入度**：

```
cpp
vector<int> inDegree(n, 0);  // 初始化入度为0
for (int u = 0; u < n; u++) {
    for (int v : adjList[u]) {
        inDegree[v]++;  // v的入度加1
    }
}
```

1. **拓扑排序**：

```
cpp
queue<int> q;
for (int i = 0; i < n; i++) {
    if (inDegree[i] == 0) {
        q.push(i);  // 入度为0的节点入队
    }
}

vector<int> topoOrder;
while (!q.empty()) {
    int node = q.front();
    q.pop();
    topoOrder.push_back(node);

    // 更新邻接表中相邻节点的入度
    for (int neighbor : adjList[node]) {
        if (--inDegree[neighbor] == 0) {
            q.push(neighbor);
        }
    }
}

if (topoOrder.size() == n) {
    // 输出拓扑排序结果
    for (int node : topoOrder) {
        cout << node << " ";
    }
} else {
    cout << "图中有环，无法进行拓扑排序" << endl;
}
```

**解释**：

- **邻接表表示**：图中的每个节点通过一个数组存储其所有相邻的节点。
- **入度计算**：遍历图的所有边，对每个边的目标节点的入度加 1。
- **拓扑排序**：使用 Kahn 算法，利用一个队列存储入度为 0 的节点，并逐步减少其相邻节点的入度，直到所有节点被处理。

**时间复杂度**：

- **邻接表表示**：时间复杂度为 **O(m)**，其中 m 是边的数量。
- **计算入度**：时间复杂度为 **O(m)**。
- **拓扑排序**：时间复杂度为 **O(n + m)**，其中 n 是节点数，m 是边数。





### 第四题：哈希和双哈希

**问题描述**：
给定一些数字，要求将其映射到哈希表中，并使用双哈希法解决冲突。

**答案**：

1. **哈希映射**：通过哈希函数将数值映射到哈希表中。
2. **双哈希法**：在发生冲突时，使用第二个哈希函数进行再哈希。

```
cpp
#define TABLE_SIZE 10

// 哈希函数
int hash1(int key) {
    return key % TABLE_SIZE;
}

// 双哈希函数
int hash2(int key) {
    return 7 - (key % 7);  // 第二个哈希函数，常用质数7
}

// 插入哈希表
void insert(int hashTable[], int key) {
    int index = hash1(key);
    if (hashTable[index] == -1) {
        hashTable[index] = key;
    } else {
        int i = 1;
        while (hashTable[(index + i * hash2(key)) % TABLE_SIZE] != -1) {
            i++;
        }
        hashTable[(index + i * hash2(key)) % TABLE_SIZE] = key;
    }
}
```

**解释**：

- **哈希函数**：使用一个简单的取模运算来将键映射到哈希表的索引。
- **双哈希**：当发生冲突时，使用第二个哈希函数计算步长来查找下一个位置。

**时间复杂度**：

- **哈希插入**：在最坏情况下

时间复杂度为 **O(1)**，但在发生冲突时，双哈希的时间复杂度可能会变成 **O(n)**，其中 n 是表的大小。



### 问题：期末考试分数排序与排名

期末考试结束了，教授想要了解第几名是谁，要求所使用的算法是 **O(n log n)** 级别的，且 **额外的空间开销为 O (1)**。

#### （1）你想用什么数据结构，说说你的设计。（10 分）

**答案**：
我们可以使用**原地排序算法**来解决这个问题，最常用的满足 O (n log n) 时间复杂度并且额外空间开销为 O (1) 的排序算法是**堆排序**。堆排序是一种原地排序算法，使用堆这种数据结构来完成排序，并且它的时间复杂度为 O (n log n)，额外空间开销为 O (1)。

**设计说明**：

- 使用**最大堆**来组织分数。在最大堆中，父节点的值总是大于或等于其子节点的值，因此根节点是当前堆中的最大元素。
- 堆排序的过程中，不需要额外的存储空间，只需通过交换堆顶元素和堆的最后一个元素来实现排序。每次调整堆结构，堆的大小减小，直到堆完全排序。

------

#### （2）用什么算法？写出伪代码。（10 分）

**答案**：
可以使用**堆排序**算法，具体的步骤如下：

1. **构建最大堆**。
2. **交换堆顶元素和堆的最后一个元素**。
3. **减少堆的大小**并调整堆。

**伪代码**：

```
text
HeapSort(arr):
    // Step 1: Build a max heap
    for i = n/2 - 1 to 0:   // 从最后一个非叶节点开始调整堆
        MaxHeapify(arr, i, n)

    // Step 2: Perform heap sort
    for i = n - 1 down to 1:
        // Swap the root (maximum element) with the last element
        Swap(arr[0], arr[i])
        // Reduce the heap size by 1
        MaxHeapify(arr, 0, i)  // Restore the max heap property

MaxHeapify(arr, i, n):
    left = 2 * i + 1
    right = 2 * i + 2
    largest = i

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        Swap(arr[i], arr[largest])
        MaxHeapify(arr, largest, n)
```

**解释**：

- **Build Max Heap**：首先构建最大堆，使得每个父节点大于其子节点，根节点即为最大元素。
- **MaxHeapify**：调整堆的结构，确保堆的性质（父节点大于子节点）在交换后依然成立。
- **Swap**：交换堆顶元素和最后一个元素，并逐步调整堆的结构以恢复最大堆的性质。

------

#### （3）说说你的算法的时间和空间开销。（5 分）

**答案**：

- **时间复杂度**：
  - **建堆**（MaxHeapify）需要 O (n) 时间，具体来说，它从最后一个非叶子节点开始，调整每个节点的堆结构。每次调整操作最多进行 O (log n) 的比较和交换，因此总时间复杂度为 O (n)。
  - **堆排序**的主循环需要 O (n log n) 的时间，因为每次都要执行 O (log n) 的堆调整操作，而堆调整操作在交换堆顶元素时进行。循环执行 n 次，因此总时间复杂度为 O (n log n)。
- **空间复杂度**：
  - 堆排序是一个**原地排序算法**，其主要的空间开销仅用于存储输入数组，不需要额外的存储空间。
  - 除了输入数组，算法没有额外的数据结构开销，所有的操作都在输入数组上进行，因此空间复杂度为 **O(1)**（不包括输入数组的存储空间）。

**总结**：

- **时间复杂度**：O(n log n)
- **空间复杂度**：O(1)