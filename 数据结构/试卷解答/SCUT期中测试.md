## SCUT期中测试

1．什么是抽象数据类型？试用C++的类声明定义“复数”的抽象数据类型。要求
	(1) 在复数内部用浮点数定义它的实部和虚部。
	(2) 实现3个构造函数：缺省的构造函数没有参数；第二个构造函数将双精度浮点数赋给复数的实部，虚部置为0；第三个构造函数将两个双精度浮点数分别赋给复数的实部和虚部。
	(3) 定义获取和修改复数的实部和虚部，以及+、-、*、/等运算的成员函数。
	(4) 定义重载的流函数来输出一个复数。

2 试编写一个函数计算n!*2n的值，结果存放于数组A[arraySize]的第n个数组元素中，0  n  arraySize。若设计算机中允许的整数的最大值为maxInt，则当n > arraySize或者对于某一个k (0  k  n)，使得k!*2k > maxInt时，应按出错处理。可有如下三种不同的出错处理方式：
	(1) 用cerr<<及exit (1)语句来终止执行并报告错误；
	(2) 用返回整数函数值0, 1来实现算法，以区别是正常返回还是错误返回；
	(3) 在函数的参数表设置一个引用型的整型变量来区别是正常返回还是某种错误返回。
	试讨论这三种方法各自的优缺点，并以你认为是最好的方式实现它。
3.   (1) 在下面所给函数的适当地方插入计算次数的计数器count的语句：
		void d (ArrayElement x[ ], int n ) {
		   int i = 1;
	do {
			  x[i] += 2;

 				i +=2;
 		   } while (i <= n );
;		i = 1;
		   while ( i <= (n/2) ) {
x[i] += x[i+1];
 i++;		   }
}

(2) 将由(1)所得到的程序化简。使得化简后的程序与化简前的程序具有相同的count值。

(3) 程序执行结束时的count值是多少？

(4) 使用执行频度的方法计算这个程序的程序步数，画出程序步数统计表。

4 设n个人围坐在一个圆桌周围，现在从第s个人开始报数，数到第m个人，让他出局；然后从出局的下一个人重新开始报数，数到第m个人，再让他出局，……，如此反复直到所有的人全部出局为止。下面要解决的Josephus问题是：对于任意给定的n, s和m，求出这n个人的出局序列。请以n = 9, s = 1, m = 5为例，人工模拟Josephus的求解过程以求得问题的解。







5. 设有一个二维数组A[m][n]，假设A[0][0]存放位置在644(10)，A[2][2]存放位置在676(10)，每个元素占一个空间，问A[3][3](10)存放在什么位置？脚注(10)表示用10进制表示。









6. 设有一个nn的对称矩阵A，如图(a)所示。为了节约存储，可以只存对角线及对角线以上的元素，或者只存对角线或对角线以下的元素。前者称为上三角矩阵，后者称为下三角矩阵。我们把它们按行存放于一个一维数组B中，如图(b)和图(c)所示。并称之为对称矩阵A的压缩存储方式。试问：
(1)	存放对称矩阵A上三角部分或下三角部分的一维数组B有多少元素？
(2)	若在一维数组B中从0号位置开始存放，则如图(a)所示的对称矩阵中的任一元素aij在只存上三角部分的情形下(图(b))应存于一维数组的什么下标位置？给出计算公式。
(3) 若在一维数组B中从0号位置开始存放，则如图(a)所示的对称矩阵中的任一元素aij在只存下三角部分的情形下(图(c))应存于一维数组的什么下标位置？给出计算公式。







7. 编写一个算法frequency，统计在一个输入字符串中各个不同字符出现的频度。用适当的测试数据来验证这个算法。










8 试编写一个算法，在带表头结点的单链表中寻找第i个结点。若找到，则函数返回第i个结点的地址；若找不到，则函数返回0。













9 试设计一个实现下述要求的Locate运算的函数。设有一个带表头结点的双向链表L，每个结点有4个数据成员：指向前驱结点的指针prior、指向后继结点的指针next、存放数据的成员data和访问频度freq。所有结点的freq初始时都为0。每当在链表上进行一次Locate (L, x)操作时，令元素值为x的结点的访问频度freq加1，并将该结点前移，链接到与它的访问频度相等的结点后面，使得链表中所有结点保持按访问频度递减的顺序排列，以使频繁访问的结点总是靠近表头。
10.改写顺序栈的进栈成员函数Push (x )，要求当栈满时执行一个stackFull ( )操作进行栈满处理。其功能是：动态创建一个比原来的栈数组大二倍的新数组，代替原来的栈数组，原来栈数组中的元素占据新数组的前MaxSize位置



11 铁路进行列车调度时, 常把站台设计成栈式结构的站台，如右图所示。试问：
（1）设有编号为1,2,3,4,5,6的六辆列车, 顺序开入栈式结构的站台, 则可能的出栈序列有多少种?

(2) 若进站的六辆列车顺序如上所述, 那么是否能够得到435612, 325641, 154623和135426的出站序列, 如果不能, 说明为什么不能; 如果能, 说明如何得到(即写出"进栈"或"出栈"的序列)。





12. 试证明：若借助栈可由输入序列1, 2, 3, …, n得到一个输出序列p1, p2, p3, …, pn (它是输入序列的某一种排列)，则在输出序列中不可能出现以下情况，即存在i < j < k，使得pj < pk < pi。(提示：用反证法)
13. 试建立一个继承结构，以栈、队列和优先级队列为派生类，建立它们的抽象基类——Bag类。写出各个类的声明。统一命名各派生类的插入操作为Add，删除操作为Remove，存取操作为Get和Put，初始化操作为MakeEmpty，判空操作为Empty，判满操作为Full，计数操作为Length。



14. 已知A[n]为整数数组，试写出实现下列运算的递归算法：
	(1) 求数组A中的最大整数。
	(2) 求n个整数的和。
	(3) 求n个整数的平均值。

15【背包问题】设有一个背包可以放入的物品的重量为s，现有n件物品，重量分别为w[1], w[2], …, w[n]。问能否从这n件物品中选择若干件放入此背包中，使得放入的重量之和正好为s。如果存在一种符合上述要求的选择，则称此背包问题有解(或称其解为真)；否则称此背包问题无解(或称其解为假)。试用递归方法设计求解背包问题的算法。（提示：此背包问题的递归定义如下：）


16. 在结点个数为n (n>1)的各棵树中，高度最小的树的高度是多少？它有多少个叶结点？多少个分支结点？高度最大的树的高度是多少？它有多少个叶结点？多少个分支结点？

17. 试分别找出满足以下条件的所有二叉树:
(1) 二叉树的前序序列与中序序列相同; 
(2) 二叉树的中序序列与后序序列相同; 
(3)	二叉树的前序序列与后序序列相同。


18. 写出向堆中加入数据4, 2, 5, 8, 3, 6, 10, 14时，每加入一个数据后堆的变化。



19. 已知一棵二叉树的前序遍历的结果是ABECDFGHIJ, 中序遍历的结果是EBCDAFHIGJ, 试画出这棵二叉树。


20. 假定用于通信的电文仅由8个字母c1, c2, c3, c4, c5, c6, c7, c8组成, 各字母在电文中出现的频率分别为5, 25, 3, 6, 10, 11, 36, 4。试为这8个字母设计不等长Huffman编码, 并给出该电文的总码数。
